=== modified file '3d-viewer/3d_class.cpp'
--- 3d-viewer/3d_class.cpp	2012-08-21 10:45:54 +0000
+++ 3d-viewer/3d_class.cpp	2014-01-24 04:02:01 +0000
@@ -59,7 +59,7 @@
 
 void S3D_MASTER::Copy( S3D_MASTER* pattern )
 {
-    m_Shape3DName = pattern->m_Shape3DName;
+    SetShape3DName( pattern->GetShape3DName() );
     m_MatScale    = pattern->m_MatScale;
     m_MatRotation = pattern->m_MatRotation;
     m_MatPosition = pattern->m_MatPosition;
@@ -74,6 +74,7 @@
     m_MatScale.x  = m_MatScale.y = m_MatScale.z = 1.0;
     m_3D_Drawings = NULL;
     m_Materials   = NULL;
+    m_ShapeType   = FILE3D_NONE;
 }
 
 
@@ -96,6 +97,45 @@
 }
 
 
+bool S3D_MASTER::Is3DType( enum FILE3D_TYPE aShapeType )
+{
+    // type 'none' is not valid and will always return false
+    if( aShapeType == FILE3D_NONE )
+        return false;
+
+    // no one is interested if we have no file
+    if( m_Shape3DName.empty() )
+        return false;
+
+    if( aShapeType == m_ShapeType )
+        return true;
+
+    return false;
+}
+
+
+void S3D_MASTER::SetShape3DName( const wxString& aShapeName )
+{
+    m_ShapeType = FILE3D_NONE;
+    m_Shape3DName = aShapeName;
+
+    if( m_Shape3DName.empty() )
+        return;
+
+    wxFileName fn = m_Shape3DName;
+    wxString ext  = fn.GetExt();
+
+    if( ext == wxT( "wrl" ) || ext == wxT( "x3d" ) )
+        m_ShapeType = FILE3D_VRML;
+    else if( ext == wxT( "idf" ) )
+        m_ShapeType = FILE3D_IDF;
+    else
+        m_ShapeType = FILE3D_UNKNOWN;
+
+    return;
+}
+
+
 STRUCT_3D_SHAPE::STRUCT_3D_SHAPE( EDA_ITEM* aParent ) :
     EDA_ITEM( aParent, NOT_USED )
 {

=== modified file '3d-viewer/3d_draw.cpp'
--- 3d-viewer/3d_draw.cpp	2013-10-13 16:47:11 +0000
+++ 3d-viewer/3d_draw.cpp	2014-01-24 03:00:36 +0000
@@ -857,7 +857,7 @@
 
         for( ; struct3D != NULL; struct3D = struct3D->Next() )
         {
-            if( !struct3D->m_Shape3DName.IsEmpty() )
+            if( struct3D->Is3DType( S3D_MASTER::FILE3D_VRML ) )
                 struct3D->ReadData();
         }
 

=== modified file '3d-viewer/3d_struct.h'
--- 3d-viewer/3d_struct.h	2013-08-28 07:23:14 +0000
+++ 3d-viewer/3d_struct.h	2014-01-24 03:47:55 +0000
@@ -92,13 +92,24 @@
 class S3D_MASTER : public EDA_ITEM
 {
 public:
-    wxString        m_Shape3DName; /* 3D shape name in 3D library */
     S3D_VERTEX      m_MatScale;
     S3D_VERTEX      m_MatRotation;
     S3D_VERTEX      m_MatPosition;
     STRUCT_3D_SHAPE* m_3D_Drawings;
     S3D_MATERIAL*   m_Materials;
 
+    enum FILE3D_TYPE
+    {
+        FILE3D_NONE = 0,
+        FILE3D_VRML,
+        FILE3D_IDF,
+        FILE3D_UNKNOWN
+    };
+
+private:
+    wxString    m_Shape3DName;  /* 3D shape name in 3D library */
+    FILE3D_TYPE m_ShapeType;
+
 public:
     S3D_MASTER( EDA_ITEM* aParent );
     ~S3D_MASTER();
@@ -120,6 +131,20 @@
 #if defined(DEBUG)
     void Show( int nestLevel, std::ostream& os ) const { ShowDummy( os ); } // override
 #endif
+
+    /**
+     * Function Is3DType
+     * returns true if the argument matches the type of model referred to
+     * by m_Shape3DName
+     */
+    bool Is3DType( enum FILE3D_TYPE aShapeType );
+
+    const wxString& GetShape3DName( void )
+    {
+        return m_Shape3DName;
+    }
+
+    void SetShape3DName( const wxString& aShapeName );
 };
 
 

=== modified file 'common/wildcards_and_files_ext.cpp'
--- common/wildcards_and_files_ext.cpp	2013-07-19 18:27:22 +0000
+++ common/wildcards_and_files_ext.cpp	2014-01-23 05:28:58 +0000
@@ -97,4 +97,5 @@
 const wxString ReportFileWildcard = _( "Report files (*.rpt)|*.rpt" );
 const wxString FootprintPlaceFileWildcard = _( "Footprint place files (*.pos)|*.pos" );
 const wxString Shapes3DFileWildcard( _( "Vrml and x3d files (*.wrl *.x3d)|*.wrl;*.x3d" ) );
+const wxString IDF3DFileWildcard( _( "IDFv3 component files (*.idf)|*.idf" ) );
 const wxString TextWildcard( _( "Text files (*.txt)|*.txt" ) );

=== modified file 'include/wildcards_and_files_ext.h'
--- include/wildcards_and_files_ext.h	2013-07-19 18:27:22 +0000
+++ include/wildcards_and_files_ext.h	2014-01-23 05:29:31 +0000
@@ -94,6 +94,7 @@
 extern const wxString ReportFileWildcard;
 extern const wxString FootprintPlaceFileWildcard;
 extern const wxString Shapes3DFileWildcard;
+extern const wxString IDF3DFileWildcard;
 extern const wxString DocModulesFileName;
 extern const wxString LegacyFootprintLibPathWildcard;
 extern const wxString KiCadFootprintLibFileWildcard;

=== modified file 'pcbnew/class_module.cpp'
--- pcbnew/class_module.cpp	2013-12-20 09:15:00 +0000
+++ pcbnew/class_module.cpp	2014-01-24 03:38:25 +0000
@@ -146,7 +146,7 @@
     // Copy auxiliary data: 3D_Drawings info
     for( S3D_MASTER* item = aModule.m_3D_Drawings;  item;  item = item->Next() )
     {
-        if( item->m_Shape3DName.IsEmpty() )           // do not copy empty shapes.
+        if( item->GetShape3DName().IsEmpty() )           // do not copy empty shapes.
             continue;
 
         S3D_MASTER* t3d = m_3D_Drawings;
@@ -270,12 +270,12 @@
 
     for( S3D_MASTER* item = aModule->m_3D_Drawings;  item;  item = item->Next() )
     {
-        if( item->m_Shape3DName.IsEmpty() )           // do not copy empty shapes.
+        if( item->GetShape3DName().IsEmpty() )           // do not copy empty shapes.
             continue;
 
         S3D_MASTER* t3d = m_3D_Drawings;
 
-        if( t3d && t3d->m_Shape3DName.IsEmpty() )       // The first entry can
+        if( t3d && t3d->GetShape3DName().IsEmpty() )    // The first entry can
         {                                               // exist, but is empty : use it.
             t3d->Copy( item );
         }
@@ -530,9 +530,9 @@
     // Search the first active 3D shape in list
     for( S3D_MASTER* struct3D = m_3D_Drawings; struct3D; struct3D = struct3D->Next() )
     {
-        if( !struct3D->m_Shape3DName.IsEmpty() )
+        if( !struct3D->GetShape3DName().IsEmpty() )
         {
-            msg = struct3D->m_Shape3DName;
+            msg = struct3D->GetShape3DName();
             break;
         }
     }

=== modified file 'pcbnew/dialogs/dialog_edit_module_for_BoardEditor.cpp'
--- pcbnew/dialogs/dialog_edit_module_for_BoardEditor.cpp	2013-12-20 09:15:00 +0000
+++ pcbnew/dialogs/dialog_edit_module_for_BoardEditor.cpp	2014-01-24 03:19:53 +0000
@@ -249,12 +249,12 @@
 
     while( draw3D )
     {
-        if( !draw3D->m_Shape3DName.IsEmpty() )
+        if( !draw3D->GetShape3DName().IsEmpty() )
         {
             S3D_MASTER* draw3DCopy = new S3D_MASTER( NULL );
             draw3DCopy->Copy( draw3D );
             m_Shapes3D_list.push_back( draw3DCopy );
-            m_3D_ShapeNameListBox->Append( draw3DCopy->m_Shape3DName );
+            m_3D_ShapeNameListBox->Append( draw3DCopy->GetShape3DName() );
         }
         draw3D = (S3D_MASTER*) draw3D->Next();
     }
@@ -428,11 +428,16 @@
     fullpath.Replace( wxT( "/" ), wxT( "\\" ) );
 #endif
 
+    wxString fileFilters;
+    fileFilters = wxGetTranslation( Shapes3DFileWildcard );
+    fileFilters += wxChar(  '|' );
+    fileFilters += wxGetTranslation( IDF3DFileWildcard );
+
     fullfilename = EDA_FileSelector( _( "3D Shape:" ),
                                      fullpath,
                                      wxEmptyString,
                                      wxEmptyString,
-                                     wxGetTranslation( Shapes3DFileWildcard ),
+                                     wxGetTranslation( fileFilters ),
                                      this,
                                      wxFD_OPEN,
                                      true
@@ -474,7 +479,7 @@
     // Store filename in Unix notation
     shortfilename.Replace( wxT( "\\" ), wxT( "/" ) );
 #endif
-    new3DShape->m_Shape3DName = shortfilename;
+    new3DShape->SetShape3DName( shortfilename );
     m_Shapes3D_list.push_back( new3DShape );
     m_3D_ShapeNameListBox->Append( shortfilename );
 
@@ -606,7 +611,7 @@
     {
         S3D_MASTER* draw3DCopy = m_Shapes3D_list[ii];
 
-        if( draw3DCopy->m_Shape3DName.IsEmpty() )
+        if( draw3DCopy->GetShape3DName().IsEmpty() )
             continue;
 
         if( draw3D == NULL )
@@ -615,7 +620,7 @@
             m_CurrentModule->Models().Append( draw3D );
         }
 
-        draw3D->m_Shape3DName = draw3DCopy->m_Shape3DName;
+        draw3D->SetShape3DName( draw3DCopy->GetShape3DName() );
         draw3D->m_MatScale    = draw3DCopy->m_MatScale;
         draw3D->m_MatRotation = draw3DCopy->m_MatRotation;
         draw3D->m_MatPosition = draw3DCopy->m_MatPosition;

=== modified file 'pcbnew/dialogs/dialog_edit_module_for_Modedit.cpp'
--- pcbnew/dialogs/dialog_edit_module_for_Modedit.cpp	2014-01-02 02:17:07 +0000
+++ pcbnew/dialogs/dialog_edit_module_for_Modedit.cpp	2014-01-24 03:46:39 +0000
@@ -98,12 +98,12 @@
 
     while( draw3D )
     {
-        if( !draw3D->m_Shape3DName.IsEmpty() )
+        if( !draw3D->GetShape3DName().IsEmpty() )
         {
             S3D_MASTER* draw3DCopy = new S3D_MASTER(NULL);
             draw3DCopy->Copy( draw3D );
             m_shapes3D_list.push_back( draw3DCopy );
-            m_3D_ShapeNameListBox->Append( draw3DCopy->m_Shape3DName );
+            m_3D_ShapeNameListBox->Append( draw3DCopy->GetShape3DName() );
         }
         draw3D = (S3D_MASTER*) draw3D->Next();
     }
@@ -292,11 +292,16 @@
     fullpath.Replace( wxT( "/" ), wxT( "\\" ) );
 #endif
 
+    wxString fileFilters;
+    fileFilters = wxGetTranslation( Shapes3DFileWildcard );
+    fileFilters += wxChar(  '|' );
+    fileFilters += wxGetTranslation( IDF3DFileWildcard );
+
     fullfilename = EDA_FileSelector( _( "3D Shape:" ),
                                      fullpath,
                                      wxEmptyString,
                                      wxEmptyString,
-                                     wxGetTranslation( Shapes3DFileWildcard ),
+                                     wxGetTranslation( fileFilters ),
                                      this,
                                      wxFD_OPEN,
                                      true
@@ -339,7 +344,7 @@
     shortfilename.Replace( wxT( "\\" ), wxT( "/" ) );
 #endif
 
-    new3DShape->m_Shape3DName = shortfilename;
+    new3DShape->SetShape3DName( shortfilename );
     m_shapes3D_list.push_back( new3DShape );
     m_3D_ShapeNameListBox->Append( shortfilename );
 
@@ -439,7 +444,7 @@
     {
         S3D_MASTER*   draw3DCopy = m_shapes3D_list[ii];
 
-        if( draw3DCopy->m_Shape3DName.IsEmpty() )
+        if( draw3DCopy->GetShape3DName().IsEmpty() )
             continue;
 
         if( draw3D == NULL )
@@ -448,7 +453,7 @@
             m_currentModule->Models().Append( draw3D );
         }
 
-        draw3D->m_Shape3DName = draw3DCopy->m_Shape3DName;
+        draw3D->SetShape3DName( draw3DCopy->GetShape3DName() );
         draw3D->m_MatScale    = draw3DCopy->m_MatScale;
         draw3D->m_MatRotation = draw3DCopy->m_MatRotation;
         draw3D->m_MatPosition = draw3DCopy->m_MatPosition;

=== modified file 'pcbnew/exporters/export_idf.cpp'
--- pcbnew/exporters/export_idf.cpp	2014-01-07 20:41:32 +0000
+++ pcbnew/exporters/export_idf.cpp	2014-01-24 23:46:40 +0000
@@ -34,6 +34,7 @@
 #include <class_module.h>
 #include <class_edge_mod.h>
 #include <idf.h>
+#include <3d_struct.h>
 
 // assumed default graphical line thickness: 10000 IU == 0.1mm
 #define LINE_WIDTH (100000)
@@ -316,8 +317,50 @@
         }
     }
 
-    // TODO
-    // add to the library item list
+    // add any valid models to the library item list
+    std::string refdes;
+
+    for( S3D_MASTER* modfile = aModule->Models(); modfile != 0; modfile = modfile->Next() )
+    {
+        if( !modfile->Is3DType( S3D_MASTER::FILE3D_IDF ) )
+            continue;
+
+        double rotz = modfile->m_MatRotation.z + aModule->GetOrientation()/10.0;
+        double locx = modfile->m_MatPosition.x;
+        double locy = modfile->m_MatPosition.y;
+        double locz = modfile->m_MatPosition.z;
+
+        bool top = ( aModule->GetLayer() == LAYER_N_BACK ) ? false : true;
+
+        refdes = TO_UTF8( aModule->GetReference() );
+
+        if( top )
+        {
+            locy = -locy;
+            RotatePoint( &locx, &locy, aModule->GetOrientation() );
+            locy = -locy;
+        }
+        if( !top )
+        {
+            RotatePoint( &locx, &locy, aModule->GetOrientation() );
+            locy = -locy;
+
+            rotz = 180.0 - rotz;
+
+            if( rotz >= 360.0 )
+                while( rotz >= 360.0 ) rotz -= 360.0;
+
+            if( rotz <= -360.0 )
+                while( rotz <= -360.0 ) rotz += 360.0;
+        }
+
+        locx += aModule->GetPosition().x * scale + dx;
+        locy += -aModule->GetPosition().y * scale + dy;
+
+        aIDFBoard.PlaceComponent(modfile->GetShape3DName(), refdes, locx, locy, locz, rotz, top);
+    }
+
+    return;
 }
 
 
@@ -332,14 +375,12 @@
 
     SetLocaleTo_C_standard();
 
-    // NOTE:
-    // XXX We may enclose all this in a TRY .. CATCH block
     idfBoard.Setup( aPcb->GetFileName(), aFullFileName, aUseThou,
             aPcb->GetDesignSettings().GetBoardThickness() );
 
     // set up the global offsets
     EDA_RECT bbox = aPcb->ComputeBoundingBox( true );
-    idfBoard.SetOffset( bbox.Centre().x * idfBoard.GetScale(),
+    idfBoard.SetOffset( -bbox.Centre().x * idfBoard.GetScale(),
                          bbox.Centre().y * idfBoard.GetScale() );
 
     // Export the board outline

=== modified file 'pcbnew/exporters/export_vrml.cpp'
--- pcbnew/exporters/export_vrml.cpp	2014-01-07 20:41:32 +0000
+++ pcbnew/exporters/export_vrml.cpp	2014-01-24 03:06:09 +0000
@@ -1151,18 +1151,18 @@
     // Export the object VRML model(s)
     for( S3D_MASTER* vrmlm = aModule->Models(); vrmlm != 0; vrmlm = vrmlm->Next() )
     {
-        wxString fname = vrmlm->m_Shape3DName;
-
-        if( fname.IsEmpty() )
+        if( !vrmlm->Is3DType( S3D_MASTER::FILE3D_VRML ) )
             continue;
 
+        wxString fname = vrmlm->GetShape3DName();
+
         if( !wxFileName::FileExists( fname ) )
         {
             wxFileName fn = fname;
             fname = wxGetApp().FindLibraryPath( fn );
 
-            if( fname.IsEmpty() ) // keep "short" name if full filemane not found
-                fname = vrmlm->m_Shape3DName;
+            if( fname.IsEmpty() ) // keep "short" name if full filename not found
+                fname = vrmlm->GetShape3DName();
         }
 
         fname.Replace( wxT( "\\" ), wxT( "/" ) );

=== modified file 'pcbnew/exporters/idf.cpp'
--- pcbnew/exporters/idf.cpp	2014-01-07 20:41:32 +0000
+++ pcbnew/exporters/idf.cpp	2014-01-24 23:24:33 +0000
@@ -30,10 +30,17 @@
 
 #include <list>
 #include <string>
+#include <iostream>
+#include <fstream>
+#include <sstream>
 #include <algorithm>
 #include <cstdio>
 #include <cmath>
 #include <ctime>
+#include <cctype>
+#include <strings.h>
+#include <appl_wxstruct.h>
+#include <wx/file.h>
 #include <wx/filename.h>
 #include <macros.h>
 #include <idf.h>
@@ -49,6 +56,19 @@
 // used in a flexible design.
 #define IDF_MIN_BRD_THICKNESS (12000)
 
+
+// START: a few routines to help IDF_LIB but which may be of general use in the future
+// as IDF support develops
+
+// fetch a line from the given input file and trim the ends
+static bool FetchIDFLine( std::ifstream& aModel, std::string& aLine, bool& isComment );
+
+// extract an IDF string and move the index to point to the character after the substring
+static bool GetIDFString( const std::string& aLine, std::string& aIDFString,
+                          bool& hasQuotes, int& aIndex );
+
+// END: IDF_LIB helper routines
+
 bool IDF_POINT::Matches( const IDF_POINT& aPoint, double aRadius )
 {
     double dx = x - aPoint.x;
@@ -518,40 +538,32 @@
 bool IDF_BOARD::Finish( void )
 {
     // Steps to finalize the board and library files:
-    // 1. (emp) finalize the library file
-    // 2. (emn) close the BOARD_OUTLINE section
-    // 3. (emn) write out the DRILLED_HOLES section
+    // 1. (emn) close the BOARD_OUTLINE section
+    // 2. (emn) write out the DRILLED_HOLES section
+    // 3. (emp) finalize the library file
     // 4. (emn) write out the COMPONENT_PLACEMENT section
 
-    // TODO:
-    // idfLib.Finish();
-    if( libFile != NULL )
-    {
-        fclose( libFile );
-        libFile = NULL;
-    }
-
-    if( layoutFile == NULL )
+    if( layoutFile == NULL || libFile == NULL )
         return false;
 
     // Finalize the board outline section
     fprintf( layoutFile, ".END_BOARD_OUTLINE\n\n" );
 
     // Write out the drill section
-    if( WriteDrills() )
-    {
-        fclose( layoutFile );
-        layoutFile = NULL;
-        return false;
-    }
-
-    // TODO: Write out the component placement section
-    // IDF3::export_placement();
+    bool ok = WriteDrills();
+
+    // populate the library (*.emp) file and write the
+    // PLACEMENT section
+    if( ok )
+        ok = IDFLib.WriteFiles( layoutFile, libFile );
+
+    fclose( libFile );
+    libFile = NULL;
 
     fclose( layoutFile );
     layoutFile = NULL;
 
-    return true;
+    return ok;
 }
 
 
@@ -753,6 +765,16 @@
 }
 
 
+bool IDF_BOARD::PlaceComponent( const wxString aComponentFile, const std::string aRefDes,
+                     double aXLoc, double aYLoc, double aZLoc,
+                     double aRotation, bool isOnTop )
+{
+    return IDFLib.PlaceComponent( aComponentFile, aRefDes,
+                                  aXLoc, aYLoc, aZLoc,
+                                  aRotation, isOnTop );
+}
+
+
 bool IDF_BOARD::WriteDrills( void )
 {
     if( !layoutFile )
@@ -936,27 +958,818 @@
 }
 
 
-bool IDF_LIB::WriteLib( FILE* aLibFile )
+IDF_LIB::~IDF_LIB()
+{
+    while( !components.empty() )
+    {
+        delete components.back();
+        components.pop_back();
+    }
+}
+
+
+bool IDF_LIB::writeLib( FILE* aLibFile )
 {
     if( !aLibFile )
         return false;
 
     // TODO: check stream integrity and return false as appropriate
 
-    // TODO: export models
-
+    // export models
+    std::list< IDF_COMP* >::const_iterator mbeg = components.begin();
+    std::list< IDF_COMP* >::const_iterator mend = components.end();
+
+    while( mbeg != mend )
+    {
+        if( !(*mbeg)->WriteLib( aLibFile ) )
+            return false;
+        ++mbeg;
+    }
+
+    libWritten = true;
     return true;
 }
 
 
-bool IDF_LIB::WriteBrd( FILE* aLayoutFile )
+bool IDF_LIB::writeBrd( FILE* aLayoutFile )
 {
-    if( !aLayoutFile )
+    if( !aLayoutFile || !libWritten )
         return false;
 
+    if( components.empty() )
+        return true;
+
     // TODO: check stream integrity and return false as appropriate
 
-    // TODO: write out the board placement information
+    // write out the board placement information
+    std::list< IDF_COMP* >::const_iterator mbeg = components.begin();
+    std::list< IDF_COMP* >::const_iterator mend = components.end();
+
+    fprintf( aLayoutFile, "\n.PLACEMENT\n" );
+
+    while( mbeg != mend )
+    {
+        if( !(*mbeg)->WritePlacement( aLayoutFile ) )
+            return false;
+        ++mbeg;
+    }
+
+    fprintf( aLayoutFile, ".END_PLACEMENT\n" );
+
+    return true;
+}
+
+
+bool IDF_LIB::WriteFiles( FILE* aLayoutFile, FILE* aLibFile )
+{
+    if( !aLayoutFile || !aLibFile )
+        return false;
+
+    libWritten = false;
+    regOutlines.clear();
+
+    if( !writeLib( aLibFile ) )
+        return false;
+
+    return writeBrd( aLayoutFile );
+}
+
+
+bool IDF_LIB::RegisterOutline( const std::string aGeomPartString )
+{
+    std::set< std::string >::const_iterator it = regOutlines.find( aGeomPartString );
+
+    if( it != regOutlines.end() )
+        return true;
+
+    regOutlines.insert( aGeomPartString );
+
+    return false;
+}
+
+
+bool IDF_LIB::PlaceComponent( const wxString aComponentFile, const std::string aRefDes,
+                                double aXLoc, double aYLoc, double aZLoc,
+                                double aRotation, bool isOnTop )
+{
+    IDF_COMP* comp = new IDF_COMP( this );
+
+    if( comp == NULL )
+    {
+        std::cerr << "IDF_LIB: *ERROR* could not allocate memory for a component\n";
+        return false;
+    }
+
+    components.push_back( comp );
+
+    if( !comp->PlaceComponent( aComponentFile, aRefDes,
+                                     aXLoc, aYLoc, aZLoc,
+                                     aRotation, isOnTop ) )
+    {
+        std::cerr << "IDF_LIB: file does not exist (or is symlink):\n";
+        std::cerr << "   FILE: " << TO_UTF8( aComponentFile ) << "\n";
+        return false;
+    }
+
+    return true;
+}
+
+
+IDF_COMP::IDF_COMP( IDF_LIB* aParent )
+{
+    parent = aParent;
+}
+
+
+bool IDF_COMP::PlaceComponent( const wxString aComponentFile, const std::string aRefDes,
+                               double aXLoc, double aYLoc, double aZLoc,
+                               double aRotation, bool isOnTop )
+{
+    componentFile = aComponentFile;
+    refdes = aRefDes;
+
+    if( refdes.empty() || !refdes.compare("~") || !refdes.compare("0") )
+        refdes = "NOREFDES";
+
+    loc_x = aXLoc;
+    loc_y = aYLoc;
+    loc_z = aZLoc;
+    rotation = aRotation;
+    top = isOnTop;
+
+    if( !wxFileName::FileExists( aComponentFile ) )
+    {
+        wxFileName fn = aComponentFile;
+        wxString fname = wxGetApp().FindLibraryPath( fn );
+
+        if( fname.IsEmpty() )
+            return false;
+        else
+            componentFile = fname;
+    }
+
+    return true;
+}
+
+
+bool IDF_COMP::WritePlacement( FILE* aLayoutFile )
+{
+    if( aLayoutFile == NULL )
+    {
+        std::cerr << "IDF_COMP: *ERROR* WritePlacement() invoked with aLayoutFile = NULL\n";
+        return false;
+    }
+
+    if( parent == NULL )
+    {
+        std::cerr << "IDF_COMP: *ERROR* no valid pointer \n";
+        return false;
+    }
+
+    if( componentFile.empty() )
+    {
+        std::cerr << "IDF_COMP: *BUG* empty componentFile name in WritePlacement()\n";
+        return false;
+    }
+
+    if( geometry.empty() && partno.empty() )
+    {
+        std::cerr << "IDF_COMP: *BUG* geometry and partno strings are empty in WritePlacement()\n";
+        return false;
+    }
+
+    // TODO: monitor stream integrity and respond accordingly
+
+    // PLACEMENT, RECORD 2:
+    fprintf( aLayoutFile, "\"%s\" \"%s\" \"%s\"\n",
+             geometry.c_str(), partno.c_str(), refdes.c_str() );
+
+    // PLACEMENT, RECORD 3:
+    if( rotation >= -MIN_ANG && rotation <= -MIN_ANG )
+    {
+        fprintf( aLayoutFile, "%.6f %.6f %.6f 0 %s ECAD\n",
+                 loc_x, loc_y, loc_z, top ? "TOP" : "BOTTOM" );
+    }
+    else
+    {
+        fprintf( aLayoutFile, "%.6f %.6f %.6f %.3f %s ECAD\n",
+                 loc_x, loc_y, loc_z, rotation, top ? "TOP" : "BOTTOM" );
+    }
+
+    return true;
+}
+
+
+bool IDF_COMP::WriteLib( FILE* aLibFile )
+{
+    // 1. parse the file for the .ELECTRICAL or .MECHANICAL section
+    //      and extract the Geometry and PartNumber strings
+    // 2. Register the name; check if it already exists
+    // 3. parse the rest of the file until .END_ELECTRICAL or
+    //      .END_MECHANICAL; validate that each entry conforms
+    //      to a valid outline
+    // 4. write lines to library file
+    //
+    // NOTE on parsing (the order matters):
+    //  + store each line which begins with '#'
+    //  + strip blanks from both ends of the line
+    //  + drop each blank line
+    //  + the first non-blank non-comment line must be
+    //      .ELECTRICAL or .MECHANICAL (as per spec, case does not matter)
+    //  + the first non-blank line after RECORD 1 must be RECORD 2
+    //  + following RECORD 2, only blank lines, valid outline entries,
+    //      and .END_{MECHANICAL,ELECTRICAL} are allowed
+    //  + only a single outline may be specified; the order may be
+    //      CW or CCW.
+    //  + all valid lines are stored and written to the library file
+    //
+    // return: false if we do could not write model data; we may return
+    //  true even if we could not read an IDF file for some reason, provided
+    //  that the default model was written. In such a case, warnings will be
+    //  written to stderr.
+
+    if( aLibFile == NULL )
+    {
+        std::cerr << "IDF_COMP: *ERROR* WriteLib() invoked with aLibFile = NULL\n";
+        return false;
+    }
+
+    if( parent == NULL )
+    {
+        std::cerr << "IDF_COMP: *ERROR* no valid pointer \n";
+        return false;
+    }
+
+    if( componentFile.empty() )
+    {
+        std::cerr << "IDF_COMP: *BUG* empty componentFile name in WriteLib()\n";
+        return false;
+    }
+
+    std::list< std::string > records;
+    std::ifstream model;
+    std::string fname = TO_UTF8( componentFile );
+
+    model.open( fname.c_str(), std::ios_base::in );
+
+    if( !model.is_open() )
+    {
+        std::cerr << "* IDF EXPORT: could not open file " << fname << "\n";
+        return substituteComponent( aLibFile );
+    }
+
+    std::string entryType;  // will be one of ELECTRICAL or MECHANICAL
+    std::string endMark;    // will be one of .END_ELECTRICAL or .END_MECHANICAL
+    std::string iline;      // the input line
+    int state = 1;
+    bool isComment;         // true if a line just read in is a comment line
+    bool isNewItem = false; // true if the outline is a previously unsaved IDF item
+
+    // some vars for parsing record 3
+    int    loopIdx = -1;        // direction of points in outline (0=CW, 1=CCW, -1=no points yet)
+    double firstX;
+    double firstY;
+    bool   lineClosed = false;  // true when outline has been closed; only one outline is permitted
+
+    while( state )
+    {
+        while( !FetchIDFLine( model, iline, isComment ) && model.good() );
+
+        if( !model.good() )
+        {
+            // this should not happen; we should at least
+            // have encountered the .END_ statement;
+            // however, we shall make a concession if the
+            // last line is an .END_ statement which had
+            // not been correctly terminated
+            if( !endMark.empty() && !strncasecmp( iline.c_str(), endMark.c_str(), 15 ) )
+            {
+                std::cerr << "IDF EXPORT: *WARNING* IDF file is not properly terminated\n";
+                std::cerr << "*     FILE: " << fname << "\n";
+                records.push_back( endMark );
+                break;
+            }
+
+            std::cerr << "IDF EXPORT: *ERROR* faulty IDF file\n";
+            std::cerr << "*     FILE: " << fname << "\n";
+            return substituteComponent( aLibFile );
+        }
+
+        switch( state )
+        {
+            case 1:
+                // accept comment lines, .ELECTRICAL, or .MECHANICAL;
+                // all others are simply ignored
+                if( isComment )
+                {
+                    records.push_back( iline );
+                    break;
+                }
+
+                if( !strncasecmp( iline.c_str(), ".electrical", 11 ) )
+                {
+                    entryType = ".ELECTRICAL";
+                    endMark   = ".END_ELECTRICAL";
+                    records.push_back( entryType );
+                    state = 2;
+                    break;
+                }
+
+                if( !strncasecmp( iline.c_str(), ".mechanical", 11 ) )
+                {
+                    entryType = ".MECHANICAL";
+                    endMark   = ".END_MECHANICAL";
+                    records.push_back( entryType );
+                    state = 2;
+                    break;
+                }
+
+                break;
+
+            case 2:
+                // accept only a RECORD 2 compliant line;
+                // anything else constitutes a malformed IDF file
+                if( isComment )
+                {
+                    std::cerr << "IDF EXPORT: bad IDF file\n";
+                    std::cerr << "*     LINE: " << iline << "\n";
+                    std::cerr << "*     FILE: " << fname << "\n";
+                    std::cerr << "*   REASON: comment within "
+                              << entryType << " section\n";
+                    model.close();
+                    return substituteComponent( aLibFile );
+                }
+
+                if( !parseRec2( iline, isNewItem ) )
+                {
+                    std::cerr << "IDF EXPORT: bad IDF file\n";
+                    std::cerr << "*     LINE: " << iline << "\n";
+                    std::cerr << "*     FILE: " << fname << "\n";
+                    std::cerr << "*   REASON: expecting RECORD 2 of "
+                              << entryType << " section\n";
+                    model.close();
+                    return substituteComponent( aLibFile );
+                }
+
+                if( isNewItem )
+                {
+                    records.push_back( iline );
+                    state = 3;
+                }
+                else
+                {
+                    model.close();
+                    return true;
+                }
+
+                break;
+
+            case 3:
+                // accept outline entries or end of section
+                if( isComment )
+                {
+                    std::cerr << "IDF EXPORT: bad IDF file\n";
+                    std::cerr << "*     LINE: " << iline << "\n";
+                    std::cerr << "*     FILE: " << fname << "\n";
+                    std::cerr << "*   REASON: comment within "
+                              << entryType << " section\n";
+                    model.close();
+                    return substituteComponent( aLibFile );
+                }
+
+                if( !strncasecmp( iline.c_str(), endMark.c_str(), 15 ) )
+                {
+                    records.push_back( endMark );
+                    state = 0;
+                    break;
+                }
+
+                if( lineClosed )
+                {
+                    // there should be no further points
+                    std::cerr << "IDF EXPORT: faulty IDF file\n";
+                    std::cerr << "*     LINE: " << iline << "\n";
+                    std::cerr << "*     FILE: " << fname << "\n";
+                    std::cerr << "*   REASON: more than 1 outline in "
+                              << entryType << " section\n";
+                    model.close();
+                    return substituteComponent( aLibFile );
+                }
+
+                if( !parseRec3( iline, loopIdx, firstX, firstY, lineClosed ) )
+                {
+                    std::cerr << "IDF EXPORT: unexpected line in IDF file\n";
+                    std::cerr << "*     LINE: " << iline << "\n";
+                    std::cerr << "*     FILE: " << fname << "\n";
+                    model.close();
+                    return substituteComponent( aLibFile );
+                }
+
+                records.push_back( iline );
+                break;
+
+            default:
+                std::cerr << "IDF EXPORT: BUG in " << __FUNCTION__ << ": unexpected state\n";
+                model.close();
+                return substituteComponent( aLibFile );
+                break;
+        }   // switch( state )
+    }       // while( state )
+
+    model.close();
+
+    if( !lineClosed )
+    {
+        std::cerr << "IDF EXPORT: component outline not closed\n";
+        std::cerr << "*     FILE: " << fname << "\n";
+        return substituteComponent( aLibFile );
+    }
+
+    std::list< std::string >::iterator lbeg = records.begin();
+    std::list< std::string >::iterator lend = records.end();
+
+    // TODO: check stream integrity
+    while( lbeg != lend )
+    {
+        fprintf( aLibFile, "%s\n", lbeg->c_str() );
+        ++lbeg;
+    }
+    fprintf( aLibFile, "\n" );
+
+    return true;
+}
+
+
+bool IDF_COMP::substituteComponent( FILE* aLibFile )
+{
+    // the component outline does not exist or could not be
+    // read; substitute a placeholder
+
+    // TODO: check the stream integrity
+    geometry = "NOGEOM";
+    partno   = "NOPART";
+
+    if( parent->RegisterOutline( "NOGEOM_NOPART" ) )
+        return true;
+
+    fprintf( aLibFile, ".ELECTRICAL\n" );
+    fprintf( aLibFile, "\"NOGEOM\" \"NOPART\" MM 5\n" );
+    // TODO: for now we shall use a simple cylinder; a more intricate
+    // and readily recognized feature (a stylistic X) would be of
+    // much greater value.
+    fprintf( aLibFile, "0 0 0 0\n" );
+    fprintf( aLibFile, "0 2.5 0 360\n" );
+    fprintf( aLibFile, ".END_ELECTRICAL\n\n" );
+
+    return true;
+}
+
+
+bool IDF_COMP::parseRec2( const std::string aLine, bool& isNewItem )
+{
+    // RECORD 2:
+    // + "Geometry Name"
+    // + "Part Number"
+    // + MM or THOU
+    // + height (float)
+
+    isNewItem = false;
+
+    int idx = 0;
+    bool quoted = false;
+    std::string entry;
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2 in model file (no Geometry Name entry)\n";
+        return false;
+    }
+
+    geometry = entry;
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2 in model file (no Part No. entry)\n";
+        return false;
+    }
+
+    partno = entry;
+
+    if( geometry.empty() && partno.empty() )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2 in model file\n";
+        std::cerr << "          Geometry Name and Part Number are both empty.\n";
+        return false;
+    }
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2, missing FIELD 3\n";
+        return false;
+    }
+
+    if( strcasecmp( "MM", entry.c_str() ) && strcasecmp( "THOU", entry.c_str() ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2, invalid FIELD 3 \""
+                  << entry << "\"\n";
+        return false;
+    }
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2, missing FIELD 4\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2, invalid FIELD 4 (quoted)\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    // ensure that we have a valid value
+    double val;
+    std::stringstream teststr;
+    teststr << entry;
+
+    if( !( teststr >> val ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 2, invalid FIELD 4 (must be numeric)\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    teststr.str( "" );
+    teststr << geometry << "_" << partno;
+    isNewItem = parent->RegisterOutline( teststr.str() );
+
+    return true;
+}
+
+
+bool IDF_COMP::parseRec3( const std::string aLine, int& aLoopIndex,
+                          double& aX, double& aY, bool& aClosed )
+{
+    // RECORD 3:
+    // + 0,1 (loop label)
+    // + X coord (float)
+    // + Y coord (float)
+    // + included angle (0 for line, +ang for CCW, -ang for CW, +360 for circle)
+    //
+    // notes:
+    // 1. first entry may not be a circle or arc
+    // 2. it would be nice, but not essential, to ensure that the
+    //      winding is indeed as specified by the loop label
+    //
+
+    double x, y, ang;
+    bool ccw    = false;
+    bool quoted = false;
+    int idx = 0;
+    std::string entry;
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, no data\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 1 is quoted\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( entry.compare( "0" ) && entry.compare( "1" ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 1 is invalid (must be 0 or 1)\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( !entry.compare( "0" ) )
+        ccw = true;
+
+    if( aLoopIndex == 0 && !ccw )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, LOOP INDEX changed from 0 to 1\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( aLoopIndex == 1 && ccw )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, LOOP INDEX changed from 1 to 0\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 2 does not exist\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 2 is quoted\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    std::stringstream tstr;
+    tstr.str( entry );
+
+    if( !(tstr >> x ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, invalid X value in FIELD 2\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 3 does not exist\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 3 is quoted\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    tstr.clear();
+    tstr.str( entry );
+
+    if( !(tstr >> y ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, invalid Y value in FIELD 3\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( aLine, entry, quoted, idx ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 4 does not exist\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, FIELD 4 is quoted\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    tstr.clear();
+    tstr.str( entry );
+
+    if( !(tstr >> ang ) )
+    {
+        std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, invalid ANGLE value in FIELD 3\n";
+        std::cerr << "    LINE: " << aLine << "\n";
+        return false;
+    }
+
+    if( aLoopIndex == -1 )
+    {
+        // this is the first point; there are some special checks
+        aLoopIndex = ccw ? 0 : 1;
+        aX = x;
+        aY = y;
+        aClosed = false;
+
+        // ensure that the first point is not an arc specification
+        if( ang < -MIN_ANG || ang > MIN_ANG )
+        {
+            std::cerr << "IDF_COMP: *ERROR* invalid RECORD 3, first point has non-zero angle\n";
+            std::cerr << "    LINE: " << aLine << "\n";
+            return false;
+        }
+    }
+    else
+    {
+        // does this close the outline?
+        if( ang < 0.0 ) ang = -ang;
+
+        ang -= 360.0;
+
+        if( ang > -MIN_ANG && ang < MIN_ANG )
+        {
+            // this is  a circle; the loop is closed
+            aClosed = true;
+        }
+        else
+        {
+            x = (aX - x) * (aX - x);
+            y = (aY - y) * (aY - y) + x;
+
+            if( y <= 1e-6 )
+            {
+                // the points are close enough; the loop is closed
+                aClosed = true;
+            }
+        }
+    }
+
+    // NOTE:
+    // 1. ideally we would ensure that there are no arcs with a radius of 0; this entails
+    //    actively calculating the last point as the previous entry could have been an instruction
+    //    to create an arc. This check is sacrificed in the interest of speed.
+    // 2. a bad outline can be crafted by giving at least one valid segment and then introducing
+    //    a circle; such a condition is not checked for here in the interest of speed.
+    // 3. a circle specified with an angle of -360 is invalid, but that condition is not
+    //    tested here.
+
+    return true;
+}
+
+
+// fetch a line from the given input file and trim the ends
+static bool FetchIDFLine( std::ifstream& aModel, std::string& aLine, bool& isComment )
+{
+    aLine = "";
+    std::getline( aModel, aLine );
+
+    isComment = false;
+
+    // A comment begins with a '#' and must be the first character on the line
+    if( aLine[0] == '#' )
+        isComment = true;
+
+
+    while( !aLine.empty() && isspace( *aLine.begin() ) )
+        aLine.erase( aLine.begin() );
+
+    while( !aLine.empty() && isspace( *aLine.rbegin() ) )
+        aLine.erase( --aLine.end() );
+
+    if( aLine.empty() )
+        return false;
+
+    return true;
+}
+
+
+// extract an IDF string and move the index to point to the character after the substring
+static bool GetIDFString( const std::string& aLine, std::string& aIDFString,
+                          bool& hasQuotes, int& aIndex )
+{
+    // 1. drop all leading spaces
+    // 2. if the first character is '"', read until the next '"',
+    //    otherwise read until the next space or EOL.
+
+    std::ostringstream ostr;
+
+    int len = aLine.length();
+    int idx = aIndex;
+
+    if( idx < 0 || idx >= len )
+        return false;
+
+    while( isspace( aLine[idx] ) && idx < len ) ++idx;
+
+    if( idx == len )
+    {
+        aIndex = idx;
+        return false;
+    }
+
+    if( aLine[idx] == '"' )
+    {
+        hasQuotes = true;
+        ++idx;
+        while( aLine[idx] != '"' && idx < len )
+            ostr << aLine[idx++];
+
+        if( idx == len )
+        {
+            std::cerr << "GetIDFString(): *ERROR*: unterminated quote mark in line:\n";
+            std::cerr << "LINE: " << aLine << "\n";
+            aIndex = idx;
+            return false;
+        }
+
+        ++idx;
+    }
+    else
+    {
+        hasQuotes = false;
+
+        while( !isspace( aLine[idx] ) && idx < len )
+            ostr << aLine[idx++];
+
+    }
+
+    aIDFString = ostr.str();
+    aIndex = idx;
 
     return true;
 }

=== modified file 'pcbnew/exporters/idf.h'
--- pcbnew/exporters/idf.h	2014-01-07 20:41:32 +0000
+++ pcbnew/exporters/idf.h	2014-01-24 23:42:26 +0000
@@ -29,6 +29,8 @@
 #define IDF_H
 
 #include <wx/string.h>
+#include <set>
+#include <string>
 
 #ifndef M_PI
 #define M_PI 3.1415926535897932384626433832795028841
@@ -46,6 +48,7 @@
 class IDF_SEGMENT;
 class IDF_DRILL_DATA;
 class IDF_OUTLINE;
+class IDF_LIB;
 
 namespace IDF3 {
 enum KEY_OWNER
@@ -89,6 +92,20 @@
 
 
 /**
+ * @Struct IDF_POINT
+ * represents a vector of three doubles; this may be represent
+ * a point in space, or scaling, translation or rotation along
+ * three axes.
+ */
+struct IDF_VECTOR
+{
+    double x;
+    double y;
+    double z;
+};
+
+
+/**
  * @Class IDF_POINT
  * represents a point
  */
@@ -288,12 +305,154 @@
 
 
 /**
+ * @Class IDF_COMP
+ * is responsible for parsing individual component files and rewriting relevant
+ * data to a library file.
+ */
+class IDF_COMP
+{
+private:
+    /// filename (full path) of the IDF component footprint
+    wxString componentFile;
+
+    /// reference designator; a valid designator or NOREFDES
+    std::string refdes;
+
+    /// overall translation of the part (component location + 3D offset)
+    double loc_x;
+    double loc_y;
+    double loc_z;
+
+    /// overall rotation of the part (3D Z rotation + component rotation)
+    double rotation;
+
+    /// true if the component is on the top of the board
+    bool top;
+
+    /// geometry of the package; for example, HORIZ, VERT, "HORIZ 0.2 inch"
+    std::string geometry;
+
+    /// package name or part number; for example "TO92" or "BC107"
+    std::string partno;
+
+    /// the owning IDF_LIB instance
+    IDF_LIB* parent;
+
+    /**
+     * Function substituteComponent
+     * places a substitute component footprint into the library file
+     * and creates an appropriate entry for the PLACEMENT section
+     * @param aLibFile is the library file to write to
+     * @return bool: true if data was successfully written
+     */
+    bool substituteComponent( FILE* aLibFile );
+
+    // parse RECORD 2; return TRUE if all is OK, otherwise FALSE
+    bool parseRec2( const std::string aLine, bool& isNewItem );
+
+    // parse RECORD 3; return TRUE if all is OK, otherwise FALSE
+    bool parseRec3( const std::string aLine, int& aLoopIndex,
+                    double& aX, double& aY, bool& aClosed );
+
+public:
+    IDF_COMP( IDF_LIB* aParent );
+
+    /**
+     * Function PlaceComponent
+     * specifies the parameters of an IDF component outline placed on the board
+     * @param aComponentFile is the IDF component file to include
+     * @param aRefDes is the component reference designator; an empty string,
+     *                '~' or '0' all default to "NOREFDES".
+     * @param aLocation is the overall translation of the part (board location + 3D offset)
+     * @param aRotation is the overall rotation of the part (component rotation + 3D Z rotation)
+     * @return bool: true if the specified component file exists
+     */
+    bool PlaceComponent( const wxString aComponentFile, const std::string aRefDes,
+                         double aXLoc, double aYLoc, double aZLoc,
+                         double aRotation, bool isOnTop );
+
+    /**
+     * Function WriteLib
+     * parses the model file to extract information needed by the
+     * PLACEMENT section and writes data (if necessary) to the
+     * library file
+     * @param aLibFile is the library file to write to
+     * @return bool: true if data was successfully written
+     */
+    bool WriteLib( FILE* aLibFile );
+
+    /**
+     * Function WritePlacement
+     * write the .PLACEMENT data of the component to the IDF board @param aLayoutFile
+     * @return bool: true if data was successfully written
+     */
+    bool WritePlacement( FILE* aLayoutFile );
+};
+
+
+/**
+ * @Class IDF_LIB
+ * stores information on IDF models ( also has an inbuilt NOMODEL model )
+ * and is responsible for writing the ELECTRICAL sections of the library file
+ * (*.emp) and the PLACEMENT section of the board file.
+ */
+class IDF_LIB
+{
+    /// a list of component outline names and a flag to indicate their save state
+    std::set< std::string > regOutlines;
+    std::list< IDF_COMP* > components;
+    bool libWritten;
+
+    /**
+     * Function writeLib
+     * writes all current library information to the output file
+     */
+    bool writeLib( FILE* aLibFile );
+
+    /**
+     * Function writeBrd
+     * write placement information to the board file
+     */
+    bool writeBrd( FILE* aLayoutFile );
+
+public:
+    virtual ~IDF_LIB();
+
+    /**
+     * Function WriteFiles
+     * writes the library entries to the *.emp file (aLibFile) and the
+     * .PLACEMENT section to the *.emn file (aLayoutFile)
+     * @param aLayoutFile IDF board file
+     * @param aLibFile IDF library file
+     * @return bool: true if all data was written successfully
+     */
+    bool WriteFiles( FILE* aLayoutFile, FILE* aLibFile );
+
+    /**
+     * Function RegisterOutline
+     * adds the given string to a list of current outline entities.
+     * @param aGeomPartString is a concatenation of the IDF component's
+     * geometry name and part name; this is used as a unique identifier
+     * to prevent redundant entries in the library output.
+     * @return bool: true if the string was already registered,
+     * false if it is a new registration.
+     */
+    bool RegisterOutline( const std::string aGeomPartString );
+
+    bool PlaceComponent( const wxString  aComponentFile, const std::string aRefDes,
+                         double aXLoc, double aYLoc, double aZLoc,
+                         double aRotation, bool isOnTop );
+};
+
+
+/**
  * @Class IDF_BOARD
  * contains objects necessary for the maintenance of the IDF board and library files.
  */
 class IDF_BOARD
 {
 private:
+    IDF_LIB IDFLib;                         ///< IDF library manager
     std::list<IDF_DRILL_DATA*> drills;      ///< IDF drill data
     int outlineIndex;                       ///< next outline index to use
     bool useThou;                           ///< true if output is THOU
@@ -375,6 +534,10 @@
      * represent the Reference Designator association with a slot.
      */
     bool AddSlot( double aWidth, double aLength, double aOrientation, double aX, double aY );
+
+    bool PlaceComponent( const wxString aComponentFile, const std::string aRefDes,
+                         double aXLoc, double aYLoc, double aZLoc,
+                         double aRotation, bool isOnTop );
 };
 
 
@@ -422,33 +585,4 @@
     bool Write( FILE* aLayoutFile );
 };
 
-
-/**
- * @Class IDF_LIB
- * stores information on IDF models ( also has an inbuilt NOMODEL model )
- * and is responsible for writing the ELECTRICAL sections of the library file
- * (*.emp) and the PLACEMENT section of the board file.
- */
-class IDF_LIB
-{
-    // TODO: IMPLEMENT
-
-public:
-    /**
-     * Function WriteLib
-     * writes all current library information to the output file
-     */
-    bool WriteLib( FILE* aLibFile );
-
-    // write placement information to the board file
-    bool WriteBrd( FILE* aLayoutFile );
-
-    // bool Finish( void )
-    // {
-    // TODO: Write out the library (*.emp) file
-    // idf_lib.Write( lib_file );
-    // TODO: fclose( lib_file );
-    // }
-};
-
 #endif  // IDF_H

=== modified file 'pcbnew/kicad_plugin.cpp'
--- pcbnew/kicad_plugin.cpp	2014-01-02 02:17:07 +0000
+++ pcbnew/kicad_plugin.cpp	2014-01-24 03:09:15 +0000
@@ -1050,10 +1050,10 @@
     // Save 3D info.
     for( S3D_MASTER* t3D = aModule->Models();  t3D;  t3D = t3D->Next() )
     {
-        if( !t3D->m_Shape3DName.IsEmpty() )
+        if( !t3D->GetShape3DName().IsEmpty() )
         {
             m_out->Print( aNestLevel+1, "(model %s\n",
-                          m_out->Quotew( t3D->m_Shape3DName ).c_str() );
+                          m_out->Quotew( t3D->GetShape3DName() ).c_str() );
 
             m_out->Print( aNestLevel+2, "(at (xyz %s %s %s))\n",
                           Double2Str( t3D->m_MatPosition.x ).c_str(),

=== modified file 'pcbnew/legacy_plugin.cpp'
--- pcbnew/legacy_plugin.cpp	2014-01-19 13:12:57 +0000
+++ pcbnew/legacy_plugin.cpp	2014-01-24 03:27:50 +0000
@@ -1643,7 +1643,7 @@
 {
     S3D_MASTER* t3D = aModule->Models();
 
-    if( !t3D->m_Shape3DName.IsEmpty() )
+    if( !t3D->GetShape3DName().IsEmpty() )
     {
         S3D_MASTER* n3D = new S3D_MASTER( aModule );
 
@@ -1659,7 +1659,7 @@
         {
             char    buf[512];
             ReadDelimitedText( buf, line + SZ( "Na" ), sizeof(buf) );
-            t3D->m_Shape3DName = FROM_UTF8( buf );
+            t3D->SetShape3DName( FROM_UTF8( buf ) );
         }
 
         else if( TESTLINE( "Sc" ) )     // Scale
@@ -3513,11 +3513,11 @@
 {
     for( S3D_MASTER* t3D = me->Models();  t3D;  t3D = t3D->Next() )
     {
-        if( !t3D->m_Shape3DName.IsEmpty() )
+        if( !t3D->GetShape3DName().IsEmpty() )
         {
             fprintf( m_fp, "$SHAPE3D\n" );
 
-            fprintf( m_fp, "Na %s\n", EscapedUTF8( t3D->m_Shape3DName ).c_str() );
+            fprintf( m_fp, "Na %s\n", EscapedUTF8( t3D->GetShape3DName() ).c_str() );
 
             fprintf(m_fp,
 #if defined(DEBUG)

=== modified file 'pcbnew/menubar_pcbframe.cpp'
--- pcbnew/menubar_pcbframe.cpp	2014-01-08 14:18:51 +0000
+++ pcbnew/menubar_pcbframe.cpp	2014-01-25 01:06:23 +0000
@@ -205,7 +205,7 @@
 
     // IDF3
     AddMenuItem( submenuexport, ID_GEN_EXPORT_FILE_IDF3,
-                 _( "I&DFv3 Board Shape Export" ), _( "Basic export of board shape only IDFv3 format" ),
+                 _( "I&DFv3 Export" ), _( "IDFv3 board and component export" ),
                  KiBitmap( export_xpm ) );
 
     AddMenuItem( filesMenu, submenuexport,

=== modified file 'pcbnew/pcb_parser.cpp'
--- pcbnew/pcb_parser.cpp	2013-12-20 09:15:00 +0000
+++ pcbnew/pcb_parser.cpp	2014-01-24 03:28:57 +0000
@@ -263,7 +263,7 @@
     std::auto_ptr< S3D_MASTER > n3D( new S3D_MASTER( NULL ) );
 
     NeedSYMBOLorNUMBER();
-    n3D->m_Shape3DName = FromUTF8();
+    n3D->SetShape3DName( FromUTF8() );
 
     for( token = NextTok();  token != T_RIGHT;  token = NextTok() )
     {

