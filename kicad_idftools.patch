=== added file 'utils/idftools/build.sh'
--- utils/idftools/build.sh	1970-01-01 00:00:00 +0000
+++ utils/idftools/build.sh	2014-05-15 08:52:56 +0000
@@ -0,0 +1,112 @@
+#! /bin/bash
+#g++ -Wall -I . `wx-config --cxxflags` -c idf_parser.cpp
+
+#g++ -Wall -I . -I ../../include -I ../../build `wx-config --cxxflags` idf_parser.cpp idf_common.cpp idf2vrml.cpp \
+#  ../../common/richio.cpp `wx-config --libs` -o idf2vrml
+
+# set these flags to (re)build each unit
+IDF_HELPERS=false
+IDF_OUTLINES=false
+IDF_PARSER=true
+IDF_COMMON=false
+VRML_BOARD=false
+RICHIO=false
+MAIN=false
+APP=true
+
+
+if ( ${IDF_HELPERS} )
+    then
+    if ! ( g++ -Wall -I . -c idf_helpers.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: idf_helpers.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34midf_helpers.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${IDF_OUTLINES} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c idf_outlines.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: idf_outlines.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34midf_outlines.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${IDF_PARSER} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c idf_parser.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: idf_parser.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34midf_parser.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${IDF_COMMON} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c idf_common.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: idf_common.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34midf_common.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${VRML_BOARD} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c vrml_board.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: vrml_board.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34mvrml_board.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${RICHIO} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c ../../common/richio.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: richio.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34mrichio.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${MAIN} )
+    then
+    if ! ( g++ -Wall -I . -I ../../include `wx-config --cxxflags` -c test_idf2vrml.cpp )
+        then
+        echo -e "\E[31mFAILED TO COMPILE: test_idf2vrml.cpp\E[0m"
+        exit 1
+    else
+        echo -e "\E[34mtest_idf2vrml.cpp: OK\E[0m"
+    fi
+fi
+
+
+if ( ${APP} )
+    then
+    if ! ( g++ -lGLU idf_parser.o idf_common.o idf_helpers.o idf_outlines.o vrml_board.o \
+           richio.o test_idf2vrml.o `wx-config --libs` -o testidf2vrml )
+        then
+        echo -e "\E[31mFAILED TO LINK: testidf2vrml\E[0m"
+        exit 1
+    else
+        echo -e "\E[34mtestidf2vrml: Build Completed\E[0m"
+    fi
+fi

=== added file 'utils/idftools/config.h'
--- utils/idftools/config.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/config.h	2014-04-29 02:24:25 +0000
@@ -0,0 +1,81 @@
+// Do not modify this file, it was automatically generated by CMake.
+
+#ifndef CONFIG_H_
+#define CONFIG_H_
+
+#define HAVE_STRCASECMP
+
+#define HAVE_STRNCASECMP
+
+#define HAVE_STRTOKR       // spelled odly to differ from wx's similar test
+
+// Handle platform differences in math.h
+#define HAVE_MATH_H
+
+// Handle platform differences in C++ cmath.
+#define HAVE_CXX_CMATH
+
+#define HAVE_CMATH_ASINH
+
+#define HAVE_CMATH_ACOSH
+
+#define HAVE_CMATH_ATANH
+
+#define HAVE_CMATH_ISINF
+
+#define HAVE_CLOCK_GETTIME
+
+#define HAVE_GETTIMEOFDAY_FUNC
+
+#define MALLOC_IN_STDLIB_H
+
+#if !defined( MALLOC_IN_STDLIB_H )
+#include <malloc.h>
+#endif
+
+#define HAVE_ISO646_H
+
+#if defined( HAVE_ISO646_H )
+#include <iso646.h>
+#endif
+
+#if defined( HAVE_STRCASECMP )
+#define stricmp strcasecmp
+#endif
+
+#if defined( HAVE_STRNCASECMP )
+#define strnicmp strncasecmp
+#endif
+
+// Use Posix getc_unlocked() instead of getc() when it's available.
+#define HAVE_FGETC_NOLOCK
+
+// Warning!!!  Using wxGraphicContext for rendering is experimental.
+/* #undef USE_WX_GRAPHICS_CONTEXT */
+
+#define USE_IMAGES_IN_MENUS        1
+
+/// The legacy file format revision of the *.brd file created by this build
+#define LEGACY_BOARD_FILE_VERSION       2
+
+/// The install prefix defined in CMAKE_INSTALL_PREFIX.
+#define DEFAULT_INSTALL_PATH            "/usr/local"
+
+/// Default footprint library install path when installed with `make install`.
+#define DEFAULT_FP_LIB_PATH             "/usr/local/share/kicad/modules"
+
+/// When defined, build the GITHUB_PLUGIN for pcbnew.
+#define BUILD_GITHUB_PLUGIN
+
+/// When defined, use KIWAY and KIFACE DSOs
+#define USE_KIWAY_DLLS
+
+/// A file extension with a leading '.' is a suffix, and this one is used on
+/// top level program modules which implement the KIFACE.
+#define KIFACE_SUFFIX                   wxT( ".kiface" )
+#define KIFACE_PREFIX                   wxT( "_" )
+
+/// Name of repo from which this build came.
+#define KICAD_REPO_NAME                 "product"
+
+#endif  // CONFIG_H_

=== modified file 'utils/idftools/dxf2idfmain.cpp'
--- utils/idftools/dxf2idfmain.cpp	2014-02-05 09:27:21 +0000
+++ utils/idftools/dxf2idfmain.cpp	2014-05-09 04:23:18 +0000
@@ -123,7 +123,8 @@
         tstr.clear();
         tstr.str( line );
 
-        if( (tstr >> height ) && height > 0.001 )
+        tstr >> height
+        if( !tstr.fail() && height > 0.001 )
             ok = true;
     }
 

=== added file 'utils/idftools/idf2vrml.cpp'
--- utils/idftools/idf2vrml.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf2vrml.cpp	2014-04-08 07:49:38 +0000
@@ -0,0 +1,57 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+/*
+ *  This program takes an IDF base name, loads the board outline
+ *  and component outine files, and creates a single VRML file.
+ *  The VRML file can be used to visually verify the IDF files
+ *  before sending them to a mechanical designer. The output scale
+ *  is 10:1; this scale was chosen because VRML was originally
+ *  intended to describe large virtual worlds and rounding errors
+ *  would be more likely if we used a 1:1 scale.
+ */
+
+#include <fctsys.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <cmath>
+#include <cstdio>
+#include <list>
+#include <utility>
+#include <clocale>
+#include <vector>
+#include <idf_common.h>
+#include <vrml_board.h>
+
+int main( int argc, char **argv )
+{
+    // IDF implicitly requires the C locale
+    setlocale( LC_ALL, "C" );
+
+
+    // restore the locale
+    setlocale( LC_ALL, "" );
+    return 0;
+}

=== added file 'utils/idftools/idf_common.cpp'
--- utils/idftools/idf_common.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_common.cpp	2014-05-15 07:36:25 +0000
@@ -0,0 +1,1325 @@
+/**
+ * file: idf_common.cpp
+ *
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2013-2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <list>
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <sstream>
+#include <iomanip>
+#include <cerrno>
+#include <cstdio>
+#include <cmath>
+#include <richio.h>
+#include <idf_common.h>
+#include <build_version.h>
+#include <idf_helpers.h>
+
+using namespace IDF3;
+using namespace std;
+
+IDF_NOTE::IDF_NOTE()
+{
+    xpos = 0.0;
+    ypos = 0.0;
+    height = 0.0;
+    length = 0.0;
+}
+
+
+bool IDF_NOTE::ReadNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState,
+                         IDF3::IDF_UNIT aBoardUnit )
+{
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+
+    // RECORD 2: X, Y, text Height, text Length, "TEXT"
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board notes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within a section (NOTES)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: X position in NOTES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( ".END_NOTES", token ) )
+    {
+        // the end of the note section is a special case; although we return 'false'
+        // we do not change the board's state variable and we ensure that errno is 0;
+        // all other false returns set the state to FILE_INVALID
+        errno = 0;
+        return false;
+    }
+
+    istringstream istr;
+    istr.str( token );
+
+    istr >> xpos;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: X position in NOTES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Y position in NOTES section is missing\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Y position in NOTES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> ypos;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Y position in NOTES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text height in NOTES section is missing\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text height in NOTES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> height;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text height in NOTES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text length in NOTES section is missing\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text length in NOTES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> length;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text length in NOTES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: text value in NOTES section is missing\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    text = token;
+
+    if( aBoardUnit == UNIT_THOU )
+    {
+        xpos *= 0.0254;
+        ypos *= 0.0254;
+        height *= 0.0254;
+        length *= 0.0254;
+    }
+
+    return true;
+}
+
+
+bool IDF_NOTE::WriteNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
+{
+    if( aBoardUnit == UNIT_THOU )
+    {
+        aBoardFile << setiosflags(ios::fixed) << setprecision(1)
+                   << (xpos / 0.0254) << " "
+                   << (ypos / 0.0254) << " "
+                   << (height / 0.0254) << " "
+                   << (length / 0.0254) << " ";
+    }
+    else
+    {
+        aBoardFile << setiosflags(ios::fixed) << setprecision(5)
+                   << xpos << " " << ypos << " " << height << " " << length << " ";
+    }
+
+    aBoardFile << "\"" << text << "\"\n";
+
+    return !aBoardFile.bad();
+}
+
+
+void IDF_NOTE::SetText( const std::string& aText )
+{
+    text = aText;
+    return;
+}
+
+void IDF_NOTE::SetPosition( double aXpos, double aYpos )
+{
+    xpos = aXpos;
+    ypos = aYpos;
+    return;
+}
+
+void IDF_NOTE::SetSize( double aHeight, double aLength )
+{
+    height = aHeight;
+    length = aLength;
+    return;
+}
+
+const std::string& IDF_NOTE::GetText( void )
+{
+    return text;
+}
+
+void IDF_NOTE::GetPosition( double& aXpos, double& aYpos )
+{
+    aXpos = xpos;
+    aYpos = ypos;
+    return;
+}
+
+void IDF_NOTE::GetSize( double& aHeight, double& aLength )
+{
+    aHeight = height;
+    aLength = length;
+    return;
+}
+
+
+/*
+ * CLASS: IDF_DRILL_DATA
+ */
+IDF_DRILL_DATA::IDF_DRILL_DATA()
+{
+    dia = 0.0;
+    x = 0.0;
+    y = 0.0;
+    plating = NPTH;
+    kref = NOREFDES;
+    khole = MTG;
+    owner = UNOWNED;
+
+    return;
+}
+
+
+IDF_DRILL_DATA::IDF_DRILL_DATA( double aDrillDia, double aPosX, double aPosY,
+                                IDF3::KEY_PLATING aPlating,
+                                const std::string aRefDes,
+                                const std::string aHoleType,
+                                IDF3::KEY_OWNER aOwner )
+{
+    if( aDrillDia < 0.3 )
+        dia = 0.3;
+    else
+        dia = aDrillDia;
+
+    x = aPosX;
+    y = aPosY;
+    plating = aPlating;
+
+    if( !aRefDes.compare( "BOARD" ) )
+    {
+        kref = BOARD;
+    }
+    else if( aRefDes.empty() || !aRefDes.compare( "NOREFDES" ) )
+    {
+        kref = NOREFDES;
+    }
+    else if( !aRefDes.compare( "PANEL" ) )
+    {
+        kref = PANEL;
+    }
+    else
+    {
+        kref = REFDES;
+        refdes = aRefDes;
+    }
+
+    if( !aHoleType.compare( "PIN" ) )
+    {
+        khole = PIN;
+    }
+    else if( !aHoleType.compare( "VIA" ) )
+    {
+        khole = VIA;
+    }
+    else if( aHoleType.empty() || !aHoleType.compare( "MTG" ) )
+    {
+        khole = MTG;
+    }
+    else if( !aHoleType.compare( "TOOL" ) )
+    {
+        khole = TOOL;
+    }
+    else
+    {
+        khole = OTHER;
+        holetype = aHoleType;
+    }
+
+    owner = aOwner;
+}    // IDF_DRILL_DATA::IDF_DRILL_DATA( ... )
+
+bool IDF_DRILL_DATA::Matches( double aDrillDia, double aPosX, double aPosY )
+{
+    double ddia = aDrillDia - dia;
+    IDF_POINT p1, p2;
+
+    p1.x = x;
+    p1.y = y;
+    p2.x = aPosX;
+    p2.y = aPosY;
+
+    if( ddia > -0.00001 && ddia < 0.00001 && p1.Matches( p2, 0.00001 ) )
+        return true;
+
+    return false;
+}
+
+bool IDF_DRILL_DATA::Read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit,
+                           IDF3::FILE_STATE aBoardState )
+{
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+
+    // RECORD 2: DIA, X, Y, Plating Style, REFDES, HOLE TYPE, HOLE OWNER
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board drilled holes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within a section (DRILLED HOLES)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: drill diameter must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( ".END_DRILLED_HOLES", token ) )
+    {
+        // the end of the section is a special case; although we return 'false'
+        // we do not change the board's state variable and we ensure that errno is 0;
+        // all other false returns set the state to FILE_INVALID
+        errno = 0;
+        return false;
+    }
+
+    istringstream istr;
+    istr.str( token );
+
+    istr >> dia;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: drill diameter is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( ( aBoardUnit == UNIT_MM && dia < IDF_MIN_DIA_MM )
+        || ( aBoardUnit != UNIT_MM && dia < IDF_MIN_DIA_THOU ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Invalid drill diameter (too small): " << token << "\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing X position for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: X position in DRILLED HOLES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> x;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "* Violation of specification: X position in DRILLED HOLES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing Y position for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Y position in DRILLED HOLES section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> y;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "* Violation of specification: Y position in DRILLED HOLES section is not numeric\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing PLATING for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "PTH", token ) )
+    {
+        plating = IDF3::PTH;
+    }
+    else if( CompareToken( "NPTH", token ) )
+    {
+        plating = IDF3::NPTH;
+    }
+    else
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: invalid PLATING type ('" << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing REFDES for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "BOARD", token ) )
+    {
+        kref = IDF3::BOARD;
+    }
+    else if( CompareToken( "NOREFDES", token ) )
+    {
+        kref = IDF3::NOREFDES;
+    }
+    else if( CompareToken( "PANEL", token ) )
+    {
+        kref = IDF3::PANEL;
+    }
+    else
+    {
+        kref = IDF3::REFDES;
+        refdes = token;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing HOLE TYPE for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "PIN", token ) )
+    {
+        khole = IDF3::PIN;
+    }
+    else if( CompareToken( "VIA", token ) )
+    {
+        khole = IDF3::VIA;
+    }
+    else if( CompareToken( "MTG", token ) )
+    {
+        khole = IDF3::MTG;
+    }
+    else if( CompareToken( "TOOL", token ) )
+    {
+        khole = IDF3::TOOL;
+    }
+    else
+    {
+        khole = IDF3::OTHER;
+        holetype = token;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: missing OWNER for drilled hole\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !ParseOwner( token, owner ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: invalid OWNER for drilled hole ('" << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( aBoardUnit == UNIT_THOU )
+    {
+        dia *= 0.0254;
+        x *= 0.0254;
+        y *= 0.0254;
+    }
+
+    return true;
+}
+
+bool IDF_DRILL_DATA::Write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
+{
+    std::string holestr;
+    std::string refstr;
+    std::string ownstr;
+    std::string pltstr;
+
+    switch( khole )
+    {
+        case PIN:
+            holestr = "PIN";
+            break;
+
+        case VIA:
+            holestr = "VIA";
+            break;
+
+        case TOOL:
+            holestr = "TOOL";
+            break;
+
+        case OTHER:
+            holestr = "\"" + holetype + "\"";
+            break;
+
+        default:
+            holestr = "MTG";
+            break;
+    }
+
+    switch( kref )
+    {
+        case BOARD:
+            refstr = "BOARD";
+            break;
+
+        case PANEL:
+            refstr = "PANEL";
+            break;
+
+        case REFDES:
+            refstr = "\"" + refdes + "\"";
+            break;
+
+        default:
+            refstr = "NOREFDES";
+            break;
+    }
+
+    if( plating == PTH )
+        pltstr = "PTH";
+    else
+        pltstr = "NPTH";
+
+    switch( owner )
+    {
+        case MCAD:
+            ownstr = "MCAD";
+            break;
+
+        case ECAD:
+            ownstr = "ECAD";
+            break;
+
+        default:
+            ownstr = "UNOWNED";
+            break;
+    }
+
+    if( aBoardUnit == UNIT_MM )
+    {
+        aBoardFile << std::setiosflags( std::ios::fixed ) << std::setprecision( 3 ) << dia << " "
+            << std::setprecision( 5 ) << x << " " << y << " "
+            << pltstr.c_str() << " " << refstr.c_str() << " "
+            << holestr.c_str() << " " << ownstr.c_str() << "\n";
+    }
+    else
+    {
+        aBoardFile << std::setiosflags( std::ios::fixed ) << std::setprecision( 1 ) << (dia / 0.0254) << " "
+        << std::setprecision( 1 ) << (x / 0.0254) << " " << (y / 0.0254) << " "
+            << pltstr.c_str() << " " << refstr.c_str() << " "
+            << holestr.c_str() << " " << ownstr.c_str() << "\n";
+    }
+
+    return ! aBoardFile.fail();
+}    // IDF_DRILL_DATA::Write( aBoardFile, unitMM )
+
+
+double IDF_DRILL_DATA::GetDrillDia()
+{
+    return dia;
+}
+
+double IDF_DRILL_DATA::GetDrillXPos()
+{
+    return x;
+}
+
+double IDF_DRILL_DATA::GetDrillYPos()
+{
+    return y;
+}
+
+IDF3::KEY_PLATING IDF_DRILL_DATA::GetDrillPlating()
+{
+    return plating;
+}
+
+const std::string& IDF_DRILL_DATA::GetDrillRefDes()
+{
+    switch( kref )
+    {
+        case BOARD:
+            refdes = "BOARD";
+            break;
+
+        case PANEL:
+            refdes = "PANEL";
+            break;
+
+        case REFDES:
+            break;
+
+        default:
+            refdes = "NOREFDES";
+            break;
+    }
+
+    return refdes;
+}
+
+const std::string& IDF_DRILL_DATA::GetDrillHoleType()
+{
+    switch( khole )
+    {
+        case PIN:
+            holetype = "PIN";
+            break;
+
+        case VIA:
+            holetype = "VIA";
+            break;
+
+        case TOOL:
+            holetype = "TOOL";
+            break;
+
+        case OTHER:
+            break;
+
+        default:
+            holetype = "MTG";
+            break;
+    }
+
+    return holetype;
+}
+
+
+#ifdef DEBUG_IDF
+void IDF3::PrintSeg( IDF_SEGMENT* aSegment )
+{
+    if( aSegment->IsCircle() )
+    {
+        fprintf(stdout, "printSeg(): CIRCLE: C(%.3f, %.3f) P(%.3f, %.3f) rad. %.3f\n",
+                aSegment->startPoint.x, aSegment->startPoint.y,
+                aSegment->endPoint.x, aSegment->endPoint.y,
+                aSegment->radius );
+        return;
+    }
+
+    if( aSegment->angle < -MIN_ANG || aSegment->angle > MIN_ANG )
+    {
+        fprintf(stdout, "printSeg(): ARC: p1(%.3f, %.3f) p2(%.3f, %.3f) ang. %.3f\n",
+                aSegment->startPoint.x, aSegment->startPoint.y,
+                aSegment->endPoint.x, aSegment->endPoint.y,
+                aSegment->angle );
+        return;
+    }
+
+    fprintf(stdout, "printSeg(): LINE: p1(%.3f, %.3f) p2(%.3f, %.3f)\n",
+            aSegment->startPoint.x, aSegment->startPoint.y,
+            aSegment->endPoint.x, aSegment->endPoint.y );
+
+    return;
+}
+#endif
+
+
+bool IDF_POINT::Matches( const IDF_POINT& aPoint, double aRadius )
+{
+    double dx = x - aPoint.x;
+    double dy = y - aPoint.y;
+
+    double d2 = dx * dx + dy * dy;
+
+    if( d2 <= aRadius * aRadius )
+        return true;
+
+    return false;
+}
+
+
+double IDF_POINT::CalcDistance( const IDF_POINT& aPoint ) const
+{
+    double dx   = aPoint.x - x;
+    double dy   = aPoint.y - y;
+    double dist = sqrt( dx * dx + dy * dy );
+
+    return dist;
+}
+
+
+double IDF3::CalcAngleRad( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint )
+{
+    return atan2( aEndPoint.y - aStartPoint.y, aEndPoint.x - aStartPoint.x );
+}
+
+
+double IDF3::CalcAngleDeg( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint )
+{
+    double ang = CalcAngleRad( aStartPoint, aEndPoint );
+
+    // round to thousandths of a degree
+    int iang = int (ang / M_PI * 1800000.0);
+
+    ang = iang / 10000.0;
+
+    return ang;
+}
+
+
+void IDF3::GetOutline( std::list<IDF_SEGMENT*>& aLines,
+                       IDF_OUTLINE& aOutline )
+{
+    aOutline.Clear();
+
+    // NOTE: To tell if the point order is CCW or CW,
+    // sum all:  (endPoint.X[n] - startPoint.X[n])*(endPoint[n] + startPoint.Y[n])
+    // If the result is >0, the direction is CW, otherwise
+    // it is CCW. Note that the result cannot be 0 unless
+    // we have a bounded area of 0.
+
+    // First we find the segment with the leftmost point
+    std::list<IDF_SEGMENT*>::iterator bl    = aLines.begin();
+    std::list<IDF_SEGMENT*>::iterator el    = aLines.end();
+    std::list<IDF_SEGMENT*>::iterator idx   = bl++;       // iterator for the object with minX
+
+    double minx = (*idx)->GetMinX();
+    double curx;
+
+    while( bl != el )
+    {
+        curx = (*bl)->GetMinX();
+
+        if( curx < minx )
+        {
+            minx = curx;
+            idx = bl;
+        }
+
+        ++bl;
+    }
+
+    aOutline.push( *idx );
+#ifdef DEBUG_IDF
+    PrintSeg( *idx );
+#endif
+    aLines.erase( idx );
+
+    // If the item is a circle then we're done
+    if( aOutline.front()->IsCircle() )
+        return;
+
+    // Assemble the loop
+    bool complete = false;  // set if loop is complete
+    bool matched;           // set if a segment's end point was matched
+
+    while( !complete )
+    {
+        matched = false;
+        bl  = aLines.begin();
+        el  = aLines.end();
+
+        while( bl != el && !matched )
+        {
+            if( (*bl)->MatchesStart( aOutline.back()->endPoint ) )
+            {
+                if( (*bl)->IsCircle() )
+                {
+                    // a circle on the perimeter is pathological but we just ignore it
+                    ++bl;
+                }
+                else
+                {
+                    matched = true;
+#ifdef DEBUG_IDF
+                    PrintSeg( *bl );
+#endif
+                    aOutline.push( *bl );
+                    aLines.erase( bl );
+                }
+
+                continue;
+            }
+
+            ++bl;
+        }
+
+        if( !matched )
+        {
+            // attempt to match the end points
+            bl  = aLines.begin();
+            el  = aLines.end();
+
+            while( bl != el && !matched )
+            {
+                if( (*bl)->MatchesEnd( aOutline.back()->endPoint ) )
+                {
+                    if( (*bl)->IsCircle() )
+                    {
+                        // a circle on the perimeter is pathological but we just ignore it
+                        ++bl;
+                    }
+                    else
+                    {
+                        matched = true;
+                        (*bl)->SwapEnds();
+#ifdef DEBUG_IDF
+                        printSeg( *bl );
+#endif
+                        aOutline.push( *bl );
+                        aLines.erase( bl );
+                    }
+
+                    continue;
+                }
+
+                ++bl;
+            }
+        }
+
+        if( !matched )
+        {
+            // still no match - attempt to close the loop
+            if( (aOutline.size() > 1) || ( aOutline.front()->angle < -MIN_ANG )
+                || ( aOutline.front()->angle > MIN_ANG ) )
+            {
+                // close the loop
+                IDF_SEGMENT* seg = new IDF_SEGMENT( aOutline.back()->endPoint,
+                                                    aOutline.front()->startPoint );
+
+                if( seg )
+                {
+                    complete = true;
+#ifdef DEBUG_IDF
+                    printSeg( seg );
+#endif
+                    aOutline.push( seg );
+                    break;
+                }
+            }
+
+            // the outline is bad; drop the segments
+            aOutline.Clear();
+
+            return;
+        }
+
+        // check if the loop is complete
+        if( aOutline.front()->MatchesStart( aOutline.back()->endPoint ) )
+        {
+            complete = true;
+            break;
+        }
+    }
+}
+
+
+IDF_SEGMENT::IDF_SEGMENT()
+{
+    angle = 0.0;
+    offsetAngle = 0.0;
+    radius = 0.0;
+}
+
+
+IDF_SEGMENT::IDF_SEGMENT( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint )
+{
+    angle = 0.0;
+    offsetAngle = 0.0;
+    radius = 0.0;
+    startPoint = aStartPoint;
+    endPoint = aEndPoint;
+}
+
+
+IDF_SEGMENT::IDF_SEGMENT( const IDF_POINT& aStartPoint,
+                          const IDF_POINT& aEndPoint,
+                          double aAngle,
+                          bool aFromKicad )
+{
+    double diff = abs( aAngle ) - 360.0;
+
+    if( ( diff < MIN_ANG
+        && diff > -MIN_ANG ) || ( aAngle < MIN_ANG && aAngle > -MIN_ANG ) || (!aFromKicad) )
+    {
+        angle = 0.0;
+        startPoint = aStartPoint;
+        endPoint = aEndPoint;
+
+        if( diff < MIN_ANG && diff > -MIN_ANG )
+        {
+            angle = 360.0;
+            center = aStartPoint;
+            offsetAngle = 0.0;
+            radius = aStartPoint.CalcDistance( aEndPoint );
+        }
+        else if( aAngle < MIN_ANG && aAngle > -MIN_ANG )
+        {
+            CalcCenterAndRadius();
+        }
+
+        return;
+    }
+
+    // we need to convert from the KiCad arc convention
+    angle = aAngle;
+
+    center = aStartPoint;
+
+    offsetAngle = IDF3::CalcAngleDeg( aStartPoint, aEndPoint );
+
+    radius = aStartPoint.CalcDistance( aEndPoint );
+
+    startPoint = aEndPoint;
+
+    double ang = offsetAngle + aAngle;
+    ang = (ang / 180.0) * M_PI;
+
+    endPoint.x  = ( radius * cos( ang ) ) + center.x;
+    endPoint.y  = ( radius * sin( ang ) ) + center.y;
+}
+
+
+bool IDF_SEGMENT::MatchesStart( const IDF_POINT& aPoint, double aRadius )
+{
+    return startPoint.Matches( aPoint, aRadius );
+}
+
+
+bool IDF_SEGMENT::MatchesEnd( const IDF_POINT& aPoint, double aRadius )
+{
+    return endPoint.Matches( aPoint, aRadius );
+}
+
+
+void IDF_SEGMENT::CalcCenterAndRadius( void )
+{
+    // NOTE:  this routine does not check if the points are the same
+    // or too close to be sensible in a production setting.
+
+    double offAng = IDF3::CalcAngleRad( startPoint, endPoint );
+    double d = startPoint.CalcDistance( endPoint ) / 2.0;
+    double xm   = ( startPoint.x + endPoint.x ) * 0.5;
+    double ym   = ( startPoint.y + endPoint.y ) * 0.5;
+
+    radius = d / sin( angle * M_PI / 180.0 );
+
+    if( radius < 0.0 )
+    {
+        radius = -radius;
+    }
+
+    // calculate the height of the triangle with base d and hypotenuse r
+    double dh2 = radius * radius - d * d;
+
+    if( dh2 < 0 )
+    {
+        // this should only ever happen due to rounding errors when r == d
+        dh2 = 0;
+    }
+
+    double h = sqrt( dh2 );
+
+    if( angle > 0.0 )
+        offAng += M_PI2;
+    else
+        offAng -= M_PI2;
+
+    if( ( angle > M_PI ) || ( angle < -M_PI ) )
+        offAng += M_PI;
+
+    center.x = h * cos( offAng ) + xm;
+    center.y = h * sin( offAng ) + ym;
+
+    offsetAngle = IDF3::CalcAngleDeg( center, startPoint );
+}
+
+
+bool IDF_SEGMENT::IsCircle( void )
+{
+    double diff = abs( angle ) - 360.0;
+
+    if( ( diff < MIN_ANG ) && ( diff > -MIN_ANG ) )
+        return true;
+
+    return false;
+}
+
+
+double IDF_SEGMENT::GetMinX( void )
+{
+    if( angle == 0.0 )
+        return std::min( startPoint.x, endPoint.x );
+
+    // Calculate the leftmost point of the circle or arc
+
+    if( IsCircle() )
+    {
+        // if only everything were this easy
+        return center.x - radius;
+    }
+
+    // cases:
+    // 1. CCW arc: if offset + included angle >= 180 deg then
+    // MinX = center.x - radius, otherwise MinX is the
+    // same as for the case of a line.
+    // 2. CW arc: if offset + included angle <= -180 deg then
+    // MinX = center.x - radius, otherwise MinX is the
+    // same as for the case of a line.
+
+    if( angle > 0 )
+    {
+        // CCW case
+        if( ( offsetAngle + angle ) >= 180.0 )
+        {
+            return center.x - radius;
+        }
+        else
+        {
+            return std::min( startPoint.x, endPoint.x );
+        }
+    }
+
+    // CW case
+    if( ( offsetAngle + angle ) <= -180.0 )
+    {
+        return center.x - radius;
+    }
+
+    return std::min( startPoint.x, endPoint.x );
+}
+
+
+void IDF_SEGMENT::SwapEnds( void )
+{
+    if( IsCircle() )
+    {
+        // reverse the direction
+        angle = -angle;
+        return;
+    }
+
+    IDF_POINT tmp = startPoint;
+    startPoint = endPoint;
+    endPoint = tmp;
+
+    if( ( angle < MIN_ANG ) && ( angle > -MIN_ANG ) )
+        return;         // nothing more to do
+
+        // change the direction of the arc
+        angle = -angle;
+    // calculate the new offset angle
+    offsetAngle = IDF3::CalcAngleDeg( center, startPoint );
+}
+
+
+bool IDF_OUTLINE::IsCCW( void )
+{
+    // note: when outlines are not valid, 'false' is returned
+    switch( outline.size() )
+    {
+    case 0:
+        // no outline
+        return false;
+        break;
+
+    case 1:
+        // circles are always reported as CCW
+        if( outline.front()->IsCircle() )
+            return true;
+        else
+            return false;
+        break;
+
+    case 2:
+        // we may have a closed outline consisting of:
+        // 1. arc and line, winding depends on the arc
+        // 2. 2 arcs, winding depends on larger arc
+        {
+            double a1 = outline.front()->angle;
+            double a2 = outline.back()->angle;
+
+            if( ( a1 < -MIN_ANG || a1 > MIN_ANG )
+                && ( a2 < -MIN_ANG || a2 > MIN_ANG ) )
+            {
+                // we have 2 arcs
+                if( abs( a1 ) >= abs( a2 ) )
+                {
+                    // winding depends on a1
+                    if( a1 < 0.0 )
+                        return false;
+                    else
+                        return true;
+                }
+                else
+                {
+                    if( a2 < 0.0 )
+                        return false;
+                    else
+                        return true;
+                }
+            }
+
+            // we may have a line + arc (or 2 lines)
+            if( a1 < -MIN_ANG )
+                return false;
+
+            if( a1 > MIN_ANG )
+                return true;
+
+            if( a2 < -MIN_ANG )
+                return false;
+
+            if( a2 > MIN_ANG )
+                return true;
+
+            // we have 2 lines (invalid outline)
+            return false;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    double winding = dir + ( outline.front()->startPoint.x - outline.back()->endPoint.x )
+    * ( outline.front()->startPoint.y + outline.back()->endPoint.y );
+
+    if( winding > 0.0 )
+        return false;
+
+    return true;
+}
+
+
+bool IDF_OUTLINE::push( IDF_SEGMENT* item )
+{
+    if( !outline.empty() )
+    {
+        if( item->IsCircle() )
+        {
+            // not allowed
+            ERROR << "INVALID GEOMETRY\n";
+            cerr << "* a circle is being added to a non-empty outline\n";
+            return false;
+        }
+        else
+        {
+            if( outline.back()->IsCircle() )
+            {
+                // we can't add lines to a circle
+                ERROR << "INVALID GEOMETRY\n";
+                cerr << "* a line is being added to a circular outline\n";
+                return false;
+            }
+            else if( !item->MatchesStart( outline.back()->endPoint ) )
+            {
+                // startPoint[N] != endPoint[N -1]
+                ERROR << "INVALID GEOMETRY\n";
+                cerr << "* disjoint segments (current start point != last end point)\n";
+                cerr << "* start point: " << item->startPoint.x << ", " << item->startPoint.y << "\n";
+                cerr << "* end point: " << outline.back()->endPoint.x << ", " << outline.back()->endPoint.y << "\n";
+                return false;
+            }
+        }
+    }
+
+    outline.push_back( item );
+    dir += ( outline.back()->endPoint.x - outline.back()->startPoint.x )
+    * ( outline.back()->endPoint.y + outline.back()->startPoint.y );
+
+    return true;
+}

=== added file 'utils/idftools/idf_common.h'
--- utils/idftools/idf_common.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_common.h	2014-05-15 07:35:12 +0000
@@ -0,0 +1,437 @@
+/**
+ * @file idf_common.h
+ */
+
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2013-2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#ifndef IDF_COMMON_H
+#define IDF_COMMON_H
+
+#include <list>
+#include <fstream>
+
+#ifndef M_PI
+#define M_PI 3.1415926535897932384626433832795028841
+#endif
+
+#ifndef M_PI2
+#define M_PI2 ( M_PI / 2.0 )
+#endif
+
+#ifndef M_PI4
+#define M_PI4 ( M_PI / 4.0 )
+#endif
+
+// differences in angle smaller than MIN_ANG are considered equal
+#define MIN_ANG     (0.01)
+
+class IDF_POINT;
+class IDF_SEGMENT;
+class IDF_DRILL_DATA;
+class IDF_OUTLINE;
+class IDF_LIB;
+
+namespace IDF3 {
+
+    enum FILE_STATE
+    {
+        FILE_START = 0, // no data has been read; expecting .HEADER
+        FILE_HEADER,    // header has been read; expecting  .BOARD_OUTLINE
+        FILE_OUTLINE,   // board outline has been read; most sections can be accepted
+        FILE_PLACEMENT, // placement has been read; no further sections can be accepted
+        FILE_INVALID,   // file is invalid
+        FILE_ERROR      // other errors while processing the file
+    };
+
+    enum KEY_OWNER
+    {
+        UNOWNED = 0,        //< either MCAD or ECAD may modify a feature
+        MCAD,               //< only MCAD may modify a feature
+        ECAD                //< only ECAD may modify a feature
+    };
+
+    enum KEY_HOLETYPE
+    {
+        PIN = 0,            //< drill hole is for a pin
+        VIA,                //< drill hole is for a via
+        MTG,                //< drill hole is for mounting
+        TOOL,               //< drill hole is for tooling
+        OTHER               //< user has specified a custom type
+    };
+
+    enum KEY_PLATING
+    {
+        PTH = 0,            //< Plate-Through Hole
+        NPTH                //< Non-Plate-Through Hole
+    };
+
+    enum KEY_REFDES
+    {
+        BOARD = 0,          //< feature is associated with the board
+        NOREFDES,           //< feature is associated with a component with no RefDes
+        PANEL,              //< feature is associated with an IDF panel
+        REFDES              //< reference designator as assigned by the CAD software
+    };
+
+    enum CAD_TYPE
+    {
+        CAD_ELEC = 0,       //< An Electrical CAD is opening/modifying the file
+        CAD_MECH,           //< A Mechanical CAD is opening/modifying the file
+        CAD_INVALID
+    };
+
+    enum IDF_LAYER
+    {
+        LYR_TOP = 0,
+        LYR_BOTTOM,
+        LYR_BOTH,
+        LYR_INNER,
+        LYR_ALL,
+        LYR_INVALID
+    };
+
+    enum OUTLINE_TYPE
+    {
+        OTLN_BOARD = 0,
+        OTLN_OTHER,
+        OTLN_PLACE,
+        OTLN_ROUTE,
+        OTLN_PLACE_KEEPOUT,
+        OTLN_ROUTE_KEEPOUT,
+        OTLN_VIA_KEEPOUT,
+        OTLN_GROUP_PLACE,
+        OTLN_COMPONENT,
+        OTLN_INVALID
+    };
+
+    enum COMP_TYPE
+    {
+        COMP_ELEC = 0,      //< Component library object is an electrical part
+        COMP_MECH,          //< Component library object is a mechanical part
+        COMP_INVALID
+    };
+
+    enum IDF_UNIT
+    {
+        UNIT_MM = 0,        //< Units in the file are in millimeters
+        UNIT_THOU,          //< Units in the file are in mils (aka thou)
+        UNIT_INVALID
+    };
+
+    enum IDF_PLACEMENT
+    {
+        PS_UNPLACED = 0,    //< component location on the board has not been specified
+        PS_PLACED,          //< component location has been specified and may be modified by ECAD or MCAD
+        PS_MCAD,            //< component location has been specified and may only be modified by MCAD
+        PS_ECAD,            //< component location has been specified and may only be modified by ECAD
+        PS_INVALID
+    };
+
+    // calculate the angle between the horizon and the segment aStartPoint to aEndPoint
+    double  CalcAngleRad( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint );
+    double  CalcAngleDeg( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint );
+
+    // take contiguous elements from 'lines' and stuff them into 'outline'
+    void GetOutline( std::list<IDF_SEGMENT*>& aLines,
+                     IDF_OUTLINE& aOutline );
+
+#ifdef DEBUG_IDF
+    // prints out segment information for debug purposes
+    void PrintSeg( IDF_SEGMENT* aSegment );
+#endif
+}
+
+
+class IDF_NOTE
+{
+private:
+    std::string text;
+    double xpos;
+    double ypos;
+    double height;
+    double length;
+
+public:
+    IDF_NOTE();
+
+    bool ReadNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState, IDF3::IDF_UNIT aBoardUnit );
+    bool WriteNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
+
+    void SetText( const std::string& aText );
+    void SetPosition( double aXpos, double aYpos );
+    void SetSize( double aHeight, double aLength );
+
+    const std::string& GetText( void );
+    void GetPosition( double& aXpos, double& aYpos );
+    void GetSize( double& aHeight, double& aLength );
+};
+
+
+/**
+ * @Class IDF_DRILL_DATA
+ * contains information describing a drilled hole and is responsible for
+ * writing this information to a file in compliance with the IDFv3 specification.
+ */
+class IDF_DRILL_DATA
+{
+private:
+    double dia;
+    double x;
+    double y;
+    IDF3::KEY_PLATING plating;
+    IDF3::KEY_REFDES kref;
+    IDF3::KEY_HOLETYPE khole;
+    std::string refdes;
+    std::string holetype;
+    IDF3::KEY_OWNER owner;
+
+public:
+    /**
+     * Constructor IDF_DRILL_DATA
+     * creates a drill entry with information compliant with the
+     * IDFv3 specifications.
+     * @param aDrillDia : drill diameter
+     * @param aPosX : X coordinate of the drill center
+     * @param aPosY : Y coordinate of the drill center
+     * @param aPlating : flag, PTH or NPTH
+     * @param aRefDes : component Reference Designator
+     * @param aHoleType : purpose of hole
+     * @param aOwner : one of MCAD, ECAD, UNOWNED
+     */
+    IDF_DRILL_DATA();
+
+    IDF_DRILL_DATA( double aDrillDia, double aPosX, double aPosY,
+                    IDF3::KEY_PLATING aPlating,
+                    const std::string aRefDes,
+                    const std::string aHoleType,
+                    IDF3::KEY_OWNER aOwner );
+
+    bool Matches( double aDrillDia, double aPosX, double aPosY );
+
+    /**
+     * Function Read
+     * read a single line from an IDFv3 .DRILLED_HOLES section
+     */
+    bool Read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit, IDF3::FILE_STATE aBoardState );
+
+    /**
+     * Function Write
+     * writes a single line representing the hole within a .DRILLED_HOLES section
+     */
+    bool Write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
+
+    double GetDrillDia();
+    double GetDrillXPos();
+    double GetDrillYPos();
+    IDF3::KEY_PLATING GetDrillPlating();
+    const std::string& GetDrillRefDes();
+    const std::string& GetDrillHoleType();
+};
+
+
+/**
+ * @Class IDF_POINT
+ * represents a point
+ */
+class IDF_POINT
+{
+public:
+    double x;   // < X coordinate
+    double y;   // < Y coordinate
+
+    IDF_POINT()
+    {
+        x = 0.0;
+        y = 0.0;
+    }
+
+    /**
+     * Function Matches()
+     * returns true if the given coordinate point is within the given radius
+     * of the point.
+     * @param aPoint : coordinates of the point being compared
+     * @param aRadius : radius within which the points are considered the same
+     */
+    bool    Matches( const IDF_POINT& aPoint, double aRadius = 1e-5 );
+    double  CalcDistance( const IDF_POINT& aPoint ) const;
+};
+
+
+/**
+ * @Class IDF_SEGMENT
+ * represents a geometry segment as used in IDFv3 outlines
+ */
+class IDF_SEGMENT
+{
+private:
+    /**
+     * Function CalcCenterAndRadius()
+     * Calculates the center, radius, and angle between center and start point given the
+     * IDF compliant points and included angle.
+     * @var startPoint, @var endPoint, and @var angle must be set prior as per IDFv3
+     */
+    void CalcCenterAndRadius( void );
+
+public:
+    IDF_POINT startPoint;   // starting point in IDF coordinates
+    IDF_POINT endPoint;     // end point in IDF coordinates
+    IDF_POINT   center;     // center of an arc or circle; used primarily for calculating min X
+    double  angle;          // included angle (degrees) according to IDFv3 specification
+    double  offsetAngle;    // angle between center and start of arc; used to speed up some calcs.
+    double  radius;         // radius of the arc or circle; used to speed up some calcs.
+
+    /**
+     * Function IDF_SEGMENT()
+     * initializes the internal variables
+     */
+    IDF_SEGMENT();
+
+    /**
+     * Function IDF_SEGMENT( start, end )
+     * creates a straight segment
+     */
+    IDF_SEGMENT( const IDF_POINT& aStartPoint, const IDF_POINT& aEndPoint );
+
+    /**
+     * Function IDF_SEGMENT( start, end )
+     * creates a straight segment, arc, or circle depending on the angle
+     * @param aStartPoint : start point (center if using KiCad convention, otherwise IDF convention)
+     * @param aEndPoint : end point (start of arc if using KiCad convention, otherwise IDF convention)
+     * @param aAngle : included angle; the KiCad convention is equivalent to the IDF convention
+     * @param fromKicad : set true if we need to convert from KiCad to IDF convention
+     */
+    IDF_SEGMENT( const IDF_POINT& aStartPoint,
+                 const IDF_POINT& aEndPoint,
+                 double aAngle,
+                 bool aFromKicad );
+
+    /**
+     * Function MatchesStart()
+     * returns true if the given coordinate is within a radius 'rad'
+     * of the start point.
+     * @param aPoint : coordinates of the point being compared
+     * @param aRadius : radius within which the points are considered the same
+     */
+    bool MatchesStart( const IDF_POINT& aPoint, double aRadius = 1e-3 );
+
+    /**
+     * Function MatchesEnd()
+     * returns true if the given coordinate is within a radius 'rad'
+     * of the end point.
+     * @param aPoint : coordinates of the point being compared
+     * @param aRadius : radius within which the points are considered the same
+     */
+    bool MatchesEnd( const IDF_POINT& aPoint, double aRadius = 1e-3 );
+
+    /**
+     * Function IsCircle()
+     * returns true if this segment is a circle
+     */
+    bool IsCircle( void );
+
+    /**
+     * Function GetMinX()
+     * returns the minimum X coordinate of this segment
+     */
+    double GetMinX( void );
+
+    /**
+     * Function SwapEnds()
+     * Swaps the start and end points and alters internal
+     * variables as necessary for arcs
+     */
+    void SwapEnds( void );
+};
+
+
+/**
+ * @Class IDF_OUTLINE
+ * contains segment and winding information for an IDF outline
+ */
+class IDF_OUTLINE
+{
+private:
+    double dir;
+    std::list<IDF_SEGMENT*> outline;
+
+public:
+    IDF_OUTLINE() { dir = 0.0; }
+    ~IDF_OUTLINE() { Clear(); }
+
+    // returns true if the current list of points represents a counterclockwise winding
+    bool IsCCW( void );
+
+    // clears the internal list of outline segments
+    void Clear( void )
+    {
+        dir = 0.0;
+
+        while( !outline.empty() )
+        {
+            delete outline.front();
+            outline.pop_front();
+        }
+    }
+
+    // returns the size of the internal segment list
+    size_t size( void )
+    {
+        return outline.size();
+    }
+
+    // returns true if the internal segment list is empty
+    bool empty( void )
+    {
+        return outline.empty();
+    }
+
+    // return the front() of the internal segment list
+    IDF_SEGMENT*& front( void )
+    {
+        return outline.front();
+    }
+
+    // return the back() of the internal segment list
+    IDF_SEGMENT*& back( void )
+    {
+        return outline.back();
+    }
+
+    // return the begin() iterator of the internal segment list
+    std::list<IDF_SEGMENT*>::iterator begin( void )
+    {
+        return outline.begin();
+    }
+
+    // return the end() iterator of the internal segment list
+    std::list<IDF_SEGMENT*>::iterator end( void )
+    {
+        return outline.end();
+    }
+
+    // push a segment onto the internal list
+    bool push( IDF_SEGMENT* item );
+};
+
+#endif  // IDF_COMMON_H

=== modified file 'utils/idftools/idf_cylinder.cpp'
--- utils/idftools/idf_cylinder.cpp	2014-02-21 10:05:28 +0000
+++ utils/idftools/idf_cylinder.cpp	2014-05-09 04:26:23 +0000
@@ -149,7 +149,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> dia) && dia > 0.0 )
+
+        tstr >> dia;
+        if( !tstr.fail() && dia > 0.0 )
             ok = true;
     }
 
@@ -163,7 +165,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> length) && length > 0.0 )
+
+        tstr >> length;
+        if( !tstr.fail() && length > 0.0 )
             ok = true;
     }
 
@@ -177,7 +181,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> extraZ) && extraZ >= 0.0 )
+
+        tstr >> extraZ;
+        if( !tstr.fail() && extraZ >= 0.0 )
             ok = true;
     }
 
@@ -191,7 +197,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> wireDia) && wireDia > 0.0 )
+
+        tstr >> wireDia;
+        if( !tstr.fail() && wireDia > 0.0 )
         {
             if( wireDia < dia )
                 ok = true;
@@ -236,7 +244,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> pitch) && pitch > 0.0 )
+
+        tstr >> pitch;
+        if( !tstr.fail() && pitch > 0.0 )
         {
             if( (pitch - wireDia) <= (dia / 2.0) )
             {
@@ -436,7 +446,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> pitch) && pitch > 0.0 )
+
+        tstr >> pitch;
+        if( !tstr.fail() && pitch > 0.0 )
         {
             if( axial )
             {
@@ -477,7 +489,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> lead) && lead > 0.0 )
+
+        tstr >> lead;
+        if( !tstr.fail() && lead > 0.0 )
         {
             if( lead < wireDia )
                 cout << "* WARNING: lead length must be >= wireDia\n";

=== added file 'utils/idftools/idf_helpers.cpp'
--- utils/idftools/idf_helpers.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_helpers.cpp	2014-05-15 08:32:04 +0000
@@ -0,0 +1,298 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <cctype>
+#include <iostream>
+#include <sstream>
+
+#include <idf_common.h>
+#include <idf_helpers.h>
+
+using namespace std;
+using namespace IDF3;
+
+// fetch a line from the given input file and trim the ends
+bool IDF3::FetchIDFLine( std::ifstream& aModel, std::string& aLine, bool& isComment, std::streampos& aFilePos )
+{
+    aLine = "";
+    aFilePos = aModel.tellg();
+
+    if( aFilePos == -1 )
+        return false;
+
+    std::getline( aModel, aLine );
+
+    isComment = false;
+
+    // A comment begins with a '#' and must be the first character on the line
+    if( aLine[0] == '#' )
+    {
+        // opening '#' and trailing spaces are stripped; leading spaces are preserved
+        isComment = true;
+        aLine.erase( aLine.begin() );
+
+        while( !aLine.empty() && isspace( *aLine.rbegin() ) )
+            aLine.erase( --aLine.end() );
+
+        return true;
+    }
+
+    while( !aLine.empty() && isspace( *aLine.begin() ) )
+        aLine.erase( aLine.begin() );
+
+    while( !aLine.empty() && isspace( *aLine.rbegin() ) )
+        aLine.erase( --aLine.end() );
+
+    if( aLine.empty() )
+        return false;
+
+    return true;
+}
+
+
+// extract an IDF string and move the index to point to the character after the substring
+bool IDF3::GetIDFString( const std::string& aLine, std::string& aIDFString,
+                          bool& hasQuotes, int& aIndex )
+{
+    // 1. drop all leading spaces
+    // 2. if the first character is '"', read until the next '"',
+    //    otherwise read until the next space or EOL.
+
+    std::ostringstream ostr;
+
+    int len = aLine.length();
+    int idx = aIndex;
+
+    if( idx < 0 || idx >= len )
+        return false;
+
+    while( isspace( aLine[idx] ) && idx < len ) ++idx;
+
+    if( idx == len )
+    {
+        aIndex = idx;
+        return false;
+    }
+
+    if( aLine[idx] == '"' )
+    {
+        hasQuotes = true;
+        ++idx;
+        while( aLine[idx] != '"' && idx < len )
+            ostr << aLine[idx++];
+
+        if( idx == len )
+        {
+            ERROR << "unterminated quote mark in line:\n";
+            std::cerr << "LINE: " << aLine << "\n";
+            aIndex = idx;
+            return false;
+        }
+
+        ++idx;
+    }
+    else
+    {
+        hasQuotes = false;
+
+        while( !isspace( aLine[idx] ) && idx < len )
+            ostr << aLine[idx++];
+
+    }
+
+    aIDFString = ostr.str();
+    aIndex = idx;
+
+    return true;
+}
+
+
+// perform a comparison between a fixed token string and an input string.
+// the token is assumed to be an upper case IDF token and the input string
+// is data from an IDF file. Since IDF tokens are case-insensitive, we cannot
+// assume anything about the case of the input string.
+bool IDF3::CompareToken( const char* aTokenString, const std::string& aInputString )
+{
+    std::string::size_type i, j;
+    std::string bigToken = aInputString;
+    j = aInputString.length();
+
+    for( i = 0; i < j; ++i )
+        bigToken[i] = std::toupper( bigToken[i] );
+
+    if( !bigToken.compare( aTokenString ) )
+        return true;
+
+    return false;
+}
+
+
+// parse a string for an IDF3::KEY_OWNER
+bool IDF3::ParseOwner( const std::string& aToken, IDF3::KEY_OWNER& aOwner )
+{
+    if( CompareToken( "UNOWNED", aToken ) )
+    {
+        aOwner = UNOWNED;
+        return true;
+    }
+    else if( CompareToken( "ECAD", aToken ) )
+    {
+        aOwner = ECAD;
+        return true;
+    }
+    else if( CompareToken( "MCAD", aToken ) )
+    {
+        aOwner = MCAD;
+        return true;
+    }
+
+    ERROR << "unrecognized IDF OWNER: '" << aToken << "'\n";
+
+    return false;
+}
+
+
+bool IDF3::ParseIDFLayer( const std::string& aToken, IDF3::IDF_LAYER& aLayer )
+{
+    if( CompareToken( "TOP", aToken ) )
+    {
+        aLayer = LYR_TOP;
+        return true;
+    }
+    else if( CompareToken( "BOTTOM", aToken ) )
+    {
+        aLayer = LYR_BOTTOM;
+        return true;
+    }
+    else if( CompareToken( "BOTH", aToken ) )
+    {
+        aLayer = LYR_BOTH;
+        return true;
+    }
+    else if( CompareToken( "INNER", aToken ) )
+    {
+        aLayer = LYR_INNER;
+        return true;
+    }
+    else if( CompareToken( "ALL", aToken ) )
+    {
+        aLayer = LYR_ALL;
+        return true;
+    }
+
+    ERROR << "unrecognized IDF LAYER: '" << aToken << "'\n";
+
+    aLayer = LYR_INVALID;
+    return false;
+}
+
+
+bool IDF3::WriteLayersText( std::ofstream& aBoardFile, IDF3::IDF_LAYER aLayer )
+{
+    switch( aLayer )
+    {
+        case LYR_TOP:
+            aBoardFile << "TOP";
+            break;
+
+        case LYR_BOTTOM:
+            aBoardFile << "BOTTOM";
+            break;
+
+        case LYR_BOTH:
+            aBoardFile << "BOTH";
+            break;
+
+        case LYR_INNER:
+            aBoardFile << "INNER";
+            break;
+
+        case LYR_ALL:
+            aBoardFile << "ALL";
+            break;
+
+        default:
+            ERROR << "Invalid IDF layer" << aLayer << "\n";
+            return false;
+            break;
+    }
+
+    return !aBoardFile.fail();
+}
+
+
+std::string IDF3::GetPlacementString( IDF3::IDF_PLACEMENT aPlacement )
+{
+    switch( aPlacement )
+    {
+        case PS_UNPLACED:
+            return "UNPLACED";
+
+        case PS_PLACED:
+            return "PLACED";
+
+        case PS_MCAD:
+            return "MCAD";
+
+        case PS_ECAD:
+            return "ECAD";
+
+        default:
+            break;
+    }
+
+    std::ostringstream ostr;
+    ostr << "[INVALID PLACEMENT VALUE]:" << aPlacement;
+
+    return ostr.str();
+}
+
+
+std::string IDF3::GetSideString( IDF3::IDF_LAYER aLayer )
+{
+    switch( aLayer )
+    {
+        case LYR_TOP:
+            return "TOP";
+
+        case LYR_BOTTOM:
+            return "BOTTOM";
+
+        case LYR_BOTH:
+            return "BOTH";
+
+        case LYR_INNER:
+            return "INNER";
+
+        case LYR_ALL:
+            return "ALL";
+
+        default:
+            break;
+    }
+
+    std::ostringstream ostr;
+    ostr << "[INVALID LAYER VALUE]:" << aLayer;
+
+    return ostr.str();
+}

=== added file 'utils/idftools/idf_helpers.h'
--- utils/idftools/idf_helpers.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_helpers.h	2014-05-15 05:36:13 +0000
@@ -0,0 +1,65 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#ifndef IDF_HELPERS_H
+#define IDF_HELPERS_H
+
+#include <fstream>
+#include <string>
+#include <idf_common.h>
+
+#define ERROR std::cerr << "* " << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): "
+
+// minimum drill diameters / slot widths to be represented in the IDF output
+#define IDF_MIN_DIA_MM ( 0.001 )
+#define IDF_MIN_DIA_THOU ( 0.00039 )
+
+namespace IDF3
+{
+
+// fetch a line from the given input file and trim the ends
+bool FetchIDFLine( std::ifstream& aModel, std::string& aLine, bool& isComment, std::streampos& aFilePos );
+
+// extract an IDF string and move the index to point to the character after the substring
+bool GetIDFString( const std::string& aLine, std::string& aIDFString,
+                   bool& hasQuotes, int& aIndex );
+
+// perform a case-insentitive compare of a token string and an input string
+bool CompareToken( const char* aTokenString, const std::string& aInputString );
+
+// parse a string for an IDF3::KEY_OWNER
+bool ParseOwner( const std::string& aToken, IDF3::KEY_OWNER& aOwner );
+
+// parse a string for an IDF3::IDF_LAYER
+bool ParseIDFLayer( const std::string& aToken, IDF3::IDF_LAYER& aLayer );
+
+// write the IDF3::IDF_LAYER as text
+bool WriteLayersText( std::ofstream& aBoardFile, IDF3::IDF_LAYER aLayer );
+
+std::string GetPlacementString( IDF3::IDF_PLACEMENT aPlacement );
+
+std::string GetSideString( IDF3::IDF_LAYER aLayer );
+
+}
+
+#endif // IDF_HELPERS_H
\ No newline at end of file

=== added file 'utils/idftools/idf_outlines.cpp'
--- utils/idftools/idf_outlines.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_outlines.cpp	2014-05-15 07:45:07 +0000
@@ -0,0 +1,2526 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <iostream>
+#include <iomanip>
+#include <sstream>
+#include <cmath>
+
+#include <idf_helpers.h>
+#include <idf_outlines.h>
+#include <idf_parser.h>
+
+using namespace IDF3;
+using namespace std;
+
+
+/*
+ * CLASS: BOARD OUTLINE
+ */
+BOARD_OUTLINE::BOARD_OUTLINE()
+{
+    outlineType = OTLN_BOARD;
+    single = false;
+    owner = UNOWNED;
+    parent = NULL;
+    thickness = 0.0;
+    unit = UNIT_MM;
+    return;
+}
+
+BOARD_OUTLINE::~BOARD_OUTLINE()
+{
+    Clear();
+    return;
+}
+
+IDF3::OUTLINE_TYPE BOARD_OUTLINE::GetOutlineType( void )
+{
+    return outlineType;
+}
+
+bool BOARD_OUTLINE::readOutlines( std::ifstream& aBoardFile )
+{
+    // reads the outline data from a file
+    double x, y, ang;
+    double dLoc  = 1e-5;    // distances are equal when closer than 0.1 micron
+    bool comment = false;
+    bool quoted  = false;
+    bool closed  = false;
+    int idx      = 0;
+    int loopidx  = -1;
+    int tmp      = 0;
+    int npts     = 0;
+    std::string iline;
+    std::string entry;
+    std::stringstream tstr;
+    IDF_OUTLINE* op = NULL;
+    IDF_SEGMENT* sp = NULL;
+    IDF_POINT prePt;
+    IDF_POINT curPt;
+    std::streampos pos;
+
+    // destroy any existing outline data
+    ClearOutlines();
+
+    while( aBoardFile.good() )
+    {
+        if( !FetchIDFLine( aBoardFile, iline, comment, pos ) )
+            continue;
+
+        idx = 0;
+        GetIDFString( iline, entry, quoted, idx );
+
+        if( quoted )
+        {
+            ERROR << "invalid outline; FIELD 1 is quoted\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        // check for the end of the section
+        if( entry.size() >= 5 && CompareToken( ".END_", entry.substr( 0, 5 ) ) )
+        {
+            // rewind to the start of the last line; the routine invoking
+            // this is responsible for checking that the current '.END_ ...'
+            // matches the section header.
+            aBoardFile.seekg( pos );
+
+            if( outlines.size() > 0 )
+            {
+                if( npts > 0 && !closed )
+                {
+                    ERROR << "invalid outline (not closed)\n";
+                    return false;
+                }
+
+                // verify winding
+                if( !single )
+                {
+                    if( !outlines.front()->IsCCW() )
+                    {
+                        ERROR << "first outline is not in CCW order\n";
+                        return false;
+                    }
+
+                    if( outlines.size() > 1 && outlines.back()->IsCCW() )
+                    {
+                        ERROR << "cutout points are not in CW order\n";
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        tstr.clear();
+        tstr << entry;
+
+        tstr >> tmp;
+        if( tstr.fail() )
+        {
+            if( outlineType == OTLN_COMPONENT && CompareToken( "PROP", entry ) )
+            {
+                aBoardFile.seekg( pos );
+                return true;
+            }
+
+            ERROR << "invalid outline; FIELD 1 is not numeric\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( tmp != loopidx )
+        {
+            // index change
+
+            if( tmp < 0 )
+            {
+                ERROR << "invalid outline; FIELD 1 is invalid\n";
+                std::cerr << "    LINE: " << iline << "\n";
+                return false;
+            }
+
+            if( loopidx == -1 )
+            {
+                // first outline
+                if( single )
+                {
+                    // outline may have a Loop Index of 0 or 1
+                    if( tmp == 0 || tmp == 1 )
+                    {
+                        op = new IDF_OUTLINE;
+                        if( op == NULL )
+                        {
+                            ERROR << "memory allocation failed\n";
+                            return false;
+                        }
+                        outlines.push_back( op );
+                        loopidx = tmp;
+                    }
+                    else
+                    {
+                        ERROR << "invalid outline; FIELD 1 is invalid (must be 0 or 1)\n";
+                        std::cerr << "    LINE: " << iline << "\n";
+                        return false;
+                    }
+                }
+                else
+                {
+                    // outline *MUST* have a Loop Index of 0
+                    if( tmp != 0 )
+                    {
+                        ERROR << "invalid outline; first outline of a BOARD or PANEL must have a Loop Index of 0\n";
+                        std::cerr << "    LINE: " << iline << "\n";
+                        return false;
+                    }
+
+                    op = new IDF_OUTLINE;
+
+                    if( op == NULL )
+                    {
+                        ERROR << "memory allocation failed\n";
+                        return false;
+                    }
+
+                    outlines.push_back( op );
+                    loopidx = tmp;
+                }
+                // end of block for first outline
+            }
+            else
+            {
+                // outline for cutout
+                if( single )
+                {
+                    ERROR << "invalid outline; a simple outline type may only have one outline\n";
+                    std::cerr << "    LINE: " << iline << "\n";
+                    return false;
+                }
+
+                if( tmp - loopidx != 1 )
+                {
+                    ERROR << "invalid outline; cutouts must be numbered in order from 1 onwards\n";
+                    std::cerr << "    LINE: " << iline << "\n";
+                    return false;
+                }
+
+                // verify winding of previous outline
+                if( ( loopidx = 0 && !op->IsCCW() )
+                    || ( loopidx > 0 && op->IsCCW() ) )
+                {
+                    ERROR << "invalid outline (violation of loop point order rules by Loop Index "
+                    << loopidx << ")\n";
+                    return false;
+                }
+
+                op = new IDF_OUTLINE;
+
+                if( op == NULL )
+                {
+                    ERROR << "memory allocation failed\n";
+                    return false;
+                }
+
+                outlines.push_back( op );
+                loopidx = tmp;
+            }
+            // end of index change code
+            npts = 0;
+            closed = false;
+        }
+
+        if( op == NULL )
+        {
+            ERROR << "invalid outline; FIELD 1 is invalid\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, entry, quoted, idx ) )
+        {
+            ERROR << "invalid RECORD 3, FIELD 2 does not exist\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR << "invalid RECORD 3, FIELD 2 is quoted\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        tstr.clear();
+        tstr << entry;
+
+        tstr >> x;
+        if( tstr.fail() )
+        {
+            ERROR << "invalid RECORD 3, invalid X value in FIELD 2\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, entry, quoted, idx ) )
+        {
+            ERROR << "invalid RECORD 3, FIELD 3 does not exist\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR << "invalid RECORD 3, FIELD 3 is quoted\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        tstr.clear();
+        tstr << entry;
+
+        tstr >> y;
+        if( tstr.fail() )
+        {
+            ERROR << "invalid RECORD 3, invalid Y value in FIELD 3\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, entry, quoted, idx ) )
+        {
+            ERROR << "invalid RECORD 3, FIELD 4 does not exist\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR << "invalid RECORD 3, FIELD 4 is quoted\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        tstr.clear();
+        tstr << entry;
+
+        tstr >> ang;
+        if( tstr.fail() )
+        {
+            ERROR << "invalid ANGLE value in FIELD 3\n";
+            std::cerr << "    LINE: " << iline << "\n";
+            return false;
+        }
+
+        // the line was successfully read; convert to mm if necessary
+        if( unit == UNIT_THOU )
+        {
+            x *= 0.0254;
+            y *= 0.0254;
+        }
+
+        if( npts++ == 0 )
+        {
+            // first point
+            prePt.x = x;
+            prePt.y = y;
+
+            // ensure that the first point is not an arc specification
+            if( ang < -MIN_ANG || ang > MIN_ANG )
+            {
+                ERROR << "invalid RECORD 3, first point has non-zero angle\n";
+                std::cerr << "    LINE: " << iline << "\n";
+                return false;
+            }
+        }
+        else
+        {
+            // Nth point
+            if( closed )
+            {
+                ERROR << "invalid RECORD 3; adding a segment to a closed outline\n";
+                std::cerr << "    LINE: " << iline << "\n";
+                return false;
+            }
+
+            curPt.x = x;
+            curPt.y = y;
+
+            if( ang > -MIN_ANG && ang < MIN_ANG )
+            {
+                sp = new IDF_SEGMENT( prePt, curPt );
+            }
+            else
+            {
+                sp = new IDF_SEGMENT( prePt, curPt, ang, false );
+            }
+
+            if( sp == NULL )
+            {
+                ERROR << "memory allocation failure\n";
+                return false;
+            }
+
+            if( sp->IsCircle() )
+            {
+                // this is  a circle; the loop is closed
+                if( op->size() != 0 )
+                {
+                    ERROR << "invalid RECORD 3; adding a circle to a non-empty outline\n";
+                    std::cerr << "    LINE: " << iline << "\n";
+                    delete sp;
+                    return false;
+                }
+
+                closed = true;
+            }
+            else if( op->size() != 0 )
+            {
+                if( curPt.Matches( op->front()->startPoint, dLoc ) )
+                    closed = true;
+            }
+
+            op->push( sp );
+            prePt.x = x;
+            prePt.y = y;
+        }
+    }   //  while( aBoardFile.good() )
+
+    // NOTE:
+    // 1. ideally we would ensure that there are no arcs with a radius of 0; this entails
+    //    actively calculating the last point as the previous entry could have been an instruction
+
+    return false;
+}
+
+bool BOARD_OUTLINE::writeComments( std::ofstream& aBoardFile )
+{
+    if( comments.empty() )
+        return true;
+
+    list< string >::const_iterator itS = comments.begin();
+    list< string >::const_iterator itE = comments.end();
+
+    while( itS != itE )
+    {
+        aBoardFile << "#" << *itS << "\n";
+        ++itS;
+    }
+
+    return !aBoardFile.fail();
+}
+
+bool BOARD_OUTLINE::writeOwner( std::ofstream& aBoardFile )
+{
+    switch( owner )
+    {
+        case ECAD:
+            aBoardFile << "ECAD\n";
+            break;
+
+        case MCAD:
+            aBoardFile << "MCAD\n";
+            break;
+
+        default:
+            aBoardFile << "UNOWNED\n";
+            break;
+    }
+
+    return !aBoardFile.fail();
+}
+
+bool BOARD_OUTLINE::writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex )
+{
+    // TODO: check the stream integrity
+
+    std::list<IDF_SEGMENT*>::iterator bo;
+    std::list<IDF_SEGMENT*>::iterator eo;
+
+    if( aOutline->size() == 1 )
+    {
+        if( !aOutline->front()->IsCircle() )
+        {
+            // this is a bad outline
+            ERROR << "bad outline (single segment item, not circle)\n";
+            return false;
+        }
+
+        if( single )
+            aIndex = 0;
+
+        // NOTE: a circle always has an angle of 360, never -360,
+        // otherwise SolidWorks chokes on the file.
+        if( unit == UNIT_MM )
+        {
+            aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+            << aOutline->front()->startPoint.x << " "
+            << aOutline->front()->startPoint.y << " 0\n";
+
+            aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+            << aOutline->front()->endPoint.x << " "
+            << aOutline->front()->endPoint.y << " 360\n";
+        }
+        else
+        {
+            aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+            << (aOutline->front()->startPoint.x / 0.0254) << " "
+            << (aOutline->front()->startPoint.y / 0.0254) << " 0\n";
+
+            aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+            << (aOutline->front()->endPoint.x / 0.0254) << " "
+            << (aOutline->front()->endPoint.y / 0.0254) << " 360\n";
+        }
+
+        return !aBoardFile.fail();
+    }
+
+    // ensure that the very last point is the same as the very first point
+    aOutline->back()-> endPoint = aOutline->front()->startPoint;
+
+    if( single )
+    {
+        // only indices 0 (CCW) and 1 (CW) are valid; set the index according to
+        // the outline's winding
+        if( aOutline->IsCCW() )
+            aIndex = 0;
+        else
+            aIndex = 1;
+    }
+
+    // check if we must reverse things
+    if( ( aOutline->IsCCW() && ( aIndex > 0 ) )
+        || ( ( !aOutline->IsCCW() ) && ( aIndex == 0 ) ) )
+    {
+        eo  = aOutline->begin();
+        bo  = aOutline->end();
+        --bo;
+
+        // for the first item we write out both points
+        if( unit == UNIT_MM )
+        {
+            if( aOutline->front()->angle < MIN_ANG && aOutline->front()->angle > -MIN_ANG )
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << aOutline->front()->endPoint.x << " "
+                << aOutline->front()->endPoint.y << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << aOutline->front()->startPoint.x << " "
+                << aOutline->front()->startPoint.y << " 0\n";
+            }
+            else
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << aOutline->front()->endPoint.x << " "
+                << aOutline->front()->endPoint.y << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << aOutline->front()->startPoint.x << " "
+                << aOutline->front()->startPoint.y << " "
+                << setprecision(5) << -aOutline->front()->angle << "\n";
+            }
+        }
+        else
+        {
+            if( aOutline->front()->angle < MIN_ANG && aOutline->front()->angle > -MIN_ANG )
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << (aOutline->front()->endPoint.x / 0.0254) << " "
+                << (aOutline->front()->endPoint.y / 0.0254) << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << (aOutline->front()->startPoint.x / 0.0254) << " "
+                << (aOutline->front()->startPoint.y / 0.0254) << " 0\n";
+            }
+            else
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << (aOutline->front()->endPoint.x / 0.0254) << " "
+                << (aOutline->front()->endPoint.y / 0.0254) << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << (aOutline->front()->startPoint.x / 0.0254) << " "
+                << (aOutline->front()->startPoint.y / 0.0254) << " "
+                << setprecision(5) << -aOutline->front()->angle << "\n";
+            }
+        }
+
+        // for all other segments we only write out the start point
+        while( bo != eo )
+        {
+            if( unit == UNIT_MM )
+            {
+                if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                    << (*bo)->startPoint.x << " "
+                    << (*bo)->startPoint.y << " 0\n";
+                }
+                else
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                    << (*bo)->startPoint.x << " "
+                    << (*bo)->startPoint.y << " "
+                    << setprecision(5) << -(*bo)->angle << "\n";
+                }
+            }
+            else
+            {
+                if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                    << ((*bo)->startPoint.x / 0.0254) << " "
+                    << ((*bo)->startPoint.y / 0.0254) << " 0\n";
+                }
+                else
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                    << ((*bo)->startPoint.x / 0.0254) << " "
+                    << ((*bo)->startPoint.y / 0.0254) << " "
+                    << setprecision(5) << -(*bo)->angle << "\n";
+                }
+            }
+
+            --bo;
+        }
+    }
+    else
+    {
+        bo  = aOutline->begin();
+        eo  = aOutline->end();
+
+        // for the first item we write out both points
+        if( unit == UNIT_MM )
+        {
+            if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << (*bo)->startPoint.x << " "
+                << (*bo)->startPoint.y << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << (*bo)->endPoint.x << " "
+                << (*bo)->endPoint.y << " 0\n";
+            }
+            else
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << (*bo)->startPoint.x << " "
+                << (*bo)->startPoint.y << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                << (*bo)->endPoint.x << " "
+                << (*bo)->endPoint.y << " "
+                << setprecision(5) << (*bo)->angle << "\n";
+            }
+        }
+        else
+        {
+            if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << ((*bo)->startPoint.x / 0.0254) << " "
+                << ((*bo)->startPoint.y / 0.0254) << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << ((*bo)->endPoint.x / 0.0254) << " "
+                << ((*bo)->endPoint.y / 0.0254) << " 0\n";
+            }
+            else
+            {
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << ((*bo)->startPoint.x / 0.0254) << " "
+                << ((*bo)->startPoint.y / 0.0254) << " 0\n";
+
+                aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                << ((*bo)->endPoint.x / 0.0254) << " "
+                << ((*bo)->endPoint.y / 0.0254) << " "
+                << setprecision(5) << (*bo)->angle << "\n";
+            }
+        }
+
+        ++bo;
+
+        // for all other segments we only write out the last point
+        while( bo != eo )
+        {
+            if( unit == UNIT_MM )
+            {
+                if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                    << (*bo)->endPoint.x << " "
+                    << (*bo)->endPoint.y << " 0\n";
+                }
+                else
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(5)
+                    << (*bo)->endPoint.x << " "
+                    << (*bo)->endPoint.y << " "
+                    << setprecision(5) << (*bo)->angle << "\n";
+                }
+            }
+            else
+            {
+                if( (*bo)->angle < MIN_ANG && (*bo)->angle > -MIN_ANG )
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                    << ((*bo)->endPoint.x / 0.0254) << " "
+                    << ((*bo)->endPoint.y / 0.0254) << " 0\n";
+                }
+                else
+                {
+                    aBoardFile << aIndex << " " << setiosflags(ios::fixed) << setprecision(1)
+                    << ((*bo)->endPoint.x / 0.0254) << " "
+                    << ((*bo)->endPoint.y / 0.0254) << " "
+                    << setprecision(5) << (*bo)->angle << "\n";
+                }
+            }
+
+            ++bo;
+        }
+    }
+
+    return !aBoardFile.fail();
+}
+
+bool BOARD_OUTLINE::writeOutlines( std::ofstream& aBoardFile )
+{
+    if( outlines.empty() )
+        return true;
+
+    int idx = 0;
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    while( itS != itE )
+    {
+        if( !writeOutline( aBoardFile, *itS, idx++ ) )
+            return false;
+
+        ++itS;
+    }
+
+    return true;
+}
+
+void BOARD_OUTLINE::SetUnit( IDF3::IDF_UNIT aUnit )
+{
+    unit = aUnit;
+    return;
+}
+
+IDF3::IDF_UNIT BOARD_OUTLINE::GetUnit( void )
+{
+    return unit;
+}
+
+bool BOARD_OUTLINE::SetThickness( double aThickness )
+{
+    if( aThickness < 0.0 )
+        return false;
+
+    thickness = aThickness;
+    return true;
+}
+
+double BOARD_OUTLINE::GetThickness( void )
+{
+    return thickness;
+}
+
+bool BOARD_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+{
+    //  BOARD_OUTLINE (PANEL_OUTLINE)
+    //      .BOARD_OUTLINE  [OWNER]
+    //      [thickness]
+    //      [outlines]
+
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( !CompareToken( ".BOARD_OUTLINE", token ) )
+    {
+        ERROR << "not a board outline:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "no OWNER; setting to UNOWNED\n";
+        owner = UNOWNED;
+    }
+    else
+    {
+        if( !ParseOwner( token, owner ) )
+        {
+            ERROR << "invalid OWNER (reverting to UNOWNED): " << token << "\n";
+            owner = UNOWNED;
+        }
+    }
+
+    // check RECORD 2
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .BOARD_OUTLINE section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .BOARD_OUTLINE section (no thickness)\n";
+        return false;
+    }
+
+    std::stringstream teststr;
+    teststr << token;
+
+    teststr >> thickness;
+    if( teststr.fail() )
+    {
+        ERROR << "bad .BOARD_OUTLINE section (invalid RECORD 2)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( unit == UNIT_THOU )
+        thickness *= 0.0254;
+
+    // read RECORD 3 values
+    readOutlines( aBoardFile );
+
+    // check RECORD 4
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .BOARD_OUTLINE section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx )
+        || !CompareToken( ".END_BOARD_OUTLINE", token ) )
+    {
+        ERROR << "bad .BOARD_OUTLINE section (no .END_BOARD_OUTLINE)\n";
+        return false;
+    }
+
+    return true;
+}
+
+bool BOARD_OUTLINE::WriteData( std::ofstream& aBoardFile )
+{
+    writeComments( aBoardFile );
+
+    // note: a BOARD_OUTLINE section is required, even if it is empty
+    aBoardFile << ".BOARD_OUTLINE ";
+
+    writeOwner( aBoardFile );
+
+    if( unit == UNIT_MM )
+        aBoardFile << setiosflags(ios::fixed) << setprecision(5) << thickness << "\n";
+    else
+        aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (thickness / 0.025) << "\n";
+
+    if( !writeOutlines( aBoardFile ) )
+        return false;
+
+    aBoardFile << ".END_BOARD_OUTLINE\n\n";
+
+    return !aBoardFile.fail();
+}
+
+void BOARD_OUTLINE::Clear( void )
+{
+    comments.clear();
+    ClearOutlines();
+
+    owner = UNOWNED;
+    return;
+}
+
+void BOARD_OUTLINE::SetParent( IDF3_BOARD* aParent )
+{
+    parent = aParent;
+}
+
+IDF3_BOARD* BOARD_OUTLINE::GetParent( void )
+{
+    return parent;
+}
+
+bool BOARD_OUTLINE::AddOutline( IDF_OUTLINE* aOutline )
+{
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    while( itS != itE )
+    {
+        if( *itS == aOutline )
+            return false;
+
+        ++itS;
+    }
+
+    outlines.push_back( aOutline );
+    return true;
+}
+
+bool BOARD_OUTLINE::DelOutline( IDF_OUTLINE* aOutline )
+{
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    if( outlines.empty() )
+        return false;
+
+    // if there are more than 1 outlines it makes no sense to delete
+    // the first outline (board outline) since that would have the
+    // undesirable effect of substituting a cutout outline as the board outline
+    if( aOutline == outlines.front() )
+    {
+        if( outlines.size() > 1 )
+            return false;
+
+        outlines.clear();
+        return true;
+    }
+
+    while( itS != itE )
+    {
+        if( *itS == aOutline )
+        {
+            outlines.erase( itS );
+            return true;
+        }
+
+        ++itS;
+    }
+
+    return false;
+}
+
+bool BOARD_OUTLINE::DelOutline( size_t aIndex )
+{
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    if( outlines.empty() )
+        return false;
+
+    if( aIndex >= outlines.size() )
+        return false;
+
+    if( aIndex == 0 )
+    {
+        // if there are more than 1 outlines it makes no sense to delete
+        // the first outline (board outline) since that would have the
+        // undesirable effect of substituting a cutout outline as the board outline
+        if( outlines.size() > 1 )
+            return false;
+
+        delete *itS;
+        outlines.clear();
+
+        return true;
+    }
+
+    for( ; aIndex > 0; --aIndex )
+        ++itS;
+
+    delete *itS;
+    outlines.erase( itS );
+
+    return true;
+}
+
+std::list< IDF_OUTLINE* >& BOARD_OUTLINE::GetOutlines( void )
+{
+    return outlines;
+}
+
+size_t BOARD_OUTLINE::OutlinesSize( void )
+{
+    return outlines.size();
+}
+
+IDF_OUTLINE* BOARD_OUTLINE::GetOutline( size_t aIndex )
+{
+    if( aIndex >= outlines.size() )
+        return NULL;
+
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+
+    for( ; aIndex > 0; --aIndex )
+        ++itS;
+
+    return *itS;
+}
+
+IDF3::KEY_OWNER BOARD_OUTLINE::GetOwner( void )
+{
+    return owner;
+}
+
+bool BOARD_OUTLINE::SetOwner( IDF3::KEY_OWNER aOwner )
+{
+    // if no one owns the outline, any system may
+    // set the owner
+    if( owner == UNOWNED )
+    {
+        owner = aOwner;
+        return true;
+    }
+
+    // if the outline is owned, only the owning
+    // CAD system can make alterations
+    if( parent == NULL )
+        return false;
+
+    if( owner == MCAD && parent->GetCadType() == CAD_MECH )
+    {
+        owner = aOwner;
+        return true;
+    }
+
+    if( owner == ECAD && parent->GetCadType() == CAD_ELEC )
+    {
+        owner = aOwner;
+        return true;
+    }
+
+    return false;
+}
+
+bool BOARD_OUTLINE::IsSingle( void )
+{
+    return single;
+}
+
+void BOARD_OUTLINE::ClearOutlines( void )
+{
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    while( itS != itE )
+    {
+        delete *itS;
+        ++itS;
+    }
+
+    outlines.clear();
+    return;
+}
+
+void BOARD_OUTLINE::AddComment( const std::string& aComment )
+{
+    if( aComment.empty() )
+        return;
+
+    comments.push_back( aComment );
+    return;
+}
+
+size_t BOARD_OUTLINE::CommentsSize( void )
+{
+    return comments.size();
+}
+
+const std::list< std::string >& BOARD_OUTLINE::GetComments( void )
+{
+    return comments;
+}
+
+const std::string *const BOARD_OUTLINE::GetComment( size_t aIndex )
+{
+    if( aIndex >= comments.size() )
+        return NULL;
+
+    std::list< std::string >::iterator itS = comments.begin();
+
+    for( ; aIndex > 0; --aIndex )
+        ++itS;
+
+    return &(*itS);
+}
+
+bool  BOARD_OUTLINE::DeleteComment( size_t aIndex )
+{
+    if( aIndex >= comments.size() )
+        return false;
+
+    std::list< std::string >::iterator itS = comments.begin();
+
+    for( ; aIndex > 0; --aIndex )
+        ++itS;
+
+    comments.erase( itS );
+    return true;
+}
+
+void  BOARD_OUTLINE::ClearComments( void )
+{
+    comments.clear();
+    return;
+}
+
+
+/*
+ * CLASS: OTHER_OUTLINE
+ */
+OTHER_OUTLINE::OTHER_OUTLINE()
+{
+    outlineType = OTLN_OTHER;
+    side = LYR_INVALID;
+    single = true;
+
+    return;
+}
+
+void OTHER_OUTLINE::SetOutlineIdentifier( const std::string aUniqueID )
+{
+    uniqueID = aUniqueID;
+    return;
+}
+
+const std::string& OTHER_OUTLINE::GetOutlineIdentifier( void )
+{
+    return uniqueID;
+}
+
+bool OTHER_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
+{
+    switch( aSide )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+            side = aSide;
+            break;
+
+        default:
+            ERROR << "invalid side (" << aSide << "); must be one of TOP/BOTTOM\n";
+            side = LYR_INVALID;
+            return false;
+            break;
+    }
+
+    return true;
+}
+
+IDF3::IDF_LAYER OTHER_OUTLINE::GetSide( void )
+{
+    return side;
+}
+
+bool OTHER_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+{
+    // OTHER_OUTLINE/VIA_KEEPOUT
+    //     .OTHER_OUTLINE  [OWNER]
+    //     [outline identifier] [thickness] [board side: Top/Bot] {not present in VA\IA KEEPOUT}
+    //     [outline]
+
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_OTHER )
+    {
+        if( !CompareToken( ".OTHER_OUTLINE", token ) )
+        {
+            ERROR << "not an OTHER outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !CompareToken( ".VIA_KEEPOUT", token ) )
+        {
+            ERROR << "not a VIA_KEEPOUT outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "no OWNER; setting to UNOWNED\n";
+        owner = UNOWNED;
+    }
+    else
+    {
+        if( !ParseOwner( token, owner ) )
+        {
+            ERROR << "invalid OWNER (reverting to UNOWNED): " << token << "\n";
+            owner = UNOWNED;
+        }
+    }
+
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    if( outlineType == OTLN_OTHER )
+    {
+        // check RECORD 2
+        // [outline identifier] [thickness] [board side: Top/Bot]
+        while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+        idx = 0;
+        if( comment )
+        {
+            ERROR << "comment within .OTHER_OUTLINE section\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (no outline identifier)\n";
+            return false;
+        }
+
+        uniqueID = token;
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (no thickness)\n";
+            return false;
+        }
+
+        std::stringstream teststr;
+        teststr << token;
+
+        teststr >> thickness;
+        if( teststr.fail() )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (invalid RECORD 2 reading thickness)\n";
+            std::cerr << "\tLINE: " << iline << "\n";
+            return false;
+        }
+
+        if( unit == UNIT_THOU )
+            thickness *= 0.0254;
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (no board side)\n";
+            return false;
+        }
+
+        if( !ParseIDFLayer( token, side ) || ( side != LYR_TOP && side != LYR_BOTTOM ) )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (invalid side, must be TOP/BOTTOM only)\n";
+            std::cerr << "\tLINE: " << iline << "\n";
+            return false;
+        }
+    }
+
+    // read RECORD 3 values
+    readOutlines( aBoardFile );
+
+    // check RECORD 4
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .OTHER_OUTLINE/.VIA_KEEPOUT section\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_OTHER )
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_OTHER_OUTLINE", token ) )
+        {
+            ERROR << "bad .OTHER_OUTLINE section (no .END_OTHER_OUTLINE)\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_VIA_KEEPOUT", token ) )
+        {
+            ERROR << "bad .VIA_KEEPOUT section (no .END_VIA_KEEPOUT)\n";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool OTHER_OUTLINE::WriteData( std::ofstream& aBoardFile )
+{
+    // this section is optional; do not write if not required
+    if( outlines.empty() )
+        return true;
+
+    writeComments( aBoardFile );
+
+    // write RECORD 1
+    if( outlineType == OTLN_OTHER )
+        aBoardFile << ".OTHER_OUTLINE ";
+    else
+        aBoardFile << ".VIA_KEEPOUT ";
+
+    writeOwner( aBoardFile );
+
+    // write RECORD 2
+    if( outlineType == OTLN_OTHER )
+    {
+        aBoardFile << "\"" << uniqueID << "\" ";
+
+        if( unit == UNIT_MM )
+            aBoardFile << setiosflags(ios::fixed) << setprecision(5) << thickness << " ";
+        else
+            aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (thickness / 0.0254) << " ";
+
+        switch( side )
+        {
+            case LYR_TOP:
+            case LYR_BOTTOM:
+                WriteLayersText( aBoardFile, side );
+                break;
+
+            default:
+                ERROR << "Invalid OTHER_OUTLINE side (neither top nor bottom): " << side << "\n";
+                return false;
+                break;
+        }
+    }
+
+    // write RECORD 3
+    if( !writeOutlines( aBoardFile ) )
+        return false;
+
+    // write RECORD 4
+    if( outlineType == OTLN_OTHER )
+        aBoardFile << ".END_OTHER_OUTLINE\n\n";
+    else
+        aBoardFile << ".END_VIA_KEEPOUT\n\n";
+
+    return !aBoardFile.fail();
+}
+
+void OTHER_OUTLINE::Clear( void )
+{
+    side = LYR_INVALID;
+    uniqueID.clear();
+
+    BOARD_OUTLINE::Clear();
+
+    return;
+}
+
+
+/*
+ * CLASS: ROUTE_OUTLINE
+ */
+ROUTE_OUTLINE::ROUTE_OUTLINE()
+{
+    outlineType = OTLN_ROUTE;
+    single = true;
+    layers = LYR_INVALID;
+}
+
+void ROUTE_OUTLINE::SetLayers( IDF3::IDF_LAYER aLayer )
+{
+    layers = aLayer;
+}
+
+IDF3::IDF_LAYER ROUTE_OUTLINE::GetLayers( void )
+{
+    return layers;
+}
+
+bool ROUTE_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+{
+    //  ROUTE_OUTLINE (or ROUTE_KEEPOUT)
+    //      .ROUTE_OUTLINE [OWNER]
+    //      [layers]
+    //      [outline]
+
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_ROUTE )
+    {
+        if( !CompareToken( ".ROUTE_OUTLINE", token ) )
+        {
+            ERROR << "not a ROUTE outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !CompareToken( ".ROUTE_KEEPOUT", token ) )
+        {
+            ERROR << "not a ROUTE KEEPOUT outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "no OWNER; setting to UNOWNED\n";
+        owner = UNOWNED;
+    }
+    else
+    {
+        if( !ParseOwner( token, owner ) )
+        {
+            ERROR << "invalid OWNER (reverting to UNOWNED): " << token << "\n";
+            owner = UNOWNED;
+        }
+    }
+
+    // check RECORD 2
+    // [layers: TOP, BOTTOM, BOTH, INNER, ALL]
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .ROUTE_OUTLINE/KEEPOUT section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .ROUTE_OUTLINE/KEEPOUT section (no layers specification)\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "bad .ROUTE_OUTLINE/KEEPOUT section (layers may not be quoted)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( !ParseIDFLayer( token, layers ) )
+    {
+        ERROR << "bad .ROUTE_OUTLINE/KEEPOUT section (invalid layer)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    // read RECORD 3 values
+    readOutlines( aBoardFile );
+
+    // check RECORD 4
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .ROUTE_OUTLINE/KEEPOUT section\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_ROUTE )
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_ROUTE_OUTLINE", token ) )
+        {
+            ERROR << "bad .ROUTE_OUTLINE section (no .END_ROUTE_OUTLINE)\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_ROUTE_KEEPOUT", token ) )
+        {
+            ERROR << "bad .ROUTE_KEEPOUT section (no .END_ROUTE_KEEPOUT)\n";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+
+bool ROUTE_OUTLINE::WriteData( std::ofstream& aBoardFile )
+{
+    // this section is optional; do not write if not required
+    if( outlines.empty() )
+        return true;
+
+    if( layers == LYR_INVALID )
+    {
+        ERROR << "layer not specified\n";
+        return false;
+    }
+
+    writeComments( aBoardFile );
+
+    // write RECORD 1
+    if( outlineType == OTLN_ROUTE )
+        aBoardFile << ".ROUTE_OUTLINE ";
+    else
+        aBoardFile << ".ROUTE_KEEPOUT ";
+
+    writeOwner( aBoardFile );
+
+    // write RECORD 2
+    WriteLayersText( aBoardFile, layers );
+    aBoardFile << "\n";
+
+    // write RECORD 3
+    if( !writeOutlines( aBoardFile ) )
+        return false;
+
+    // write RECORD 4
+    if( outlineType == OTLN_ROUTE )
+        aBoardFile << ".END_ROUTE_OUTLINE\n\n";
+    else
+        aBoardFile << ".END_ROUTE_KEEPOUT\n\n";
+
+    return !aBoardFile.fail();
+}
+
+
+void ROUTE_OUTLINE::Clear( void )
+{
+    BOARD_OUTLINE::Clear();
+    layers = LYR_INVALID;
+    return;
+}
+
+
+/*
+ * CLASS: PLACEME_OUTLINE
+ */
+PLACE_OUTLINE::PLACE_OUTLINE()
+{
+    outlineType = OTLN_PLACE;
+    single = true;
+    thickness = 0.0;
+    side = LYR_INVALID;
+}
+
+bool PLACE_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
+{
+    switch( aSide )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+        case LYR_BOTH:
+            side = aSide;
+            break;
+
+        default:
+            ERROR << "invalid layer (" << aSide << "): must be one of TOP/BOTTOM/BOTH\n";
+            side = LYR_INVALID;
+            return false;
+            break;
+    }
+
+    return true;
+}
+
+IDF3::IDF_LAYER PLACE_OUTLINE::GetSide( void )
+{
+    return side;
+}
+
+void PLACE_OUTLINE::SetMaxHeight( double aHeight )
+{
+    if( aHeight < 0.0 )
+    {
+        ERROR << "invalid height (must be >= 0.0); default to 0\n";
+        thickness = 0.0;
+        return;
+    }
+
+    thickness = aHeight;
+    return;
+}
+
+double PLACE_OUTLINE::GetMaxHeight( void )
+{
+    return thickness;
+}
+
+bool PLACE_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+{
+    //  PLACE_OUTLINE/KEEPOUT
+    //      .PLACE_OUTLINE [OWNER]
+    //      [board side: Top/Bot/Both] [height]
+    //      [outline]
+
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_PLACE )
+    {
+        if( !CompareToken( ".PLACE_OUTLINE", token ) )
+        {
+            ERROR << "not a PLACE outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !CompareToken( ".PLACE_KEEPOUT", token ) )
+        {
+            ERROR << "not a PLACE_KEEPOUT outline:\n";
+            std::cerr << "\tLINE: " << aHeader << "\n";
+            return false;
+        }
+    }
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "no OWNER; setting to UNOWNED\n";
+        owner = UNOWNED;
+    }
+    else
+    {
+        if( !ParseOwner( token, owner ) )
+        {
+            ERROR << "invalid OWNER (reverting to UNOWNED): " << token << "\n";
+            owner = UNOWNED;
+        }
+    }
+
+    // check RECORD 2
+    // [board side: Top/Bot/Both] [height]
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .PLACE_OUTLINE/KEEPOUT section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .PLACE_OUTLINE/KEEPOUT section (no board side information)\n";
+        return false;
+    }
+
+    if( !ParseIDFLayer( token, side ) ||
+        ( side != LYR_TOP && side != LYR_BOTTOM && side != LYR_BOTH ) )
+    {
+        ERROR << "bad .PLACE_OUTLINE/KEEPOUT section (invalid side, must be one of TOP/BOTTOM/BOTH)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .PLACE_OUTLINE/KEEPOUT section (no height)\n";
+        return false;
+    }
+
+    std::stringstream teststr;
+    teststr << token;
+
+    teststr >> thickness;
+    if( teststr.fail() )
+    {
+        ERROR << "bad .PLACE_OUTLINE/KEEPOUT section (invalid RECORD 2 reading height)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( unit == UNIT_THOU )
+        thickness *= 0.0254;
+
+    // read RECORD 3 values
+    readOutlines( aBoardFile );
+
+    // check RECORD 4
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .PLACE_OUTLINE/KEEPOUT section\n";
+        return false;
+    }
+
+    if( outlineType == OTLN_PLACE )
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_PLACE_OUTLINE", token ) )
+        {
+            ERROR << "bad .PLACE_OUTLINE section (no .END_PLACE_OUTLINE)\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_PLACE_KEEPOUT", token ) )
+        {
+            ERROR << "bad .PLACE_KEEPOUT section (no .END_PLACE_KEEPOUT)\n";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool PLACE_OUTLINE::WriteData( std::ofstream& aBoardFile )
+{
+    // this section is optional; do not write if not required
+    if( outlines.empty() )
+        return true;
+
+    writeComments( aBoardFile );
+
+    // write RECORD 1
+    if( outlineType == OTLN_PLACE )
+        aBoardFile << ".PLACE_OUTLINE ";
+    else
+        aBoardFile << ".PLACE_KEEPOUT ";
+
+    writeOwner( aBoardFile );
+
+    // write RECORD 2
+    switch( side )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+        case LYR_BOTH:
+            WriteLayersText( aBoardFile, side );
+            break;
+
+        default:
+            ERROR << "Invalid PLACE_OUTLINE/KEEPOUT side (" << side << "); must be one of TOP/BOTTOM/BOTH\n";
+            return false;
+            break;
+    }
+
+    aBoardFile << " ";
+
+    if( unit == UNIT_MM )
+        aBoardFile << setiosflags(ios::fixed) << setprecision(5) << thickness << "\n";
+    else
+        aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (thickness / 0.0254) << "\n";
+
+    // write RECORD 3
+    if( !writeOutlines( aBoardFile ) )
+        return false;
+
+    // write RECORD 4
+    if( outlineType == OTLN_PLACE )
+        aBoardFile << ".END_PLACE_OUTLINE\n\n";
+    else
+        aBoardFile << ".END_PLACE_KEEPOUT\n\n";
+
+    return !aBoardFile.fail();
+}
+
+void PLACE_OUTLINE::Clear( void )
+{
+    BOARD_OUTLINE::Clear();
+    thickness = 0.0;
+    side = LYR_INVALID;
+    return;
+}
+
+
+/*
+ * CLASS: ROUTE_KEEPOUT
+ */
+ROUTE_KO_OUTLINE::ROUTE_KO_OUTLINE()
+{
+    outlineType = OTLN_ROUTE_KEEPOUT;
+    return;
+}
+
+
+/*
+ * CLASS: PLACE_KEEPOUT
+ */
+PLACE_KO_OUTLINE::PLACE_KO_OUTLINE()
+{
+    outlineType = OTLN_PLACE_KEEPOUT;
+    return;
+}
+
+
+/*
+ * CLASS: VIA_KEEPOUT
+ */
+VIA_KO_OUTLINE::VIA_KO_OUTLINE()
+{
+    outlineType = OTLN_VIA_KEEPOUT;
+}
+
+
+/*
+ * CLASS: PLACEMENT GROUP (PLACE_REGION)
+ */
+GROUP_OUTLINE::GROUP_OUTLINE()
+{
+    outlineType = OTLN_GROUP_PLACE;
+    thickness = 0.0;
+    side = LYR_INVALID;
+    single = true;
+    return;
+}
+
+bool GROUP_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
+{
+    switch( aSide )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+        case LYR_BOTH:
+            side = aSide;
+            break;
+
+        default:
+            ERROR << "invalid side (" << aSide << "); must be one of TOP/BOTTOM/BOTH\n";
+            return false;
+            break;
+    }
+
+    return true;
+}
+
+IDF3::IDF_LAYER GROUP_OUTLINE::GetSide( void )
+{
+    return side;
+}
+
+void GROUP_OUTLINE::SetGroupName( std::string aGroupName )
+{
+    groupName = aGroupName;
+    return;
+}
+
+const std::string& GROUP_OUTLINE::GetGroupName( void )
+{
+    return groupName;
+}
+
+bool GROUP_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+{
+    //  Placement Group
+    //      .PLACE_REGION [OWNER]
+    //      [side: Top/Bot/Both ] [component group name]
+    //      [outline]
+
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( !CompareToken( ".PLACE_REGION", token ) )
+    {
+        ERROR << "not a PLACE_REGION outline:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "no OWNER; setting to UNOWNED\n";
+        owner = UNOWNED;
+    }
+    else
+    {
+        if( !ParseOwner( token, owner ) )
+        {
+            ERROR << "invalid OWNER (reverting to UNOWNED): " << token << "\n";
+            owner = UNOWNED;
+        }
+    }
+
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    // check RECORD 2
+    // [side: Top/Bot/Both ] [component group name]
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .PLACE_REGION section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .PLACE_REGION section (no board side)\n";
+        return false;
+    }
+
+    if( !ParseIDFLayer( token, side ) ||
+        ( side != LYR_TOP && side != LYR_BOTTOM && side != LYR_BOTH ) )
+    {
+        ERROR << "bad .PLACE_REGION section (invalid side, must be TOP/BOTTOM/BOTH)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad .PLACE_REGION section (no outline identifier)\n";
+        return false;
+    }
+
+    groupName = token;
+
+    // read RECORD 3 values
+    readOutlines( aBoardFile );
+
+    // check RECORD 4
+    while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within .PLACE_REGION section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx )
+        || !CompareToken( ".END_PLACE_REGION", token ) )
+    {
+        ERROR << "bad .PLACE_REGION section (no .END_PLACE_REGION)\n";
+        return false;
+    }
+
+    return true;
+}
+
+bool GROUP_OUTLINE::WriteData( std::ofstream& aBoardFile )
+{
+    // this section is optional; do not write if not required
+    if( outlines.empty() )
+        return true;
+
+    writeComments( aBoardFile );
+
+    // write RECORD 1
+    aBoardFile << ".PLACE_REGION ";
+
+    writeOwner( aBoardFile );
+
+    // write RECORD 2
+    switch( side )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+        case LYR_BOTH:
+            WriteLayersText( aBoardFile, side );
+            break;
+
+        default:
+            ERROR << "Invalid PLACE_REGION side (must be TOP/BOTTOM/BOTH): " << side << "\n";
+            return false;
+            break;
+    }
+
+    aBoardFile << " \"" << groupName << "\"\n";
+
+    // write RECORD 3
+    if( !writeOutlines( aBoardFile ) )
+        return false;
+
+    // write RECORD 4
+    aBoardFile << ".END_PLACE_REGION\n\n";
+
+    return !aBoardFile.fail();
+}
+
+void GROUP_OUTLINE::Clear( void )
+{
+    BOARD_OUTLINE::Clear();
+    thickness = 0.0;
+    side = LYR_INVALID;
+    groupName.clear();
+    return;
+}
+
+/*
+ * CLASS: COMPONENT OUTLINE
+ */
+IDF3_COMP_OUTLINE::IDF3_COMP_OUTLINE()
+{
+    single = true;
+    outlineType = OTLN_COMPONENT;
+    compType = COMP_INVALID;
+    refNum = 0;
+    return;
+}
+
+bool IDF3_COMP_OUTLINE::readProperties( std::ifstream& aLibFile )
+{
+    bool quoted = false;
+    bool comment = false;
+    std::string iline;
+    std::string token;
+    std::streampos pos;
+    std::string pname;      // property name
+    std::string pval;       // property value
+    int idx = 0;
+
+    while( aLibFile.good() )
+    {
+        if( !FetchIDFLine( aLibFile, iline, comment, pos ) )
+            continue;
+
+        idx = 0;
+        if( comment )
+        {
+            ERROR << "comment within component outline section\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad component outline section (no PROP)\n";
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR << "bad component outline section (PROP or .END may not be quoted)\n";
+            return false;
+        }
+
+        if( token.size() >= 5 && CompareToken( ".END_", token.substr( 0, 5 ) ) )
+        {
+            aLibFile.seekg( pos );
+            return true;
+        }
+
+        if( !CompareToken( "PROP", token ) )
+        {
+            ERROR << "invalid electrical outline; expecting PROP or .END_ELECTRICAL\n";
+            std::cerr << "\tLINE: " << iline << "\n";
+            return false;
+        }
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad component outline section (no prop name)\n";
+            return false;
+        }
+
+        pname = token;
+
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR << "bad component outline section (no prop value)\n";
+            return false;
+        }
+
+        pval = token;
+
+        if( props.insert( pair< string, string >(pname, pval) ).second == false )
+        {
+            ERROR << "bad component outline: duplicate property name '" << pname << "'\n";
+            return false;
+        }
+    }
+
+    return !aLibFile.fail();
+}
+
+bool IDF3_COMP_OUTLINE::writeProperties( std::ofstream& aLibFile )
+{
+    if( props.empty() )
+        return true;
+    std::map< std::string, std::string >::const_iterator itS = props.begin();
+    std::map< std::string, std::string >::const_iterator itE = props.end();
+
+    while( itS != itE )
+    {
+        aLibFile << "PROP " << "\"" << itS->first << "\" \""
+        << itS->second << "\"\n";
+        ++itS;
+    }
+
+    return !aLibFile.fail();
+}
+
+bool IDF3_COMP_OUTLINE::ReadData( std::ifstream& aLibFile, const std::string& aHeader )
+{
+    //  .ELECTRICAL/.MECHANICAL
+    //  [GEOM] [PART] [UNIT] [HEIGHT]
+    //  [outline]
+    //  [PROP] [prop name] [prop value]
+    // check RECORD 1
+    std::string token;
+    bool quoted = false;
+    int  idx = 0;
+
+    if( !GetIDFString( aHeader, token, quoted, idx ) )
+    {
+        ERROR << "invalid invocation; blank header line\n";
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR << "section names may not be quoted:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    if( CompareToken( ".ELECTRICAL", token ) )
+    {
+        compType = COMP_ELEC;
+    }
+    else if( CompareToken( ".MECHANICAL", token ) )
+    {
+        compType = COMP_MECH;
+    }
+    else
+    {
+        ERROR << "not a component outline:\n";
+        std::cerr << "\tLINE: " << aHeader << "\n";
+        return false;
+    }
+
+    // check RECORD 2
+    // [GEOM] [PART] [UNIT] [HEIGHT]
+    std::string iline;
+    bool comment = false;
+    std::streampos pos;
+
+    while( aLibFile.good() && !FetchIDFLine( aLibFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within a component outline section\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad component outline (no GEOMETRY NAME)\n";
+        return false;
+    }
+
+    geometry = token;
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad component outline (no PART NAME)\n";
+        return false;
+    }
+
+    part = token;
+
+    if( part.empty() && geometry.empty() )
+    {
+        ERROR << "bad component outline (both GEOMETRY and PART names are empty)\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad component outline (no unit type)\n";
+        return false;
+    }
+
+    if( CompareToken( "MM", token ) )
+    {
+        unit = UNIT_MM;
+    }
+    else if( CompareToken( "THOU", token ) )
+    {
+        unit = UNIT_THOU;
+    }
+    else
+    {
+        ERROR << "bad component outline (invalid unit type)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR << "bad component outline (no height)\n";
+        return false;
+    }
+
+    std::istringstream teststr;
+    teststr.str( token );
+
+    teststr >> thickness;
+    if( teststr.fail() )
+    {
+        ERROR << "bad component outline (invalid height)\n";
+        std::cerr << "\tLINE: " << iline << "\n";
+        return false;
+    }
+
+    if( unit == UNIT_THOU )
+        thickness *= 0.0254;
+
+    // read RECORD 3 values
+    readOutlines( aLibFile );
+
+    if( compType == COMP_ELEC )
+    {
+        if( !readProperties( aLibFile ) )
+            return false;
+    }
+
+    // check RECORD 4
+    while( aLibFile.good() && !FetchIDFLine( aLibFile, iline, comment, pos ) );
+
+    idx = 0;
+    if( comment )
+    {
+        ERROR << "comment within component outline section\n";
+        return false;
+    }
+
+    if( compType == COMP_ELEC )
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_ELECTRICAL", token ) )
+        {
+            ERROR << "bad component outline (no .END_ELECTRICAL)\n";
+            return false;
+        }
+    }
+    else
+    {
+        if( !GetIDFString( iline, token, quoted, idx )
+            || !CompareToken( ".END_MECHANICAL", token ) )
+        {
+            ERROR << "corrupt .MECHANICAL outline\n";
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool IDF3_COMP_OUTLINE::WriteData( std::ofstream& aLibFile )
+{
+    if( compType != COMP_ELEC && compType != COMP_MECH )
+    {
+        ERROR << "component type not set or invalid\n";
+        return false;
+    }
+
+    writeComments( aLibFile );
+
+    // note: the outline section is required, even if it is empty
+    if( compType == COMP_ELEC )
+        aLibFile << ".ELECTRICAL\n";
+    else
+        aLibFile << ".MECHANICAL\n";
+
+    // RECORD 2
+    // [GEOM] [PART] [UNIT] [HEIGHT]
+    aLibFile << "\"" << geometry << "\" \"" << part << "\" ";
+
+    if( unit == UNIT_MM )
+        aLibFile << "MM " << setiosflags(ios::fixed) << setprecision(5) << thickness << "\n";
+    else
+        aLibFile << "THOU " << setiosflags(ios::fixed) << setprecision(1) << (thickness / 0.0254) << "\n";
+
+    if( !writeOutlines( aLibFile ) )
+        return false;
+
+    if( compType == COMP_ELEC )
+    {
+        writeProperties( aLibFile );
+        aLibFile << ".END_ELECTRICAL\n\n";
+    }
+    else
+    {
+        aLibFile << ".END_MECHANICAL\n\n";
+    }
+
+    return !aLibFile.fail();
+}
+
+void IDF3_COMP_OUTLINE::Clear( void )
+{
+    BOARD_OUTLINE::Clear();
+    uid.clear();
+    geometry.clear();
+    part.clear();
+    compType = COMP_INVALID;
+    refNum = 0;
+    props.clear();
+    return;
+}
+
+bool IDF3_COMP_OUTLINE::SetComponentClass( IDF3::COMP_TYPE aCompClass )
+{
+    switch( aCompClass )
+    {
+        case COMP_ELEC:
+        case COMP_MECH:
+            compType = aCompClass;
+            break;
+
+        default:
+            ERROR << "invalid component class (must be ELECTRICAL or MECHANICAL)\n";
+            return false;
+            break;
+    }
+
+    return true;
+}
+
+IDF3::COMP_TYPE IDF3_COMP_OUTLINE::GetComponentClass( void )
+{
+    return compType;
+}
+
+
+void IDF3_COMP_OUTLINE::SetGeomName( const std::string& aGeomName )
+{
+    geometry = aGeomName;
+    uid.clear();
+    return;
+}
+
+const std::string& IDF3_COMP_OUTLINE::GetGeomName( void )
+{
+    return geometry;
+}
+
+void IDF3_COMP_OUTLINE::SetPartName( const std::string& aPartName )
+{
+    part = aPartName;
+    uid.clear();
+    return;
+}
+
+const std::string& IDF3_COMP_OUTLINE::GetPartName( void )
+{
+    return part;
+}
+
+const std::string& IDF3_COMP_OUTLINE::GetUID( void )
+{
+    if( !uid.empty() )
+        return uid;
+
+    if( geometry.empty() && part.empty() )
+        return uid;
+
+    uid = geometry + "_" + part;
+
+    return uid;
+}
+
+
+int IDF3_COMP_OUTLINE::IncrementRef( void )
+{
+    return ++refNum;
+}
+
+int IDF3_COMP_OUTLINE::DecrementRef( void )
+{
+    if( refNum > 0 )
+        --refNum;
+
+    return refNum;
+}
+
+bool IDF3_COMP_OUTLINE::CreateDefaultOutline( const std::string &aGeom, const std::string &aPart )
+{
+    Clear();
+
+    if( aGeom.empty() && aPart.empty() )
+    {
+        geometry  = "NOGEOM";
+        part      = "NOPART";
+        uid       = "NOGEOM_NOPART";
+    }
+    else
+    {
+        geometry  = aGeom;
+        part      = aPart;
+        uid       = aGeom + "_" + aPart;
+    }
+
+    compType  = COMP_ELEC;
+    thickness = 5.0;
+    unit      = UNIT_MM;
+
+    // Create a star shape 5mm high with points on 5 and 3 mm circles
+    double a, da;
+    da = M_PI / 5.0;
+    a = da / 2.0;
+
+    IDF_POINT p1, p2;
+    IDF_OUTLINE* ol = new IDF_OUTLINE;
+    IDF_SEGMENT* sp;
+
+    p1.x = 1.5 * cos( a );
+    p1.y = 1.5 * sin( a );
+
+    if( ol == NULL )
+        return false;
+
+    for( int i = 1; i < 10; ++i )
+    {
+        if( i & 1 )
+        {
+            p2.x = 2.5 * cos( a );
+            p2.y = 2.5 * sin( a );
+        }
+        else
+        {
+            p2.x = 1.5 * cos( a );
+            p2.y = 1.5 * sin( a );
+        }
+
+        sp = new IDF_SEGMENT( p1, p2 );
+
+        if( sp == NULL )
+        {
+            Clear();
+            return false;
+        }
+
+        ol->push( sp );
+        a += da;
+        p1 = p2;
+    }
+
+    a = da / 2.0;
+    p2.x = 1.5 * cos( a );
+    p2.y = 1.5 * sin( a );
+
+    sp = new IDF_SEGMENT( p1, p2 );
+
+    if( sp == NULL )
+    {
+        Clear();
+        return false;
+    }
+
+    ol->push( sp );
+    return true;
+}

=== added file 'utils/idftools/idf_outlines.h'
--- utils/idftools/idf_outlines.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_outlines.h	2014-05-15 04:53:13 +0000
@@ -0,0 +1,295 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+
+#ifndef IDF_OUTLINES_H
+#define IDF_OUTLINES_H
+
+#include <string>
+#include <list>
+#include <map>
+#include <wx/string.h>
+#include <wx/filename.h>
+
+#include <idf_common.h>
+
+/*
+ *  NOTES ON OUTLINE TYPES:
+ *
+ *  BOARD_OUTLINE (PANEL_OUTLINE)
+ *      .BOARD_OUTLINE  [OWNER]
+ *      [thickness]
+ *      [outlines]
+ *
+ *  OTHER_OUTLINE
+ *      .OTHER_OUTLINE  [OWNER]
+ *      [outline identifier] [thickness] [board side: Top/Bot]
+ *      [outline]
+ *
+ *  ROUTE_OUTLINE
+ *      .ROUTE_OUTLINE [OWNER]
+ *      [layers]
+ *      [outline]
+ *
+ *  PLACE_OUTLINE
+ *      .PLACE_OUTLINE [OWNER]
+ *      [board side: Top/Bot/Both] [height]
+ *      [outline]
+ *
+ *  ROUTE_KEEPOUT
+ *      .ROUTE_KEEPOUT [OWNER]
+ *      [layers]
+ *      [outline]
+ *
+ *  VIA_KEEPOUT
+ *      .VIA_KEEPOUT [OWNER]
+ *      [outline]
+ *
+ *  PLACE_KEEPOUT
+ *      .PLACE_KEEPOUT [OWNER]
+ *      [board side: Top/Bot/Both] [height]
+ *      [outline]
+ *
+ *  Placement Group
+ *      .PLACE_REGION [OWNER]
+ *      [side: Top/Bot/Both ] [component group name]
+ *      [outline]
+ *
+ *  Component Outline:
+ *      .ELECTRICAL/.MECHANICAL
+ *      [GEOM] [PART] [UNIT] [HEIGHT]
+ *      [outline]
+ *      [PROP] [prop name] [prop value]
+ */
+
+class IDF3_BOARD;
+
+
+class BOARD_OUTLINE
+{
+protected:
+    std::list< IDF_OUTLINE* > outlines;
+    IDF3::KEY_OWNER             owner;
+    IDF3::OUTLINE_TYPE          outlineType;
+    bool                        single;     // true if only a single outline is accepted
+    std::list< std::string >    comments;   // comment list
+    IDF3::IDF_UNIT              unit;       // unit; required for formatting
+    IDF3_BOARD*                 parent;
+    double                      thickness;  // Board/Extrude Thickness or Height (IDF spec)
+
+    bool readOutlines( std::ifstream& aBoardFile );
+    bool writeComments( std::ofstream& aBoardFile );
+    bool writeOwner( std::ofstream& aBoardFile );
+    bool writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex );
+    bool writeOutlines( std::ofstream& aBoardFile );  // write outline data (no headers)
+
+public:
+    BOARD_OUTLINE();
+    virtual ~BOARD_OUTLINE();
+
+    virtual void SetUnit( IDF3::IDF_UNIT aUnit );
+    virtual IDF3::IDF_UNIT GetUnit( void );
+
+    virtual bool SetThickness( double aThickness );
+    virtual double GetThickness( void );
+
+    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
+    // writes data to a .BOARD_OUTLINE section
+    virtual bool WriteData( std::ofstream& aBoardFile );
+    // clears all internal data except for parent pointer
+    virtual void Clear( void );
+
+    IDF3::OUTLINE_TYPE GetOutlineType( void );
+
+    void SetParent( IDF3_BOARD* aParent );
+    IDF3_BOARD* GetParent( void );
+    // return true if the outline was added; false if it already existed
+    bool AddOutline( IDF_OUTLINE* aOutline );
+    // removes the given outline if it is on the list; the outline
+    // pointer remains valid and it is the user's responsibility to
+    // delete the object. The first outline will not be deleted unless
+    // it is the only remaining outline
+    bool DelOutline( IDF_OUTLINE* aOutline );
+    // removes the outline given by the index and the outline pointer
+    // is destroyed. The first outline will not be deleted unless
+    // it is the only remaining outline.
+    bool DelOutline( size_t aIndex );
+    std::list< IDF_OUTLINE* >& GetOutlines( void );
+    size_t OutlinesSize( void );
+    IDF_OUTLINE* GetOutline( size_t aIndex );
+    IDF3::KEY_OWNER GetOwner( void );
+    bool SetOwner( IDF3::KEY_OWNER aOwner );
+    bool IsSingle( void );
+    void ClearOutlines( void );
+    void AddComment( const std::string& aComment );
+    size_t CommentsSize( void );
+    const std::list< std::string >& GetComments( void );
+    const std::string *const GetComment( size_t aIndex );
+    bool  DeleteComment( size_t aIndex );
+    void  ClearComments( void );
+};
+
+
+// OTHER outlines: describes miscellaneous extrusions on board
+class OTHER_OUTLINE : public BOARD_OUTLINE
+{
+private:
+    std::string uniqueID;   // Outline Identifier (IDF spec)
+    IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM ONLY] (IDF spec)
+
+public:
+    OTHER_OUTLINE();
+
+    virtual void SetOutlineIdentifier( const std::string aUniqueID );
+    virtual const std::string& GetOutlineIdentifier( void );
+
+    virtual bool SetSide( IDF3::IDF_LAYER aSide );
+    virtual IDF3::IDF_LAYER GetSide( void );
+
+    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
+    virtual bool WriteData( std::ofstream& aBoardFile );
+    virtual void Clear( void );
+};
+
+
+// ROUTE outlines: describes routing areas on board
+class ROUTE_OUTLINE : public BOARD_OUTLINE
+{
+protected:
+    IDF3::IDF_LAYER layers; // Routing layers (IDF spec)
+
+public:
+    ROUTE_OUTLINE();
+
+    virtual void SetLayers( IDF3::IDF_LAYER aLayer );
+    virtual IDF3::IDF_LAYER GetLayers( void );
+
+    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
+    virtual bool WriteData( std::ofstream& aBoardFile );
+    virtual void Clear( void );
+};
+
+// PLACEMENT outlines
+class PLACE_OUTLINE : public BOARD_OUTLINE
+{
+protected:
+    IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM/BOTH ONLY] (IDF spec)
+    double height;          // Max Height (IDF spec)
+
+public:
+    PLACE_OUTLINE();
+
+    virtual bool SetSide( IDF3::IDF_LAYER aSide );
+    virtual IDF3::IDF_LAYER GetSide( void );
+
+    virtual void SetMaxHeight( double aHeight );
+    virtual double GetMaxHeight( void );
+
+    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
+    virtual bool WriteData( std::ofstream& aBoardFile );
+    virtual void Clear( void );
+};
+
+
+// ROUTE KEEPOUT outlines
+class ROUTE_KO_OUTLINE : public ROUTE_OUTLINE
+{
+public:
+    ROUTE_KO_OUTLINE();
+};
+
+// VIA KEEPOUT outlines
+class VIA_KO_OUTLINE : public OTHER_OUTLINE
+{
+public:
+    VIA_KO_OUTLINE();
+};
+
+// PLACE KEEPOUT outlines
+class PLACE_KO_OUTLINE : public PLACE_OUTLINE
+{
+public:
+    PLACE_KO_OUTLINE();
+};
+
+// PLACEMENT GROUP outlines
+class GROUP_OUTLINE : public BOARD_OUTLINE
+{
+private:
+    IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM/BOTH ONLY] (IDF spec)
+    std::string groupName;  // non-unique string
+
+public:
+    GROUP_OUTLINE();
+
+    virtual bool SetSide( IDF3::IDF_LAYER aSide );
+    virtual IDF3::IDF_LAYER GetSide( void );
+
+    virtual void SetGroupName( std::string aGroupName );
+    virtual const std::string& GetGroupName( void );
+
+    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
+    virtual bool WriteData( std::ofstream& aBoardFile );
+    virtual void Clear( void );
+};
+
+
+class IDF3_COMP_OUTLINE : public BOARD_OUTLINE
+{
+private:
+    std::string     uid;        // unique ID
+    std::string     geometry;   // geometry name (IDF)
+    std::string     part;       // part name (IDF)
+    IDF3::COMP_TYPE compType;   // component type
+    int             refNum;     // number of components referring to this outline
+
+    std::map< std::string, std::string >    props;      // properties list
+
+    bool readProperties( std::ifstream& aLibFile );
+    bool writeProperties( std::ofstream& aLibFile );
+
+public:
+    IDF3_COMP_OUTLINE();
+
+    virtual bool ReadData( std::ifstream& aLibFile, const std::string& aHeader );
+    virtual bool WriteData( std::ofstream& aLibFile );
+    virtual void Clear( void );
+
+    bool SetComponentClass( IDF3::COMP_TYPE aCompClass );
+    IDF3::COMP_TYPE GetComponentClass( void );
+
+    void SetGeomName( const std::string& aGeomName );
+    const std::string& GetGeomName( void );
+    void SetPartName( const std::string& aPartName );
+    const std::string& GetPartName( void );
+    const std::string& GetUID( void );
+
+    int IncrementRef( void );
+    int DecrementRef( void );
+
+    bool CreateDefaultOutline( const std::string &aGeom, const std::string &aPart );
+
+    // XXX: property manipulators
+};
+
+#endif // IDF_OUTLINES_H
\ No newline at end of file

=== added file 'utils/idftools/idf_parser.cpp'
--- utils/idftools/idf_parser.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_parser.cpp	2014-05-16 00:10:55 +0000
@@ -0,0 +1,3376 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <iostream>
+#include <iomanip>
+#include <fstream>
+#include <sstream>
+#include <cmath>
+#include <cerrno>
+#include <algorithm>
+#include <macros.h>
+
+#include <idf_parser.h>
+#include <idf_helpers.h>
+
+using namespace std;
+using namespace IDF3;
+
+static bool CompareComponent( IDF3_COMPONENT* p1, IDF3_COMPONENT* p2 )
+{
+    return p1->GetRefDes().compare( p2->GetRefDes() ) < 0 ? true : false;
+}
+
+static bool CompareCompOutline( IDF3_COMP_OUTLINE* p1, IDF3_COMP_OUTLINE* p2 )
+{
+    return p1->GetUID().compare( p2->GetUID() ) < 0 ? true : false;
+}
+
+
+/*
+ * CLASS: IDF3_COMP_OUTLINE_DATA
+ * This represents the outline placement
+ * information and other data specific to
+ * each component instance.
+ */
+IDF3_COMP_OUTLINE_DATA::IDF3_COMP_OUTLINE_DATA()
+{
+    parent = NULL;
+    outline = NULL;
+    xoff = 0.0;
+    yoff = 0.0;
+    zoff = 0.0;
+    aoff = 0.0;
+
+    return;
+}
+
+IDF3_COMP_OUTLINE_DATA::IDF3_COMP_OUTLINE_DATA( IDF3_COMPONENT* aParent,
+                                                IDF3_COMP_OUTLINE* aOutline )
+{
+    parent = aParent;
+    outline = aOutline;
+    xoff = 0.0;
+    yoff = 0.0;
+    zoff = 0.0;
+    aoff = 0.0;
+
+    if( aOutline )
+        aOutline->IncrementRef();
+
+    return;
+}
+
+IDF3_COMP_OUTLINE_DATA::IDF3_COMP_OUTLINE_DATA( IDF3_COMPONENT* aParent,
+                                                IDF3_COMP_OUTLINE* aOutline,
+                                                double aXoff, double aYoff,
+                                                double aZoff, double aAoff )
+{
+    parent = aParent;
+    outline = aOutline;
+    xoff = aXoff;
+    yoff = aYoff;
+    zoff = aZoff;
+    aoff = aAoff;
+    return;
+}
+
+IDF3_COMP_OUTLINE_DATA::~IDF3_COMP_OUTLINE_DATA()
+{
+    if( outline )
+        outline->DecrementRef();
+
+    return;
+}
+
+void IDF3_COMP_OUTLINE_DATA::SetOffsets( double aXoff, double aYoff,
+                                         double aZoff, double aAngleOff )
+{
+    xoff = aXoff;
+    yoff = aYoff;
+    zoff = aZoff;
+    aoff = aAngleOff;
+    return;
+}
+
+void IDF3_COMP_OUTLINE_DATA::GetOffsets( double& aXoff, double& aYoff,
+                                         double& aZoff, double& aAngleOff )
+{
+    aXoff = xoff;
+    aYoff = yoff;
+    aZoff = zoff;
+    aAngleOff = aoff;
+    return;
+}
+
+
+void IDF3_COMP_OUTLINE_DATA::SetParent( IDF3_COMPONENT* aParent )
+{
+    parent = aParent;
+}
+
+void IDF3_COMP_OUTLINE_DATA::SetOutline( IDF3_COMP_OUTLINE* aOutline )
+{
+    if( outline )
+        outline->DecrementRef();
+
+    outline = aOutline;
+
+    if( outline )
+        outline->IncrementRef();
+
+    return;
+}
+
+bool IDF3_COMP_OUTLINE_DATA::ReadPlaceData( std::ifstream &aBoardFile,
+                                            IDF3::FILE_STATE& aBoardState, IDF3_BOARD *aBoard )
+{
+    if( !aBoard )
+    {
+        ERROR;
+        cerr << "BUG: invoked with no reference to the parent IDF_BOARD\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // clear out data possibly left over from previous use of the object
+    outline = NULL;
+    parent  = NULL;
+
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+    std::string uid;
+    std::string refdes;
+    IDF3::IDF_PLACEMENT placement = IDF3::PS_UNPLACED;
+    IDF3::IDF_LAYER side = IDF3::LYR_TOP;
+
+    // RECORD 2: 'package name', 'part number', 'Refdes' (any, NOREFDES, BOARD)
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading PLACEMENT SECTION\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within a section (PLACEMENT)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( !quoted && CompareToken( ".END_PLACEMENT", token ) )
+    {
+        errno = 0;
+        aBoardState = IDF3::FILE_PLACEMENT;
+        return false;
+    }
+
+    std::string ngeom = token;
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no PART NAME in PLACEMENT RECORD2\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    std::string npart = token;
+    uid = ngeom + "_" + npart;
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no REFDES in PLACEMENT RECORD2\n";
+        cerr << "* Line: '" << iline << "'\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "NOREFDES", token ) )
+    {
+        // according to the IDF3.0 specification, this is a
+        // mechanical component. The specification is defective
+        // since it is impossible to associate mechanical
+        // components with their holes unless the mechanical
+        // component is given a unique RefDes. This class of defect
+        // is one reason IDF does not work well in faithfully
+        // conveying information between ECAD and MCAD.
+        refdes = token;
+    }
+    else if( CompareToken( "BOARD", token ) )
+    {
+        ERROR;
+        cerr << "unsupported feature\n";
+        cerr << "* RefDes is 'BOARD', indicating this is a PANEL FILE (not supported)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+    else if( CompareToken( "PANEL", token ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: RefDes in PLACEMENT RECORD2 is 'PANEL'\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+    else if( token.empty() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: empty RefDes string in PLACEMENT RECORD2\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+    else
+    {
+        // note: perversely, spaces can be a valid RefDes
+        refdes = token;
+    }
+
+    // RECORD 3: X, Y, Z, ROT, SIDE (top/bot), PLACEMENT (placed, unplaced, mcad, ecad)
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading PLACEMENT SECTION, RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within a section (PLACEMENT)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: X value must not be in quotes (PLACEMENT RECORD 3)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istringstream istr;
+    istr.str( token );
+
+    istr >> xoff;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: X value is not numeric (PLACEMENT RECORD 3)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no Y value in PLACEMENT RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> yoff;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Y value is not numeric (PLACEMENT RECORD 3)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no Z value in PLACEMENT RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> zoff;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: Z value is not numeric (PLACEMENT RECORD 3)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no rotation value in PLACEMENT RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    istr.clear();
+    istr.str( token );
+
+    istr >> aoff;
+    if( istr.fail() )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: rotation value is not numeric (PLACEMENT RECORD 3)\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no SIDE value in PLACEMENT RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "TOP", token ) )
+    {
+        side = IDF3::LYR_TOP;
+    }
+    else if( CompareToken( "BOTTOM", token ) )
+    {
+        side = IDF3::LYR_BOTTOM;
+    }
+    else
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: SIDE value in PLACEMENT RECORD 3 is invalid ('";
+        cerr << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: no PLACEMENT value in PLACEMENT RECORD 3\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "PLACED", token ) )
+    {
+        placement = IDF3::PS_PLACED;
+    }
+    else if( CompareToken( "UNPLACED", token ) )
+    {
+        placement = IDF3::PS_UNPLACED;
+    }
+    else if( CompareToken( "MCAD", token ) )
+    {
+        placement = IDF3::PS_MCAD;
+    }
+    else if( CompareToken( "ECAD", token ) )
+    {
+        placement = IDF3::PS_ECAD;
+    }
+    else
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: PLACEMENT value in PLACEMENT RECORD 3 is invalid ('";
+        cerr << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    outline = aBoard->GetComponentOutline( uid );
+
+    if( outline == NULL )
+    {
+        ERROR << "MISSING OUTLINE\n";
+        cerr << "* GeomName( " << ngeom << " ), PartName( " << npart << " )\n";
+        cerr << "* Substituting default outline.\n";
+        outline = aBoard->GetInvalidOutline( ngeom, npart );
+
+        if( outline == NULL )
+        {
+            ERROR << "cannot create outline object\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+    }
+
+    if( aBoard->GetUnit() == IDF3::UNIT_THOU )
+    {
+        xoff *= 0.0254;
+        yoff *= 0.0254;
+        zoff *= 0.0254;
+    }
+
+    parent = aBoard->FindComponent( refdes );
+
+    if( parent == NULL )
+    {
+        IDF3_COMPONENT* cp = new IDF3_COMPONENT( aBoard );
+
+        if( cp == NULL )
+        {
+            ERROR << "cannot create component object\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        cp->SetRefDes( refdes );
+        cp->SetPosition( xoff, yoff, aoff, side );
+        cp->SetPlacement( placement );
+
+        xoff = 0;
+        yoff = 0;
+        aoff = 0;
+
+        aBoard->AddComponent( cp );
+
+        parent = cp;
+    }
+    else
+    {
+        double tX, tY, tA;
+        IDF3::IDF_LAYER tL;
+
+        if( parent->GetPosition( tX, tY, tA, tL ) )
+        {
+            if( side != tL )
+            {
+                ERROR << "inconsistent PLACEMENT data\n";
+                cerr << "* SIDE value has changed from " << GetSideString( tL );
+                cerr << " to " << GetSideString( side ) << "\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            xoff -= tX;
+            yoff -= tY;
+            aoff -= tA;
+        }
+        else
+        {
+            parent->SetPosition( xoff, yoff, aoff, side );
+            parent->SetPlacement( placement );
+
+            xoff = 0;
+            yoff = 0;
+            aoff = 0;
+        }
+
+        if( placement != parent->GetPlacement() )
+        {
+            ERROR << "inconsistent PLACEMENT data\n";
+            cerr << "* placement value has changed from " << GetPlacementString( parent->GetPlacement() );
+            cerr << " to " << GetPlacementString( placement ) << "\n";
+            cerr << "* line: '" << iline << "'\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+    }
+
+    // copy internal data to a new object and push it into the component's outline list
+    IDF3_COMP_OUTLINE_DATA* cdp = new IDF3_COMP_OUTLINE_DATA;
+    *cdp = *this;
+
+    if( !parent->AddOutlineData( cdp ) )
+    {
+        ERROR << "could not add outline data object\n";
+        aBoardState = IDF3::FILE_INVALID;
+        delete cdp;
+        return false;
+    }
+
+    return true;
+}
+
+bool IDF3_COMP_OUTLINE_DATA::WritePlaceData( std::ofstream& aBoardFile,
+                                             double aXpos, double aYpos, double aAngle,
+                                             const std::string aRefDes,
+                                             IDF3::IDF_PLACEMENT aPlacement,
+                                             IDF3::IDF_LAYER aSide )
+{
+    if( outline == NULL )
+        return true;
+
+    if( outline->GetUID().empty() )
+    {
+        ERROR << "invalid GEOM/PART names\n";
+        return false;
+    }
+
+    if( aPlacement == PS_INVALID )
+    {
+        ERROR << "placement invalid; defaulting to PLACED\n";
+        aPlacement = PS_PLACED;
+    }
+
+    if( aSide != LYR_TOP && aSide != LYR_BOTTOM )
+    {
+        ERROR << "invalid side (" << aSide << "); must be TOP or BOTTOM\n";
+        return false;
+    }
+
+    // calculate the final position based on layer
+    double xpos, ypos, ang;
+
+    switch( aSide )
+    {
+        case LYR_TOP:
+            xpos = aXpos + xoff;
+            ypos = aYpos + yoff;
+            ang  = aAngle + aoff;
+            break;
+
+        default:
+            xpos = aXpos - xoff;
+            ypos = aYpos + yoff;
+            ang  = aAngle - aoff;
+            break;
+    }
+
+    std::string arefdes = aRefDes;
+
+    if( arefdes.empty() || !arefdes.compare( "~" )
+        || ( arefdes.size() >= 8 && CompareToken( "NOREFDES", arefdes.substr(0, 8) ) ) )
+        arefdes = "NOREFDES";
+
+    aBoardFile << "\"" << outline->GetGeomName() << "\" \"" << outline->GetPartName() << "\" "
+    << arefdes << "\n";
+
+    IDF3::IDF_UNIT unit = UNIT_MM;
+
+    if( parent )
+        unit = parent->GetUnit();
+
+    if( unit == UNIT_MM )
+    {
+        aBoardFile << setiosflags(ios::fixed) << setprecision(5) << xpos << " "
+        << ypos << " " << setprecision(3) << zoff << " "
+        << ang << " ";
+    }
+    else
+    {
+        aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (xpos / 0.0254) << " "
+        << (ypos / 0.0254) << " "  << (zoff / 0.0254) << " "
+        << setprecision(3) << ang << " ";
+    }
+
+    WriteLayersText( aBoardFile, aSide );
+
+    switch( aPlacement )
+    {
+        case PS_PLACED:
+            aBoardFile << "PLACED\n";
+            break;
+
+        case PS_UNPLACED:
+            aBoardFile << "UNPLACED\n";
+            break;
+
+        case PS_MCAD:
+            aBoardFile << "MCAD\n";
+            break;
+
+        default:
+            aBoardFile << "ECAD\n";
+            break;
+    }
+
+    return !aBoardFile.fail();
+}
+
+
+/*
+ * CLASS: IDF3_COMPONENT
+ *
+ * This represents a component and its associated
+ * IDF outlines and ancillary data (position, etc)
+ */
+IDF3_COMPONENT::IDF3_COMPONENT()
+{
+    xpos   = 0.0;
+    ypos   = 0.0;
+    angle  = 0.0;
+    parent = NULL;
+
+    hasPosition = false;
+    placement   = PS_INVALID;
+    layer       = LYR_INVALID;
+    return;
+}
+
+IDF3_COMPONENT::IDF3_COMPONENT( IDF3_BOARD* aParent )
+{
+    IDF3_COMPONENT();
+    parent = aParent;
+    return;
+}
+
+IDF3_COMPONENT::~IDF3_COMPONENT()
+{
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itcS = components.begin();
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itcE = components.end();
+
+    while( itcS != itcE )
+    {
+        delete *itcS;
+        ++itcS;
+    }
+
+    components.clear();
+
+    std::list< IDF_DRILL_DATA* >::iterator itdS = drills.begin();
+    std::list< IDF_DRILL_DATA* >::iterator itdE = drills.end();
+
+    while( itdS != itdE )
+    {
+        delete *itdS;
+        ++itdS;
+    }
+
+    drills.clear();
+
+    return;
+}
+
+void IDF3_COMPONENT::SetParent( IDF3_BOARD* aParent )
+{
+    parent = aParent;
+    return;
+}
+
+IDF3::CAD_TYPE IDF3_COMPONENT::GetCadType( void )
+{
+    if( parent )
+        return parent->GetCadType();
+
+    return CAD_INVALID;
+}
+
+IDF3::IDF_UNIT IDF3_COMPONENT::GetUnit( void )
+{
+    if( parent )
+        return parent->GetUnit();
+
+    return UNIT_INVALID;
+}
+
+
+bool IDF3_COMPONENT::SetRefDes( const std::string& aRefDes )
+{
+    if( aRefDes.empty() )
+    {
+        ERROR << "invalid RefDes (empty)\n";
+        return false;
+    }
+
+    if( CompareToken( "PANEL", aRefDes ) )
+    {
+        ERROR;
+        cerr << "\n*BUG: PANEL is a reserved designator and may not be used by components\n";
+        return false;
+    }
+
+    refdes = aRefDes;
+    return true;
+}
+
+const std::string& IDF3_COMPONENT::GetRefDes( void )
+{
+    return refdes;
+}
+
+IDF_DRILL_DATA* IDF3_COMPONENT::AddDrill( double aDia, double aXpos, double aYpos,
+                                          IDF3::KEY_PLATING aPlating,
+                                          const std::string aHoleType,
+                                          IDF3::KEY_OWNER aOwner )
+{
+    IDF_DRILL_DATA* dp = new IDF_DRILL_DATA( aDia, aXpos, aYpos, aPlating,
+                                             refdes, aHoleType, aOwner );
+
+    if( dp == NULL )
+        return NULL;
+
+    drills.push_back( dp );
+
+    return dp;
+}
+
+IDF_DRILL_DATA* IDF3_COMPONENT::AddDrill( IDF_DRILL_DATA* aDrilledHole )
+{
+    if( !aDrilledHole )
+        return NULL;
+
+    if( CompareToken( "PANEL", refdes ) )
+    {
+        ERROR;
+        cerr << "\n*BUG: PANEL drills not supported\n";
+        return NULL;
+    }
+
+    if( refdes.compare( aDrilledHole->GetDrillRefDes() ) )
+    {
+        ERROR;
+        cerr << "\n*BUG: pushing an incorrect REFDES ('" << aDrilledHole->GetDrillRefDes();
+        cerr << "') to component ('" << refdes << "')\n";
+        return NULL;
+    }
+
+    drills.push_back( aDrilledHole );
+
+    return aDrilledHole;
+}
+
+
+bool IDF3_COMPONENT::DelDrill( double aDia, double aXpos, double aYpos )
+{
+    if( drills.empty() )
+        return false;
+
+    bool val = false;
+
+    list< IDF_DRILL_DATA* >::iterator itS = drills.begin();
+    list< IDF_DRILL_DATA* >::iterator itE = drills.end();
+
+    while( !drills.empty() && itS != itE )
+    {
+        if( (*itS)->Matches( aDia, aXpos, aYpos ) )
+        {
+            val = true;
+            delete *itS;
+            drills.erase( itS );
+            itS = drills.begin();
+            itE = drills.end();
+            continue;
+        }
+        ++itS;
+    }
+
+    return val;
+}
+
+bool IDF3_COMPONENT::DelDrill( IDF_DRILL_DATA* aDrill )
+{
+    if( drills.empty() )
+        return false;
+
+    list< IDF_DRILL_DATA* >::iterator itS = drills.begin();
+    list< IDF_DRILL_DATA* >::iterator itE = drills.end();
+
+    while( !drills.empty() && itS != itE )
+    {
+        if( *itS == aDrill )
+        {
+            delete *itS;
+            drills.erase( itS );
+            return true;
+        }
+        ++itS;
+    }
+
+    return false;
+}
+
+std::list< IDF_DRILL_DATA* >& IDF3_COMPONENT::GetDrills( void )
+{
+    return drills;
+}
+
+bool IDF3_COMPONENT::AddOutlineData( IDF3_COMP_OUTLINE_DATA* aComponentOutline )
+{
+    if( aComponentOutline == NULL )
+        return false;
+
+    components.push_back( aComponentOutline );
+
+    return true;
+}
+
+bool IDF3_COMPONENT::DeleteOutlineData( IDF3_COMP_OUTLINE_DATA* aComponentOutline )
+{
+    if( components.empty() || aComponentOutline == NULL )
+        return false;
+
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itS = components.begin();
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itE = components.end();
+
+    while( itS != itE )
+    {
+        if( *itS == aComponentOutline )
+        {
+            delete *itS;
+            components.erase( itS );
+            return true;
+        }
+
+        ++itS;
+    }
+
+    return false;
+}
+
+bool IDF3_COMPONENT::DeleteOutlineData( size_t aIndex )
+{
+    if( aIndex >= components.size() )
+        return false;
+
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itS = components.begin();
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itE = components.end();
+    size_t idx = 0;
+
+    while( itS != itE )
+    {
+        if( idx == aIndex )
+        {
+            delete *itS;
+            components.erase( itS );
+            return true;
+        }
+
+        ++idx;
+        ++itS;
+    }
+
+    return false;
+}
+
+size_t IDF3_COMPONENT::GetOutlinesSize( void )
+{
+    return components.size();
+}
+
+std::list< IDF3_COMP_OUTLINE_DATA* >& IDF3_COMPONENT::GetOutlinesData( void )
+{
+    return components;
+}
+
+bool IDF3_COMPONENT::GetPosition( double& aXpos, double& aYpos, double& aAngle,
+                                  IDF3::IDF_LAYER& aLayer )
+{
+    if( !hasPosition )
+        return false;
+
+    aXpos = xpos;
+    aYpos = ypos;
+    aAngle = angle;
+    aLayer = layer;
+    return true;
+}
+
+bool IDF3_COMPONENT::SetPosition( double aXpos, double aYpos, double aAngle, IDF3::IDF_LAYER aLayer )
+{
+    switch( aLayer )
+    {
+        case LYR_TOP:
+        case LYR_BOTTOM:
+            break;
+
+        default:
+            ERROR << "invalid side (must be TOP or BOTTOM only): " << aLayer << "\n";
+            return false;
+            break;
+    }
+
+    if( hasPosition )
+        return false;
+
+    hasPosition = true;
+    xpos = aXpos;
+    ypos = aYpos;
+    angle = aAngle;
+    layer = aLayer;
+    return true;
+}
+
+
+IDF3::IDF_PLACEMENT IDF3_COMPONENT::GetPlacement( void )
+{
+    return placement;
+}
+
+
+bool IDF3_COMPONENT::SetPlacement( IDF3::IDF_PLACEMENT aPlacementValue )
+{
+    if( aPlacementValue == PS_INVALID )
+        return false;
+
+    placement = aPlacementValue;
+    return true;
+}
+
+bool IDF3_COMPONENT::WriteDrillData( std::ofstream& aBoardFile )
+{
+    if( drills.empty() )
+        return true;
+
+    std::list< IDF_DRILL_DATA* >::iterator itS = drills.begin();
+    std::list< IDF_DRILL_DATA* >::iterator itE = drills.end();
+
+    while( itS != itE )
+    {
+        if( !(*itS)->Write( aBoardFile, GetUnit() ) )
+            return false;
+
+        ++itS;
+    }
+
+    return true;
+}
+
+bool IDF3_COMPONENT::WritePlaceData( std::ofstream& aBoardFile )
+{
+    if( components.empty() )
+        return true;
+
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itS = components.begin();
+    std::list< IDF3_COMP_OUTLINE_DATA* >::iterator itE = components.end();
+
+    while( itS != itE )
+    {
+        if( !(*itS)->WritePlaceData( aBoardFile, xpos, ypos, angle, refdes, placement, layer ) )
+            return false;
+
+        ++itS;
+    }
+
+    return true;
+}
+
+
+IDF3_BOARD::IDF3_BOARD( IDF3::CAD_TYPE aCadType )
+{
+    boardThickness = 1.6;
+    state          = FILE_START;
+    cadType        = aCadType;
+    userScale      = 1.0;
+    userXoff       = 0.0;
+    userYoff       = 0.0;
+
+
+    // unlike other outlines which are created as necessary,
+    // the board outline always exists and its parent must
+    // be set here
+    olnBoard.SetParent( this );
+
+    return;
+}
+
+IDF3_BOARD::~IDF3_BOARD()
+{
+    Clear();
+
+    return;
+}
+
+IDF3::CAD_TYPE IDF3_BOARD::GetCadType( void )
+{
+    return cadType;
+}
+
+void IDF3_BOARD::SetBoardName( std::string aBoardName )
+{
+    boardName = aBoardName;
+    return;
+}
+
+const std::string& IDF3_BOARD::GetBoardName( void )
+{
+    return boardName;
+}
+
+bool IDF3_BOARD::SetUnit( IDF3::IDF_UNIT aUnit, bool convert )
+{
+    switch( aUnit )
+    {
+    case UNIT_MM:
+    case UNIT_THOU:
+        unit = aUnit;
+        break;
+
+    default:
+        ERROR << "invalid board unit\n";
+        return false;
+        break;
+    }
+
+    // iterate through all owned OUTLINE objects (except IDF3_COMP_OUTLINE)
+    // and set to the same unit
+
+    olnBoard.SetUnit( aUnit );
+
+    do
+    {
+        std::map< std::string, OTHER_OUTLINE*>::iterator its = olnOther.begin();
+        std::map< std::string, OTHER_OUTLINE*>::iterator ite = olnOther.end();
+
+        while( its != ite )
+        {
+            its->second->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::list<ROUTE_OUTLINE*>::iterator its = olnRoute.begin();
+        std::list<ROUTE_OUTLINE*>::iterator ite = olnRoute.end();
+
+        while( its != ite )
+        {
+            (*its)->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::list<PLACE_OUTLINE*>::iterator its = olnPlace.begin();
+        std::list<PLACE_OUTLINE*>::iterator ite = olnPlace.end();
+
+        while( its != ite )
+        {
+            (*its)->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::list<ROUTE_KO_OUTLINE*>::iterator its = olnRouteKeepout.begin();
+        std::list<ROUTE_KO_OUTLINE*>::iterator ite = olnRouteKeepout.end();
+
+        while( its != ite )
+        {
+            (*its)->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::list<VIA_KO_OUTLINE*>::iterator its = olnViaKeepout.begin();
+        std::list<VIA_KO_OUTLINE*>::iterator ite = olnViaKeepout.end();
+
+        while( its != ite )
+        {
+            (*its)->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::list<PLACE_KO_OUTLINE*>::iterator its = olnPlaceKeepout.begin();
+        std::list<PLACE_KO_OUTLINE*>::iterator ite = olnPlaceKeepout.end();
+
+        while( its != ite )
+        {
+            (*its)->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+    do
+    {
+        std::map<std::string, GROUP_OUTLINE*>::iterator its = olnGroup.begin();
+        std::map<std::string, GROUP_OUTLINE*>::iterator ite = olnGroup.end();
+
+        while( its != ite )
+        {
+            its->second->SetUnit( aUnit );
+            ++its;
+        }
+
+    } while( 0 );
+
+
+    //iterate through all owned IDF3_COMP_OUTLINE objects and
+    // set to the same unit IF convert = true
+    if( convert )
+    {
+        std::map<std::string, IDF3_COMP_OUTLINE*>::iterator its = compOutlines.begin();
+        std::map<std::string, IDF3_COMP_OUTLINE*>::iterator ite = compOutlines.end();
+
+        while( its != ite )
+        {
+            its->second->SetUnit( aUnit );
+            ++its;
+        }
+
+    }
+
+    return true;
+}
+
+
+IDF3::IDF_UNIT IDF3_BOARD::GetUnit( void )
+{
+    return unit;
+}
+
+
+bool IDF3_BOARD::SetBoardThickness( double aBoardThickness )
+{
+    if( aBoardThickness <= 0.0 )
+    {
+        ERROR << "board thickness must be > 0\n";
+        return false;
+    }
+
+    boardThickness = aBoardThickness;
+    return true;
+}
+
+
+double IDF3_BOARD::GetBoardThickness( void )
+{
+    return boardThickness;
+}
+
+// read the DRILLED HOLES section
+bool IDF3_BOARD::ReadBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+{
+    IDF_DRILL_DATA drill;
+
+    while( drill.Read( aBoardFile, unit, aBoardState ) )
+    {
+        if( CompareToken( "PANEL", drill.GetDrillRefDes() ) )
+        {
+            ERROR;
+            cerr << "\n[INFO]: Dropping unsupported drill refdes: 'PANEL' (not supported)\n";
+            continue;
+        }
+
+        IDF_DRILL_DATA *dp = new IDF_DRILL_DATA;
+        *dp = drill;
+        if( AddDrill( dp ) == NULL )
+        {
+            delete dp;
+            ERROR;
+            cerr << "\n* BUG: could not add drill data; cannot continue reading the file\n";
+            aBoardState = FILE_INVALID;
+            return false;
+        }
+    }
+
+    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
+        return true;
+
+    return false;
+
+}
+
+
+// read the NOTES section
+bool IDF3_BOARD::ReadBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+{
+    IDF_NOTE note;
+
+    while( note.ReadNote( aBoardFile, aBoardState, unit ) )
+    {
+        IDF_NOTE *np = new IDF_NOTE;
+        *np = note;
+        notes.push_back( np );
+    }
+
+    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
+        return true;
+
+    return false;
+}
+
+
+// read the component placement section
+bool IDF3_BOARD::ReadBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+{
+    IDF3_COMP_OUTLINE_DATA oldata;
+
+    while( oldata.ReadPlaceData( aBoardFile, aBoardState, this ) );
+
+    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
+        return true;
+
+    ERROR << "problems reading board PLACEMENT section\n";
+
+    return false;
+
+}
+
+
+// read the board HEADER
+bool IDF3_BOARD::ReadBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+{
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+
+    // RECORD 1: ".HEADER" must be the very first line
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board header\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: first line must be .HEADER\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( ".HEADER", iline ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: first line must be .HEADER and have no quotes or trailing text\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // RECORD 2:
+    //      File Type [str]: BOARD_FILE (PANEL_FILE not supported)
+    //      IDF Version Number [float]: must be 3.0
+    //      Source System [str]: ignored
+    //      Date [str]: ignored
+    //      Board File Version [int]: ignored
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board header, RECORD 2\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within .HEADER section\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: File Type in HEADER section must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( "BOARD_FILE", token ) )
+    {
+        ERROR;
+
+        if( CompareToken( "PANEL_FILE", token ) )
+        {
+            cerr << "not a board file\n";
+            cerr << "* PANEL_FILE is not supported (expecting BOARD_FILE)\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+        else
+        {
+            cerr << "invalid IDFv3 file\n";
+            cerr << "* Expecting string: BOARD_FILE\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2: no FIELD 2\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: IDF Version must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( token.compare( "3.0" ) && token.compare( "3." ) && token.compare( "3" ) )
+    {
+        ERROR;
+        cerr << "unsupported IDF version\n";
+        cerr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 3: no Source System string\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 4: no Date string\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 5: no Board File Version number\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: HEADER section, RECORD 2, FIELD 5: Board File Version must not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // RECORD 3:
+    //      Board Name [str]: stored
+    //      Units [str]: MM or THOU
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board header, RECORD 2\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within .HEADER section\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    boardName = token;
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 3, FIELD 1: no Board Name\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: HEADER section, RECORD 3, FIELD 2: UNIT may not be in quotes\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( CompareToken( "MM", token ) )
+    {
+        unit = IDF3::UNIT_MM;
+    }
+    else if( CompareToken( "THOU", token ) )
+    {
+        unit = IDF3::UNIT_THOU;
+    }
+    else
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* HEADER section, RECORD 3, FIELD 2: expecting MM or THOU (got '" << token << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // RECORD 4:
+    //      .END_HEADER
+    while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+    if( !aBoardFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading board header, RECORD 4\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: comment within .HEADER section\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( ".END_HEADER", iline ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 file\n";
+        cerr << "* Violation of specification: expected .END_HEADER (got '" << iline << "')\n";
+        aBoardState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    aBoardState = IDF3::FILE_HEADER;
+    return true;
+}
+
+
+// read individual board sections; pay attention to IDFv3 section specifications
+bool IDF3_BOARD::ReadBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+{
+    std::list< std::string > comments;  // comments associated with a section
+
+    // Reads in .SECTION_ID or #COMMENTS
+    // Expected SECTION IDs:
+    //      .BOARD_OUTLINE
+    //      .PANEL_OUTLINE (NOT SUPPORTED)
+    //      .OTHER_OUTLINE
+    //      .ROUTE_OUTLINE
+    //      .PLACE_OUTLINE
+    //      .ROUTE_KEEPOUT
+    //      .VIA_KEEPOUT
+    //      .PLACE_KEEPOUT
+    //      .PLACE_REGION
+    //      .DRILLED_HOLES
+    //      .NOTES (NOT YET SUPPORTED: NOTES SECTION WILL BE SKIPPED FOR NOW)
+    //      .PLACEMENT
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+
+    while( aBoardFile.good() )
+    {
+        while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
+
+        if( !aBoardFile.good() )
+        {
+            if( aBoardFile.eof() && aBoardState >= IDF3::FILE_OUTLINE && aBoardState < IDF3::FILE_INVALID )
+                return true;
+
+            ERROR;
+            cerr << "problems reading board section\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( isComment )
+        {
+            comments.push_back( iline );
+            continue;
+        }
+
+        // This must be a header
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR;
+            cerr << "problems reading board section\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR;
+            cerr << "invalid IDFv3 file\n";
+            cerr << "* Violation of specification: quoted string where SECTION HEADER expected\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( CompareToken( ".BOARD_OUTLINE", token ) )
+        {
+            if( aBoardState != IDF3::FILE_HEADER )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: no HEADER section\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !olnBoard.ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    olnBoard.AddComment( *its );
+                    ++its;
+                }
+            }
+
+            aBoardState = IDF3::FILE_OUTLINE;
+            return true;
+        }
+
+        if( CompareToken( ".PANEL_OUTLINE", token ) )
+        {
+            ERROR;
+            cerr << "PANEL_OUTLINE not supported\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( CompareToken( ".OTHER_OUTLINE", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .OTHER_OUTLINE\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            OTHER_OUTLINE* op = new OTHER_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create OTHER_OUTLINE object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the OTHER_OUTLINE section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            if( olnOther.insert( pair<string, OTHER_OUTLINE*>(op->GetOutlineIdentifier(), op) ).second == false )
+            {
+                ERROR;
+                cerr << "* Violation of specification. Non-unique ID in OTHER_OUTLINE '";
+                cerr << op->GetOutlineIdentifier() << "'\n";
+                delete op;
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            return true;
+        }
+
+        if( CompareToken( ".ROUTE_OUTLINE", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_OUTLINE\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            ROUTE_OUTLINE* op = new ROUTE_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create ROUTE_OUTLINE object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the ROUTE_OUTLINE section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            olnRoute.push_back( op );
+
+            return true;
+        }
+
+        if( CompareToken( ".PLACE_OUTLINE", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_OUTLINE\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            PLACE_OUTLINE* op = new PLACE_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create PLACE_OUTLINE object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the PLACE_OUTLINE section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            olnPlace.push_back( op );
+
+            return true;
+        }
+
+        if( CompareToken( ".ROUTE_KEEPOUT", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_KEEPOUT\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            ROUTE_KO_OUTLINE* op = new ROUTE_KO_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create ROUTE_KEEPOUT object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the ROUTE_KEEPOUT section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            olnRouteKeepout.push_back( op );
+
+            return true;
+        }
+
+        if( CompareToken( ".VIA_KEEPOUT", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .VIA_KEEPOUT\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            VIA_KO_OUTLINE* op = new VIA_KO_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create VIA_KEEPOUT object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the VIA_KEEPOUT section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            olnViaKeepout.push_back( op );
+
+            return true;
+        }
+
+        if( CompareToken( ".PLACE_KEEPOUT", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_KEEPOUT\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            PLACE_KO_OUTLINE* op = new PLACE_KO_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create PLACE_KEEPOUT object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the PLACE_KEEPOUT section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            olnPlaceKeepout.push_back( op );
+
+            return true;
+        }
+
+        if( CompareToken( ".PLACE_REGION", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_REGION\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            GROUP_OUTLINE* op = new GROUP_OUTLINE;
+
+            if( op == NULL )
+            {
+                ERROR;
+                cerr << "could not create PLACE_REGION object\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            op->SetUnit( unit );
+
+            if( !op->ReadData( aBoardFile, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading the PLACE_REGION section\n";
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    op->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            if( olnGroup.insert( pair<string, GROUP_OUTLINE*>(op->GetGroupName(), op) ).second == false )
+            {
+                ERROR;
+                cerr << "* Violation of specification. Non-unique ID in PLACE_REGION '";
+                cerr << op->GetGroupName() << "'\n";
+                delete op;
+                aBoardState = IDF3::FILE_ERROR;
+                return false;
+            }
+
+            return true;
+        }
+
+        if( CompareToken( ".DRILLED_HOLES", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .DRILLED_HOLES\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !ReadBrdDrills( aBoardFile, aBoardState ) )
+            {
+                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
+                {
+                    ERROR << "could not read board DRILLED HOLES section\n";
+                    return false;
+                }
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    drillComments.push_back( *its );
+                    ++its;
+                }
+            }
+
+            return true;
+        }
+
+        if( CompareToken( ".NOTES", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .NOTES\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !ReadBrdNotes( aBoardFile, aBoardState ) )
+            {
+                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
+                {
+                    ERROR << "could not read board NOTES section\n";
+                    return false;
+                }
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    noteComments.push_back( *its );
+                    ++its;
+                }
+            }
+
+            return true;
+        }
+
+        if( CompareToken( ".PLACEMENT", token ) )
+        {
+            if( aBoardState != IDF3::FILE_OUTLINE )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 file\n";
+                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACEMENT\n";
+                aBoardState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !ReadBrdPlacement( aBoardFile, aBoardState ) )
+            {
+                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
+                {
+                    ERROR << "could not read board PLACEMENT section\n";
+                    return false;
+                }
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    placeComments.push_back( *its );
+                    ++its;
+                }
+            }
+
+            return true;
+        }
+    }   // while( aBoardFile.good()
+
+    if( !aBoardFile.good() )
+    {
+        if( !aBoardFile.eof() || aBoardState < IDF3::FILE_OUTLINE || aBoardState >= IDF3::FILE_INVALID )
+        {
+            ERROR;
+            cerr << "problems reading board section\n";
+            aBoardState = IDF3::FILE_INVALID;
+            return false;
+        }
+    }
+
+    return true;
+}   // ReadBrdSection()
+
+
+// read the board file data
+bool IDF3_BOARD::ReadBoardFile( const std::string& aFileName )
+{
+    std::ifstream brd;
+
+    brd.open( aFileName.c_str(), std::ios_base::in );
+
+    if( !brd.is_open() )
+    {
+        ERROR;
+        cerr << "could not open file: '" << aFileName << "'\n";
+        return false;
+    }
+
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    IDF3::FILE_STATE state = IDF3::FILE_START;
+
+    // note: as per IDFv3 specification:
+    //      "The Header section must be the first section in the file, the second
+    //       section must be the Outline section, and the last section must be the
+    //       Placement section. All other sections may be in any order."
+
+    // further notes: Except for the HEADER section, sections may be preceeded by
+    // comment lines which will be copied back out on write(). No comments may
+    // be associated with the board file itself since the only logical location
+    // for unambiguous association is at the end of the file, which is inconvenient
+    // for large files.
+
+    if( !ReadBrdHeader( brd, state ) )
+    {
+        ERROR;
+        cerr << "could not find a valid header\n";
+        brd.close();
+        return false;
+    }
+
+    // read the various sections
+    while( ReadBrdSection( brd, state ) && state != IDF3::FILE_PLACEMENT );
+
+    if( state == IDF3::FILE_INVALID )
+    {
+        brd.close();
+        ERROR;
+        cerr << "problems reading file: '" << aFileName << "'\n";
+        return false;
+    }
+
+    if( !brd.good() )
+    {
+        // check if we have valid data
+        if( brd.eof() && state >= IDF3::FILE_OUTLINE && state < IDF3::FILE_INVALID )
+        {
+            brd.close();
+            return true;
+        }
+
+        brd.close();
+        ERROR;
+        cerr << "problems reading file: '" << aFileName << "'\n";
+        return false;
+    }
+
+    if( brd.good() && state == IDF3::FILE_PLACEMENT )
+    {
+        // read in any trailing lines and report on ignored comments (minor fault)
+        // and any non-comment item (non-compliance with IDFv3)
+        while( !FetchIDFLine( brd, iline, isComment, pos ) && brd.good() )
+        {
+            if( isComment )
+            {
+                ERROR << "[warning]: trailing comments after PLACEMENT\n";
+            }
+            else
+            {
+                ERROR << "invalid IDF3 file\n";
+                cerr << "* Violation of specification: non-comment lines after PLACEMENT section\n";
+                Clear();
+                brd.close();
+                return false;
+            }
+        }
+    }
+
+    brd.close();
+    return true;
+}
+
+
+// read the library sections (outlines)
+bool IDF3_BOARD::ReadLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard )
+{
+    if( aBoard == NULL )
+    {
+        ERROR << "BUG: invoked with NULL reference aBoard\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    std::list< std::string > comments;  // comments associated with a section
+
+    // Reads in .ELECTRICAL, .MECHANICAL or #COMMENTS
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+    IDF3_COMP_OUTLINE *pout = new IDF3_COMP_OUTLINE;
+
+    while( aLibFile.good() )
+    {
+        while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
+
+        if( !aLibFile.good() )
+        {
+            if( aLibFile.eof() )
+                return true;
+
+            ERROR;
+            cerr << "problems reading library section\n";
+            aLibState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( isComment )
+        {
+            comments.push_back( iline );
+            continue;
+        }
+
+        // This must be a header
+        if( !GetIDFString( iline, token, quoted, idx ) )
+        {
+            ERROR;
+            cerr << "problems reading library section\n";
+            aLibState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( quoted )
+        {
+            ERROR;
+            cerr << "invalid IDFv3 library\n";
+            cerr << "* Violation of specification: quoted string where .ELECTRICAL or .MECHANICAL expected\n";
+            aLibState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+        if( CompareToken( ".ELECTRICAL", token ) || CompareToken( ".MECHANICAL", token ) )
+        {
+            if( !pout->ReadData( aLibFile, token ) )
+            {
+                ERROR;
+                cerr << "invalid IDFv3 library [faulty section]\n";
+                aLibState = IDF3::FILE_INVALID;
+                return false;
+            }
+
+            if( !comments.empty() )
+            {
+                std::list<std::string>::iterator its = comments.begin();
+                std::list<std::string>::iterator ite = comments.end();
+
+                while( its != ite )
+                {
+                    pout->AddComment( *its );
+                    ++its;
+                }
+            }
+
+            IDF3_COMP_OUTLINE* cop = aBoard->GetComponentOutline( pout->GetUID() );
+
+            if( cop == NULL )
+            {
+                compOutlines.insert( pair<const std::string, IDF3_COMP_OUTLINE*>( pout->GetUID(), pout ) );
+            }
+            else
+            {
+                ERROR;
+                cerr << "duplicate Component Outline: '" << pout->GetUID() << "'\n";
+                delete pout;
+            }
+
+            return true;
+        }
+        else
+        {
+            ERROR;
+            cerr << "invalid IDFv3 library\n";
+            cerr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << token << "'\n";
+            aLibState = IDF3::FILE_INVALID;
+            return false;
+        }
+
+    }
+
+    ERROR;
+    cerr << "problems reading library section\n";
+    aLibState = IDF3::FILE_INVALID;
+    return false;
+}
+
+
+// read the library HEADER
+bool IDF3_BOARD::ReadLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState )
+{
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+    int idx = 0;
+    bool quoted = false;
+    std::string token;
+
+    // RECORD 1: ".HEADER" must be the very first line
+    while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
+
+    if( !aLibFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading library header\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: first line must be .HEADER\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( ".HEADER", iline ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: first line must be .HEADER and have no quotes or trailing text\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // RECORD 2:
+    //      File Type [str]: LIBRARY_FILE
+    //      IDF Version Number [float]: must be 3.0
+    //      Source System [str]: ignored
+    //      Date [str]: ignored
+    //      Library File Version [int]: ignored
+    while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
+
+    if( !aLibFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading library header, RECORD 2\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: comment within .HEADER section\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    idx = 0;
+    GetIDFString( iline, token, quoted, idx );
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: File Type in HEADER section must not be in quotes\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( "LIBRARY_FILE", token ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Expecting string: LIBRARY_FILE (got '" << token << "')\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2: no FIELD 2\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: IDF Version must not be in quotes\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( token.compare( "3.0" ) && token.compare( "3." ) && token.compare( "3" ) )
+    {
+        ERROR;
+        cerr << "unsupported IDF library version\n";
+        cerr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 3: no Source System string\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 4: no Date string\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !GetIDFString( iline, token, quoted, idx ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 5: no Board File Version number\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( quoted )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: HEADER section, RECORD 2, FIELD 5: Library File Version must not be in quotes\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    // RECORD 3:
+    //      .END_HEADER
+    while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
+
+    if( !aLibFile.good() )
+    {
+        ERROR;
+        cerr << "problems reading library header, RECORD 3\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( isComment )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 library\n";
+        cerr << "* Violation of specification: comment within .HEADER section\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    if( !CompareToken( ".END_HEADER", iline ) )
+    {
+        ERROR;
+        cerr << "invalid IDFv3 header\n";
+        cerr << "* Violation of specification: expected .END_HEADER (got '" << iline << "')\n";
+        aLibState = IDF3::FILE_INVALID;
+        return false;
+    }
+
+    aLibState = IDF3::FILE_HEADER;
+    return true;
+}
+
+
+// read the library file data
+bool IDF3_BOARD::ReadLibFile( const std::string& aFileName )
+{
+    std::ifstream lib;
+
+    lib.open( aFileName.c_str(), std::ios_base::in );
+
+    if( !lib.is_open() )
+    {
+        ERROR;
+        cerr << "could not open file: '" << aFileName << "'\n";
+        return false;
+    }
+
+    IDF3::FILE_STATE state = IDF3::FILE_START;
+
+    if( !ReadLibHeader( lib, state ) )
+    {
+        ERROR;
+        cerr << "[IDF library] could not find a valid header\n";
+        lib.close();
+        return false;
+    }
+
+    // read the library sections
+    while( ReadLibSection( lib, state, this ) && lib.good() );
+
+    if( state <= IDF3::FILE_START || state >= IDF3::FILE_INVALID )
+    {
+        lib.close();
+        ERROR;
+        cerr << "problems reading file: '" << aFileName << "'\n";
+        return false;
+    }
+
+    lib.close();
+    return true;
+}
+
+
+bool IDF3_BOARD::ReadFile( const wxString& aFullFileName )
+{
+    // 1. Check that the file extension is 'emn'
+    // 2. Check if a file with extension 'emp' exists and read it
+    // 3. Open the specified filename and read it
+
+    std::string fname = TO_UTF8( aFullFileName );
+
+    wxFileName brdname( aFullFileName );
+    wxFileName libname( aFullFileName );
+
+    brdname.SetExt( wxT( "emn" ) );
+    libname.SetExt( wxT( "emp" ) );
+
+    std::string bfname = TO_UTF8( aFullFileName );
+
+    if( !brdname.IsOk() )
+    {
+        ERROR;
+        cerr << "invalid file name: '" << bfname << "'\n";
+        return false;
+    }
+
+    if( !brdname.IsOk() )
+    {
+        ERROR;
+        cerr << "invalid file name: '" << bfname << "'\n";
+        return false;
+    }
+
+    if( !brdname.FileExists() )
+    {
+        ERROR;
+        cerr << "no such file: '" << bfname  << "'\n";
+        return false;
+    }
+
+    if( !brdname.IsFileReadable() )
+    {
+        ERROR;
+        cerr << "cannot read file: '" << bfname << "'\n";
+        return false;
+    }
+
+    bfname = TO_UTF8( brdname.GetFullPath() );
+    std::string lfname = TO_UTF8( libname.GetFullPath() );
+
+    if( !libname.FileExists() )
+    {
+        ERROR;
+        cerr << "no associated library file (*.emp)\n";
+    }
+    else if( !libname.IsFileReadable() )
+    {
+        ERROR;
+        cerr << "cannot read library file: '" << lfname << "'\n";
+    }
+    else
+    {
+        // read the library file before proceeding
+        if( !ReadLibFile( lfname ) )
+        {
+            ERROR;
+            cerr << "problems reading library file: '" << lfname << "'\n";
+            return false;
+        }
+    }
+
+    // read the board file
+    if( !ReadBoardFile( bfname ) )
+    {
+        Clear();
+        ERROR;
+        cerr << "problems reading board file: '" << lfname << "'\n";
+        return false;
+    }
+
+    return true;
+}
+
+
+bool IDF3_BOARD::WriteFile( const wxString& aFullFileName, bool aUnitMM, bool aForceUnitFlag )
+{
+    if( aUnitMM )
+        SetUnit( IDF3::UNIT_MM, aForceUnitFlag );
+    else
+        SetUnit( IDF3::UNIT_THOU, aForceUnitFlag );
+
+#warning TO BE IMPLEMENTED
+    /*
+     * 1. Check that the file extension is 'emn'
+     * 2. Write the *.emn file according to the IDFv3 spec
+     * 3. Write the *.emp file according to the IDFv3 spec
+     */
+    return false;
+}
+
+
+double IDF3_BOARD::GetUserScale( void )
+{
+    return userScale;
+}
+
+
+bool IDF3_BOARD::SetUserScale( double aScaleFactor )
+{
+    if( aScaleFactor <= 0.0 )
+    {
+        ERROR << "user scale factor must be > 0\n";
+        return false;
+    }
+
+    userScale = aScaleFactor;
+    return true;
+}
+
+
+void IDF3_BOARD::GetUserOffset( double& aXoff, double& aYoff )
+{
+    aXoff = userXoff;
+    aYoff = userYoff;
+    return;
+}
+
+
+void IDF3_BOARD::SetUserOffset( double aXoff, double aYoff )
+{
+    userXoff = aXoff;
+    userYoff = aYoff;
+    return;
+}
+
+
+bool IDF3_BOARD::AddBoardOutline( IDF_OUTLINE* aOutline )
+{
+    return olnBoard.AddOutline( aOutline );
+}
+
+
+bool IDF3_BOARD::DelBoardOutline( IDF_OUTLINE* aOutline )
+{
+    return olnBoard.DelOutline( aOutline );
+}
+
+
+bool IDF3_BOARD::DelBoardOutline( size_t aIndex )
+{
+    return olnBoard.DelOutline( aIndex );
+}
+
+
+size_t IDF3_BOARD::GetBoardOutlinesSize( void )
+{
+    return olnBoard.OutlinesSize();
+}
+
+
+IDF_OUTLINE* IDF3_BOARD::GetBoardOutline( void )
+{
+    return olnBoard.GetOutline( 0 );
+}
+
+
+std::list< IDF_OUTLINE* >& IDF3_BOARD::GetBoardOutlines( void )
+{
+    return olnBoard.GetOutlines();
+}
+
+
+IDF_DRILL_DATA* IDF3_BOARD::AddBoardDrill( double aDia, double aXpos, double aYpos,
+                                   IDF3::KEY_PLATING aPlating,
+                                   const std::string aHoleType,
+                                   IDF3::KEY_OWNER aOwner )
+{
+    IDF_DRILL_DATA* drill = new IDF_DRILL_DATA( aDia, aXpos, aYpos, aPlating,
+                                                "BOARD", aHoleType, aOwner );
+
+    if( drill != NULL )
+        board_drills.push_back( drill );
+
+    return drill;
+}
+
+IDF_DRILL_DATA* IDF3_BOARD::AddDrill( IDF_DRILL_DATA* aDrilledHole )
+{
+    if( !aDrilledHole )
+        return NULL;
+
+    if( CompareToken( "PANEL", aDrilledHole->GetDrillRefDes() ) )
+    {
+        ERROR;
+        cerr << "\n*BUG: PANEL drilled holes are not supported\n";
+        return NULL;
+    }
+
+    if( CompareToken( "BOARD", aDrilledHole->GetDrillRefDes() ) )
+    {
+        board_drills.push_back( aDrilledHole );
+        return aDrilledHole;
+    }
+
+    return AddCompDrill( aDrilledHole );
+}
+
+
+bool IDF3_BOARD::DelBoardDrill( double aDia, double aXpos, double aYpos )
+{
+    std::list<IDF_DRILL_DATA*>::iterator sp = board_drills.begin();
+    std::list<IDF_DRILL_DATA*>::iterator ep = board_drills.end();
+    bool rval = false;
+
+    while( sp != ep )
+    {
+        if( (*sp)->Matches( aDia, aXpos, aYpos ) )
+        {
+            rval = true;
+            delete *sp;
+            sp = board_drills.erase( sp );
+            continue;
+        }
+        ++sp;
+    }
+
+    return rval;
+}
+
+
+// a slot is a deficient representation of a kicad slotted hole;
+// it is usually associated with a component but IDFv3 does not
+// provide for such an association.
+bool IDF3_BOARD::AddSlot( double aWidth, double aLength, double aOrientation, double aX, double aY )
+{
+    if( aWidth < IDF_MIN_DIA_MM )
+        return true;
+
+    IDF_POINT c[2];     // centers
+    IDF_POINT pt[4];
+
+    // make sure the user isn't giving us dud information
+    if( aLength < aWidth )
+        std::swap( aLength, aWidth );
+
+    if( aLength == aWidth )
+    {
+        ERROR;
+        cerr << "length == width (" << aWidth << ")\n";
+        return false;
+    }
+
+    double a1 = aOrientation / 180.0 * M_PI;
+    double a2 = a1 + M_PI2;
+    double d1 = aLength / 2.0;
+    double d2 = aWidth / 2.0;
+    double sa1 = sin( a1 );
+    double ca1 = cos( a1 );
+    double dsa2 = d2 * sin( a2 );
+    double dca2 = d2 * cos( a2 );
+
+    c[0].x  = aX + d1 * ca1;
+    c[0].y  = aY + d1 * sa1;
+
+    c[1].x  = aX - d1 * ca1;
+    c[1].y  = aY - d1 * sa1;
+
+    pt[0].x = c[0].x - dca2;
+    pt[0].y = c[0].y - dsa2;
+
+    pt[1].x = c[1].x - dca2;
+    pt[1].y = c[1].y - dsa2;
+
+    pt[2].x = c[1].x + dca2;
+    pt[2].y = c[1].y + dsa2;
+
+    pt[3].x = c[0].x + dca2;
+    pt[3].y = c[0].y + dsa2;
+
+    IDF_OUTLINE* outline = new IDF_OUTLINE;
+
+    if( outline == NULL )
+    {
+        ERROR;
+        cerr << "could not create an outline object\n";
+        return false;
+    }
+
+    // first straight run
+    IDF_SEGMENT* seg = new IDF_SEGMENT( pt[0], pt[1] );
+    outline->push( seg );
+    // first 180 degree cap
+    seg = new IDF_SEGMENT( c[1], pt[1], -180.0, true );
+    outline->push( seg );
+    // final straight run
+    seg = new IDF_SEGMENT( pt[2], pt[3] );
+    outline->push( seg );
+    // final 180 degree cap
+    seg = new IDF_SEGMENT( c[0], pt[3], -180.0, true );
+    outline->push( seg );
+
+    return AddBoardOutline( outline );
+}
+
+
+IDF_DRILL_DATA* IDF3_BOARD::AddCompDrill( double aDia, double aXpos, double aYpos,
+                                  IDF3::KEY_PLATING aPlating,
+                                  const std::string aHoleType,
+                                  IDF3::KEY_OWNER aOwner,
+                                  const std::string& aRefDes )
+{
+    // first find the matching component; if it doesn't exist we must create it somehow -
+    // question is, do we need a component outline at this stage or can those be added later?
+    //
+    // Presumably we can create a component with no outline and add the outlines later.
+    // If a component is created and an outline specified but the outline is not loaded,
+    // we're screwed if (a) we have already read the library file (*.emp) or (b) we don't
+    // know the filename
+
+    std::string refdes = aRefDes;
+
+    // note: for components 'NOREFDES' would be assigned a Unique ID, but for holes
+    // there is no way of associating the hole with the correct entity (if any)
+    // so a hole added with "NOREFDES" goes to a generic component "NOREFDES"
+    if( refdes.empty() )
+        refdes = "NOREFDES";
+
+    // check if the target is BOARD or PANEL
+    if( CompareToken( "BOARD", refdes ) )
+        return AddBoardDrill( aDia, aXpos, aYpos, aPlating, aHoleType, aOwner );
+
+    if( CompareToken( "PANEL", refdes ) )
+    {
+        ERROR;
+        cerr << "PANEL data not supported\n";
+        return NULL;
+    }
+
+    std::map<std::string, IDF3_COMPONENT*>::iterator ref = components.find( refdes );
+
+    if( ref == components.end() )
+    {
+        // create the item
+        IDF3_COMPONENT* comp = new IDF3_COMPONENT( this );
+
+        if( comp == NULL )
+        {
+            ERROR;
+            cerr << "could not create new component object\n";
+            return NULL;
+        }
+
+        comp->SetParent( this );
+        comp->SetRefDes( refdes );
+        ref = components.insert( std::pair< std::string, IDF3_COMPONENT*> ( comp->GetRefDes(), comp ) ).first;
+    }
+
+    // add the drill
+    return ref->second->AddDrill( aDia, aXpos, aYpos, aPlating, aHoleType, aOwner );
+}
+
+
+IDF_DRILL_DATA* IDF3_BOARD::AddCompDrill( IDF_DRILL_DATA* aDrilledHole )
+{
+    if( !aDrilledHole )
+        return NULL;
+
+    if( CompareToken( "PANEL", aDrilledHole->GetDrillRefDes() ) )
+    {
+        ERROR;
+        cerr << "PANEL data not supported\n";
+        return NULL;
+    }
+
+    std::map<std::string, IDF3_COMPONENT*>::iterator ref = components.find( aDrilledHole->GetDrillRefDes() );
+
+    if( ref == components.end() )
+    {
+        // create the item
+        IDF3_COMPONENT* comp = new IDF3_COMPONENT( this );
+
+        if( comp == NULL )
+        {
+            ERROR;
+            cerr << "could not create new component object\n";
+            return NULL;
+        }
+
+        comp->SetParent( this );
+        comp->SetRefDes( aDrilledHole->GetDrillRefDes() );
+        ref = components.insert( std::pair< std::string, IDF3_COMPONENT*> ( comp->GetRefDes(), comp ) ).first;
+    }
+
+    // add the drill
+    return ref->second->AddDrill( aDrilledHole );
+}
+
+
+bool IDF3_BOARD::DelCompDrill( double aDia, double aXpos, double aYpos, std::string aRefDes )
+{
+    std::map<std::string, IDF3_COMPONENT*>::iterator ref = components.find( aRefDes );
+
+    if( ref == components.end() )
+        return false;
+
+    return ref->second->DelDrill( aDia, aXpos, aYpos );
+}
+
+
+bool IDF3_BOARD::AddComponent( IDF3_COMPONENT* aComponent )
+{
+    if( !aComponent )
+    {
+        ERROR << "Invalid component pointer (NULL)\n";
+        return false;
+    }
+
+    if( components.insert( std::pair<std::string, IDF3_COMPONENT*>
+        ( aComponent->GetRefDes(), aComponent ) ).second == false )
+    {
+        ERROR << "Duplicate RefDes ('" << aComponent->GetRefDes() << "')\n";
+        return false;
+    }
+
+    return true;
+}
+
+
+bool IDF3_BOARD::DelComponent( IDF3_COMPONENT* aComponent )
+{
+    if( !aComponent )
+    {
+        ERROR << "Invalid component pointer (NULL)\n";
+        return false;
+    }
+
+    std::map<std::string, IDF3_COMPONENT*>::iterator it =
+        components.find( aComponent->GetRefDes() );
+
+    if( it == components.end() )
+        return false;
+
+    delete it->second;
+    components.erase( it );
+
+    return true;
+}
+
+
+bool IDF3_BOARD::DelComponent( size_t aIndex )
+{
+    if( aIndex >= components.size() )
+    {
+        ERROR << "index (" << aIndex << ") >= components size ("
+            << components.size() << ")\n";
+            return false;
+    }
+
+    std::map<std::string, IDF3_COMPONENT*>::iterator it = components.begin();
+
+    while( aIndex-- > 0 ) ++it;
+
+    delete it->second;
+    components.erase( it );
+
+    return false;
+}
+
+
+size_t IDF3_BOARD::GetComponentsSize( void )
+{
+    return components.size();
+}
+
+
+std::map< std::string, IDF3_COMPONENT* >& IDF3_BOARD::GetComponents( void )
+{
+    return components;
+}
+
+
+IDF3_COMPONENT* IDF3_BOARD::FindComponent( std::string aRefDes )
+{
+    std::map<std::string, IDF3_COMPONENT*>::iterator it = components.find( aRefDes );
+
+    if( it == components.end() )
+        return NULL;
+
+    return it->second;
+}
+
+
+// returns a pointer to a component outline object or NULL
+// if the object doesn't exist
+IDF3_COMP_OUTLINE* IDF3_BOARD::GetComponentOutline( const std::string aGeomName,
+                                                    const std::string aPartName,
+                                                    wxString aFullFileName )
+{
+    std::ostringstream ostr;
+    ostr << aGeomName << "_" << aPartName;
+
+    IDF3_COMP_OUTLINE* cp = GetComponentOutline( ostr.str() );
+
+    if( cp != NULL )
+        return cp;
+
+    std::string fname = TO_UTF8( aFullFileName );
+
+    cp = new IDF3_COMP_OUTLINE;
+
+    if( cp == NULL )
+    {
+        ERROR;
+        cerr << "failed to create outline with UID '" << aGeomName << "_";
+        cerr << aPartName << "'\n";
+        cerr << "* filename: '" << fname << "'\n";
+        return NULL;
+    }
+
+    wxFileName idflib( aFullFileName );
+
+    if( !idflib.IsOk() )
+    {
+        ERROR;
+        cerr << "invalid file name: '" << fname << "'\n";
+        delete cp;
+        return NULL;
+    }
+
+    if( !idflib.FileExists() )
+    {
+        ERROR;
+        cerr << "no such file: '" << fname  << "'\n";
+        delete cp;
+        return NULL;
+    }
+
+    if( !idflib.IsFileReadable() )
+    {
+        ERROR;
+        cerr << "cannot read file: '" << fname << "'\n";
+        delete cp;
+        return NULL;
+    }
+
+    std::ifstream model;
+
+    model.open( fname.c_str(), std::ios_base::in );
+
+    if( !model.is_open() )
+    {
+        ERROR;
+        cerr << "could not open file: '" << fname << "'\n";
+        delete cp;
+        return NULL;
+    }
+
+    std::string iline;      // the input line
+    bool isComment;         // true if a line just read in is a comment line
+    std::streampos pos;
+
+    while( true )
+    {
+        while( !FetchIDFLine( model, iline, isComment, pos ) && model.good() );
+
+        if( !model.good() )
+        {
+            ERROR;
+            cerr << "problems reading file: '" << fname << "'\n";
+            delete cp;
+            model.close();
+            return NULL;
+        }
+
+        // accept comment lines, .ELECTRICAL, or .MECHANICAL only
+        if( isComment )
+        {
+            cp->AddComment( iline );
+            continue;
+        }
+
+        if( CompareToken( ".ELECTRICAL", iline ) || CompareToken( ".MECHANICAL", iline ) )
+        {
+            if( !cp->ReadData( model, iline ) )
+            {
+                ERROR;
+                cerr << "problems reading file: '" << fname << "'\n";
+                delete cp;
+                model.close();
+                return NULL;
+            }
+            else
+            {
+                break;
+            }
+        }
+        else
+        {
+            ERROR << "faulty IDF component definition\n";
+            cerr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << iline << "'\n";
+            cerr << "* File: '" << fname << "'\n";
+            delete cp;
+            model.close();
+            return NULL;
+        }
+    }   // while( true )
+
+    model.close();
+
+    return cp;
+}
+
+
+// returns a pointer to the component outline object with the
+// unique ID aComponentID
+IDF3_COMP_OUTLINE* IDF3_BOARD::GetComponentOutline( std::string aComponentID )
+{
+    std::map< std::string, IDF3_COMP_OUTLINE*>::iterator its = compOutlines.find( aComponentID );
+
+    if( its != compOutlines.end() )
+        return its->second;
+
+    return NULL;
+}
+
+
+// returns a pointer to the outline which is substituted
+// whenever a true outline cannot be found or is defective
+IDF3_COMP_OUTLINE* IDF3_BOARD::GetInvalidOutline( const std::string& aGeomName, const std::string& aPartName )
+{
+    std::string uid;
+    bool empty = false;
+
+    if( aGeomName.empty() && aPartName.empty() )
+    {
+        uid = "NOGEOM_NOPART";
+        empty = true;
+    }
+    else
+    {
+        uid = aGeomName + "_" + aPartName;
+    }
+
+    IDF3_COMP_OUTLINE* cp = GetComponentOutline( uid );
+
+    if( cp != NULL )
+        return cp;
+
+    cp = new IDF3_COMP_OUTLINE;
+
+    if( cp == NULL )
+        return NULL;
+
+    if( empty )
+        cp->CreateDefaultOutline( "", "" );
+    else
+        cp->CreateDefaultOutline( aGeomName, aPartName );
+
+    compOutlines.insert( pair<const std::string, IDF3_COMP_OUTLINE*>(cp->GetUID(), cp) );
+
+    return cp;
+}
+
+
+// clears all data
+void IDF3_BOARD::Clear( void )
+{
+    // delete comment lists
+    noteComments.clear();
+    drillComments.clear();
+    placeComments.clear();
+
+    // delete notes
+    while( !notes.empty() )
+    {
+        delete notes.front();
+        notes.pop_front();
+    }
+
+    // delete drill list
+    do
+    {
+        std::list<IDF_DRILL_DATA*>::iterator ds = board_drills.begin();
+        std::list<IDF_DRILL_DATA*>::iterator de = board_drills.end();
+
+        while( ds != de )
+        {
+            delete *ds;
+            ++ds;
+        }
+
+        board_drills.clear();
+    } while(0);
+
+
+    // delete components
+    do
+    {
+        std::map<std::string, IDF3_COMPONENT*>::iterator cs = components.begin();
+        std::map<std::string, IDF3_COMPONENT*>::iterator ce = components.end();
+
+        while( cs != ce )
+        {
+            delete cs->second;
+            ++cs;
+        }
+
+        components.clear();
+    } while(0);
+
+
+    // delete component outlines
+    do
+    {
+        std::map<std::string, IDF3_COMP_OUTLINE*>::iterator cs = compOutlines.begin();
+        std::map<std::string, IDF3_COMP_OUTLINE*>::iterator ce = compOutlines.end();
+
+        while( cs != ce )
+        {
+            delete cs->second;
+            ++cs;
+        }
+
+        compOutlines.clear();
+    } while(0);
+
+
+    // delete OTHER outlines
+    do
+    {
+        std::map<std::string, OTHER_OUTLINE*>::iterator os = olnOther.begin();
+        std::map<std::string, OTHER_OUTLINE*>::iterator oe = olnOther.end();
+
+        while( os != oe )
+        {
+            delete os->second;
+            ++os;
+        }
+
+        olnOther.clear();
+    } while(0);
+
+
+    // delete ROUTE outlines
+    do
+    {
+        std::list<ROUTE_OUTLINE*>::iterator os = olnRoute.begin();
+        std::list<ROUTE_OUTLINE*>::iterator oe = olnRoute.end();
+
+        while( os != oe )
+        {
+            delete *os;
+            ++os;
+        }
+
+        olnRoute.clear();
+    } while(0);
+
+
+    // delete PLACE outlines
+    do
+    {
+        std::list<PLACE_OUTLINE*>::iterator os = olnPlace.begin();
+        std::list<PLACE_OUTLINE*>::iterator oe = olnPlace.end();
+
+        while( os != oe )
+        {
+            delete *os;
+            ++os;
+        }
+
+        olnPlace.clear();
+    } while(0);
+
+
+    // delete ROUTE KEEPOUT outlines
+    do
+    {
+        std::list<ROUTE_KO_OUTLINE*>::iterator os = olnRouteKeepout.begin();
+        std::list<ROUTE_KO_OUTLINE*>::iterator oe = olnRouteKeepout.end();
+
+        while( os != oe )
+        {
+            delete *os;
+            ++os;
+        }
+
+        olnRouteKeepout.clear();
+    } while(0);
+
+
+    // delete VIA KEEPOUT outlines
+    do
+    {
+        std::list<VIA_KO_OUTLINE*>::iterator os = olnViaKeepout.begin();
+        std::list<VIA_KO_OUTLINE*>::iterator oe = olnViaKeepout.end();
+
+        while( os != oe )
+        {
+            delete *os;
+            ++os;
+        }
+
+        olnViaKeepout.clear();
+    } while(0);
+
+
+    // delete PLACEMENT KEEPOUT outlines
+    do
+    {
+        std::list<PLACE_KO_OUTLINE*>::iterator os = olnPlaceKeepout.begin();
+        std::list<PLACE_KO_OUTLINE*>::iterator oe = olnPlaceKeepout.end();
+
+        while( os != oe )
+        {
+            delete *os;
+            ++os;
+        }
+
+        olnPlaceKeepout.clear();
+    } while(0);
+
+
+    // delete PLACEMENT GROUP outlines
+    do
+    {
+        std::map<std::string, GROUP_OUTLINE*>::iterator os = olnGroup.begin();
+        std::map<std::string, GROUP_OUTLINE*>::iterator oe = olnGroup.end();
+
+        while( os != oe )
+        {
+            delete os->second;
+            ++os;
+        }
+
+        olnGroup.clear();
+    } while(0);
+
+    boardName.clear();
+    boardThickness = 1.6;
+
+    state     = FILE_START;
+    unit      = UNIT_MM;
+    userScale = 1.0;
+    userXoff  = 0.0;
+    userYoff  = 0.0;
+
+    return;
+}

=== added file 'utils/idftools/idf_parser.h'
--- utils/idftools/idf_parser.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/idf_parser.h	2014-05-15 23:47:14 +0000
@@ -0,0 +1,355 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+// NOTE:
+// 1. Due to the complexity of objects and the risk of accumulated
+// position errors, CAD packages should only delete or add complete
+// components. If a component being added already exists, it is
+// replaced by the new component IF and only if the CAD type is
+// permitted to make such changes.
+//
+// 2. Internally all units shall be in mm and by default we shall
+// write files with mm units. The internal flags mm/thou shall only
+// be used to translate data being read from or written to files.
+// This avoids the painful management of a mixture of mm and thou.
+// The API shall require all dimensions in mm; for people using any
+// other unit, it is their responsibility to perform the conversion
+// to mm. Conversion back to thou may incur small rounding errors.
+
+// BUGS:
+// 1. IDF compliance: On DELETE operations, ensure that the CAD
+//    has permission to make these deletions. This is no small task;
+//    however this compliance task can be deferred since it is not
+//    essential to the immediate needs of KiCad which are IDF
+//    export and IDF->VRML conversion
+
+#ifndef IDF_PARSER_H
+#define IDF_PARSER_H
+
+#include <idf_outlines.h>
+
+class IDF3_COMPONENT;
+
+class IDF3_COMP_OUTLINE_DATA
+{
+private:
+    double xoff;    // X offset from KiCad or X placement from IDF file
+    double yoff;    // Y offset from KiCad or Y placement from IDF file
+    double zoff;    // height offset (specified in IDFv3 spec, corresponds to KiCad Z offset)
+    double aoff;    // angular offset from KiCad or Rotation Angle from IDF file
+    // NOTE: For the KiCad representation to be equivalent to the IDF representation,
+    // the very first model listed must have KiCad X,Y and angular offsets of 0 since the
+    // first model listed will determine the XY/Angle position of an IDF3_COMPONENT and all
+    // other components are relative to that. Ideally *ALL* models will have XY/Angle offsets
+    // of 0; if not, there is always a danger that the order of models will be shuffled
+    // and the component would effectively change its location.
+    IDF3_COMP_OUTLINE* outline; // component outline to use
+    IDF3_COMPONENT* parent;     // associated component
+
+public:
+    IDF3_COMP_OUTLINE_DATA();
+    IDF3_COMP_OUTLINE_DATA( IDF3_COMPONENT* aParent, IDF3_COMP_OUTLINE* aOutline );
+    IDF3_COMP_OUTLINE_DATA( IDF3_COMPONENT* aParent, IDF3_COMP_OUTLINE* aOutline,
+                            double aXoff, double aYoff, double aZoff, double aAoff );
+    ~IDF3_COMP_OUTLINE_DATA();
+
+    void SetOffsets( double aXoff, double aYoff, double aZoff, double aAngleOff );
+    void GetOffsets( double& aXoff, double& aYoff, double& aZoff, double& aAngleOff );
+
+    void SetParent( IDF3_COMPONENT* aParent );
+    void SetOutline( IDF3_COMP_OUTLINE* aOutline );
+
+    bool ReadPlaceData( std::ifstream &aBoardFile, IDF3::FILE_STATE& aBoardState,
+                        IDF3_BOARD *aBoard );
+
+    bool WritePlaceData( std::ofstream& aBoardFile, double aXpos, double aYpos, double aAngle,
+                         const std::string aRefDes, IDF3::IDF_PLACEMENT aPlacement,
+                         IDF3::IDF_LAYER aSide );
+};
+
+
+class IDF3_COMPONENT
+{
+private:
+    std::list< IDF3_COMP_OUTLINE_DATA* > components;
+    std::list< IDF_DRILL_DATA* > drills;
+
+    double xpos;
+    double ypos;
+    double angle;
+    IDF3::IDF_PLACEMENT placement;
+    IDF3::IDF_LAYER     layer;          // [TOP/BOTTOM ONLY as per IDF spec]
+    bool                hasPosition;    ///< True after SetPosition is called once
+    std::string         refdes;         ///< Reference Description (MUST BE UNIQUE)
+    // XXX: all "NOREFDES" must be internally
+    // converted to "NOREFDES_[NUMBER]" on READ
+    // and simply "NOREFDES" on WRITE.
+    IDF3_BOARD*         parent;
+
+public:
+    IDF3_COMPONENT();
+    IDF3_COMPONENT( IDF3_BOARD* aParent );
+    ~IDF3_COMPONENT();
+
+    void SetParent( IDF3_BOARD* aParent );
+
+    IDF3::CAD_TYPE GetCadType( void );
+
+    IDF3::IDF_UNIT GetUnit( void );
+
+    bool SetRefDes( const std::string& aRefDes );
+    const std::string& GetRefDes( void );
+
+    IDF_DRILL_DATA* AddDrill( double aDia, double aXpos, double aYpos,
+                              IDF3::KEY_PLATING aPlating,
+                              const std::string aHoleType,
+                              IDF3::KEY_OWNER aOwner );
+
+    IDF_DRILL_DATA* AddDrill( IDF_DRILL_DATA* aDrilledHole );
+
+    bool DelDrill( double aDia, double aXpos, double aYpos );
+    bool DelDrill( IDF_DRILL_DATA* aDrill );
+    std::list< IDF_DRILL_DATA* >& GetDrills( void );
+
+    bool AddOutlineData( IDF3_COMP_OUTLINE_DATA* aComponentOutline );
+    bool DeleteOutlineData( IDF3_COMP_OUTLINE_DATA* aComponentOutline );
+    bool DeleteOutlineData( size_t aIndex );
+    size_t GetOutlinesSize( void );
+    std::list< IDF3_COMP_OUTLINE_DATA* >& GetOutlinesData( void );
+
+    // return true if position was set; otherwise false
+    bool GetPosition( double& aXpos, double& aYpos, double& aAngle, IDF3::IDF_LAYER& aLayer );
+
+    // return true if the position was set
+    bool SetPosition( double aXpos, double aYpos, double aAngle, IDF3::IDF_LAYER aLayer );
+    //          Sets the absolute position; if a position
+    //          was previously set, all contained objects
+    //          are moved. If UNPLACED, set to PLACED.
+    //          CAD may vary PLACEMENT (almost) at will.
+
+    IDF3::IDF_PLACEMENT GetPlacement( void );
+    bool SetPlacement( IDF3::IDF_PLACEMENT aPlacementValue );
+
+    bool WriteDrillData( std::ofstream& aBoardFile );
+    bool WritePlaceData( std::ofstream& aBoardFile );
+};
+
+class IDF3_BOARD
+{
+private:
+
+    // XXX - can the board retain slots separately to work around the
+    // problem of no slotted holes in the IDF spec? Otherwise it would
+    // be extremely difficult for modules to move their slotted holes.
+    // Slots should be identified automatically and their centers calculated
+    // for reference.
+    std::list< IDF_NOTE* >     notes;                           // IDF notes
+    std::list< std::string >   noteComments;                    // comment list for NOTES section
+    std::list< std::string >   drillComments;                   // comment list for DRILL section
+    std::list< std::string >   placeComments;                   // comment list for PLACEMENT section
+    std::list<IDF_DRILL_DATA*> board_drills;
+    std::map< std::string, IDF3_COMPONENT*> components;         // drill and placement data for components
+    std::map< std::string, IDF3_COMP_OUTLINE*> compOutlines;    // component outlines (data for library file)
+    std::string boardName;
+    double boardThickness;
+    IDF3::FILE_STATE state;
+    IDF3::CAD_TYPE   cadType;
+    IDF3::IDF_UNIT   unit;
+    double userScale;       // user may store a scale for translating to arbitrary units
+    double userXoff;        // user may specify an arbitrary X/Y offset
+    double userYoff;
+
+    // main board outline and cutouts
+    BOARD_OUTLINE olnBoard;
+    // OTHER outlines
+    std::map<std::string, OTHER_OUTLINE*> olnOther;
+    // ROUTE outlines
+    std::list<ROUTE_OUTLINE*> olnRoute;
+    // PLACEMENT outlines
+    std::list<PLACE_OUTLINE*> olnPlace;
+    // ROUTE KEEPOUT outlines
+    std::list<ROUTE_KO_OUTLINE*> olnRouteKeepout;
+    // VIA KEEPOUT outlines
+    std::list<VIA_KO_OUTLINE*> olnViaKeepout;
+    // PLACE KEEPOUT outlines
+    std::list<PLACE_KO_OUTLINE*> olnPlaceKeepout;
+    // PLACEMENT GROUP outlines
+    std::map<std::string, GROUP_OUTLINE*> olnGroup;
+
+    // Set the unit; this can only be done internally upon
+    // reading a file or saving
+    bool SetUnit( IDF3::IDF_UNIT aUnit, bool convert = false );
+
+    IDF_DRILL_DATA* AddCompDrill( double aDia, double aXpos, double aYpos,
+                                  IDF3::KEY_PLATING aPlating,
+                                  const std::string aHoleType,
+                                  IDF3::KEY_OWNER aOwner,
+                                  const std::string& aRefDes );
+
+    IDF_DRILL_DATA* AddCompDrill( IDF_DRILL_DATA* aDrilledHole );
+
+    bool DelCompDrill( double aDia, double aXpos, double aYpos, std::string aRefDes );
+
+    // read the DRILLED HOLES section
+    bool ReadBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // read the NOTES section
+    bool ReadBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // read the component placement section
+    bool ReadBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // read the board HEADER
+    bool ReadBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // read individual board sections; pay attention to IDFv3 section specifications
+    bool ReadBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // read the board file data
+    bool ReadBoardFile( const std::string& aFileName );
+
+    // read the library sections (outlines)
+    bool ReadLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard );
+    // read the library HEADER
+    bool ReadLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState );
+    // read the library file data
+    bool ReadLibFile( const std::string& aFileName );
+
+public:
+    IDF3_BOARD( IDF3::CAD_TYPE aCadType );
+    virtual ~IDF3_BOARD();
+
+    IDF3::CAD_TYPE GetCadType( void );
+
+    // retrieve the nominal unit used in reading/writing
+    // data. This is primarily for use by owned objects
+    // and is only of informational use for the end user.
+    // Internally all data is represented in mm and the
+    // end user must use only mm in the API.
+    IDF3::IDF_UNIT GetUnit( void );
+
+    void SetBoardName( std::string aBoardName );
+    const std::string& GetBoardName( void );
+
+    bool SetBoardThickness( double aBoardThickness );
+    double GetBoardThickness( void );
+
+    bool ReadFile( const wxString& aFullFileName );
+    bool WriteFile( const wxString& aFullFileName, bool aUnitMM = true, bool aForceUnitFlag = false );
+
+    double GetUserScale( void );
+    bool SetUserScale( double aScaleFactor );
+
+    void GetUserOffset( double& aXoff, double& aYoff );
+    void SetUserOffset( double aXoff, double aYoff );
+
+    bool AddBoardOutline( IDF_OUTLINE* aOutline );
+    bool DelBoardOutline( IDF_OUTLINE* aOutline );
+    bool DelBoardOutline( size_t aIndex );
+    size_t GetBoardOutlinesSize( void );
+    IDF_OUTLINE* GetBoardOutline( void );
+    std::list< IDF_OUTLINE* >& GetBoardOutlines( void );
+
+    /// XXX - AddDrillComment
+    /// AddPlacementComment
+    /// GetDrillComments()
+    /// GetPlacementComments()
+    /// ClearDrillComments()
+    /// ClearPlacementComments()
+    /// AddNoteComment
+    /// GetNoteComments
+    /// AddNote
+
+    IDF_DRILL_DATA* AddBoardDrill( double aDia, double aXpos, double aYpos,
+                                   IDF3::KEY_PLATING aPlating,
+                                   const std::string aHoleType,
+                                   IDF3::KEY_OWNER aOwner );
+
+    IDF_DRILL_DATA* AddDrill( IDF_DRILL_DATA* aDrilledHole );
+
+    bool DelBoardDrill( double aDia, double aXpos, double aYpos );
+
+    // a slot is a deficient representation of a kicad slotted hole;
+    // it is usually associated with a component but IDFv3 does not
+    // provide for such an association.
+    bool AddSlot( double aWidth, double aLength, double aOrientation, double aX, double aY );
+
+    bool AddComponent( IDF3_COMPONENT* aComponent );
+    bool DelComponent( IDF3_COMPONENT* aComponent );
+    bool DelComponent( size_t aIndex );
+    size_t GetComponentsSize( void );
+    std::map< std::string, IDF3_COMPONENT* >& GetComponents( void );
+    IDF3_COMPONENT* FindComponent( std::string aRefDes );
+
+    // returns a pointer to a component outline object or NULL
+    // if the object doesn't exist
+    IDF3_COMP_OUTLINE* GetComponentOutline( const std::string aGeomName,
+                                            const std::string aPartName,
+                                            wxString aFullFileName );
+
+    // returns a pointer to the component outline object with the
+    // unique ID aComponentID
+    IDF3_COMP_OUTLINE* GetComponentOutline( std::string aComponentID );
+
+    // returns a pointer to the outline "NOGEOM NOPART" which is substituted
+    // whenever a true outline cannot be found or is defective
+    IDF3_COMP_OUTLINE* GetInvalidOutline( const std::string& aGeomName, const std::string& aPartName );
+
+    // clears all data
+    void Clear( void );
+};
+// BOARD contains:
+//      std::list<IDF_DRILL_DATA*> board_drills;      ///< IDF drill data for BOARD only (others must be in component)
+//      [ note: board outline needs an owner; also implement an internal OUTLINE_TYPE ]
+//      boardOutline: list of outlines (and cutouts) for the board
+//      board comment list (what appears before the header)
+
+//      [ note: various outline types below are derived classes and support different sets of attributes ]
+//      OTHER OUTLINE LISTS {with accompanying OWNER type} [outline + cutout] ( .OTHER_OUTLINE may be specified multiple times )
+//              + ATTR:
+//                  OutlineID (string, ensure UNIQUE within OTHER OUTLINE LIST)
+//                  Thickness (float)
+//                  board side (TOP/BOTTOM)
+//      ROUTING OUTLINE LISTS {w/ owner} [single outline only, 0/1] ( .ROUTE_OUTLINE may be specified multiple times )
+//              + ATTR:
+//                  Routing Layers: (TOP/BOTTOM/BOTH/INNER/ALL)
+//      PLACEMENT OUTLINE LISTS {w/ owner} [single outline only, 0/1]
+//              + ATTR:
+//                  board side (TOP/BOTTOM/BOTH)
+//                  height
+//      ROUTING_KEEPOUT LISTS {w/ owner} [single outline only, 0/1] ( may be specified multiple times )
+//              + ATTR:
+//                  routing layers: (TOP/BOTTOM/BOTH/INNER/ALL)
+//      VIA_KEEPOUT LISTS {w/ owner} [single outline only, 0/1] ( may be specified multiple times )
+//      PLACEMENT_KEEPOUT LISTS {w/ owner} [single outline only, 0/1] ( may be specified multiple times )
+//              + ATTR:
+//                  board side: (TOP/BOTTOM/BOTH)
+//                  keepout height (MAX COMPONENT HEIGHT): float
+//      PLACEMENT_GROUP LISTS {w/ owner} [single outline only, 0/1] ( may be specified multiple times )
+//              + ATTR:
+//                  board side: (TOP/BOTTOM/BOTH)
+//                  component group name: string (NO restrictions imposed)
+//      NOTES_SECTION LIST:
+//              (see spec for details)
+//      PLACEMENT SECTION: implied by COMPONENT LIST
+//
+//      NOTE AS PER SPEC: HEADER *MUST* be the first section, followed by OUTLINE,
+//          and PLACEMENT *MUST* be the last section. All other sections in
+//          between may be in *ANY* order.
+//
+#endif // IDF_PARSER_H

=== modified file 'utils/idftools/idf_rect.cpp'
--- utils/idftools/idf_rect.cpp	2014-02-05 09:27:21 +0000
+++ utils/idftools/idf_rect.cpp	2014-05-09 04:32:33 +0000
@@ -98,7 +98,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> width) && width >= 0.001 )
+
+        tstr >> width;
+        if( !tstr.fail() && width >= 0.001 )
             ok = true;
     }
 
@@ -112,7 +114,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> length) && length > 0.0 )
+
+        tstr >> length;
+        if( !tstr.fail() && length > 0.0 )
             ok = true;
     }
 
@@ -126,7 +130,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> height) && height >= 0.001 )
+
+        tstr >> height;
+        if( !tstr.fail() && height >= 0.001 )
             ok = true;
     }
 
@@ -140,7 +146,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> chamfer) && chamfer >= 0.0 )
+
+        tstr >> chamfer;
+        if( !tstr.fail() && chamfer >= 0.0 )
         {
             if( chamfer > width / 3.0 || chamfer > length / 3.0 )
                 cout << "* WARNING: chamfer must be <= MIN( width, length )/3\n";
@@ -182,7 +190,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> wireDia) && wireDia >= 0.001 )
+
+        tstr >> wireDia;
+        if( !tstr.fail() && wireDia >= 0.001 )
         {
             if( wireDia >= length )
                 cout << "* WARNING: wire diameter must be < length\n";
@@ -201,7 +211,9 @@
 
         tstr.clear();
         tstr.str( line );
-        if( (tstr >> pitch) && pitch >= 0.001 )
+
+        tstr >> pitch;
+        if( !tstr.fail() && pitch >= 0.001 )
         {
             if( pitch <= ( length + wireDia ) / 2.0 )
                 cout << "* WARNING: pitch must be > (length + wireDia)/2\n";

=== added file 'utils/idftools/test_idf2vrml.cpp'
--- utils/idftools/test_idf2vrml.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/test_idf2vrml.cpp	2014-05-15 06:51:51 +0000
@@ -0,0 +1,81 @@
+/*
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2014  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+/*
+ *  This program takes an IDF base name, loads the board outline
+ *  and component outine files, and prints out information to
+ *  verify correct operation of the IDF parser.
+ */
+
+#include <fctsys.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <cmath>
+#include <cstdio>
+#include <list>
+#include <utility>
+#include <clocale>
+#include <vector>
+#include <macros.h>
+#include <idf_common.h>
+#include <idf_parser.h>
+#include <vrml_board.h>
+
+using namespace std;
+
+#define CLEANUP do { \
+    setlocale( LC_ALL, "C" ); \
+    } while( 0 );
+
+int main( int argc, char **argv )
+{
+    // IDF implicitly requires the C locale
+    setlocale( LC_ALL, "C" );
+
+    if( argc != 2 )
+    {
+        if( argc < 2 )
+            cerr << "* No arguments passed on command line.\n";
+        else
+            cerr << "* Too many arguments passed on command line.\n";
+
+        cerr << "* Usage: testidf2vrml path/to/testfile\n";
+        CLEANUP;
+        return -1;
+    }
+
+    IDF3_BOARD pcb( IDF3::CAD_ELEC );
+
+    if( !pcb.ReadFile( FROM_UTF8( argv[1] ) ) )
+    {
+        CLEANUP;
+        cerr << "* Could not read file: " << argv[1] << "\n";
+        return -1;
+    }
+
+    // restore the locale
+    CLEANUP;
+    return 0;
+}

=== added file 'utils/idftools/vrml_board.cpp'
--- utils/idftools/vrml_board.cpp	1970-01-01 00:00:00 +0000
+++ utils/idftools/vrml_board.cpp	2014-04-08 07:49:38 +0000
@@ -0,0 +1,1501 @@
+/*
+ * file: vrml_board.cpp
+ *
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2013  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+/*
+ * NOTES ON OUTPUT PRECISION:
+ *
+ * If we use %.6f then we have no need for special unit dependent formatting:
+ *
+ *  inch: .0254 microns
+ *  mm:   0.001 microns
+ *  m:    1 micron
+ *
+ */
+
+
+#include <sstream>
+#include <string>
+#include <iomanip>
+#include <cmath>
+#include <fctsys.h>
+#include <vrml_board.h>
+
+#ifndef CALLBACK
+#define CALLBACK
+#endif
+
+#define GLCALLBACK(x) (( void (CALLBACK*)() )&(x))
+
+void FormatDoublet( double x, double y, int precision, std::string& strx, std::string& stry )
+{
+    std::ostringstream ostr;
+
+    ostr << std::fixed << std::setprecision( precision );
+
+    ostr << x;
+    strx = ostr.str();
+
+    ostr.str( "" );
+    ostr << y;
+    stry = ostr.str();
+
+    while( *strx.rbegin() == '0' )
+        strx.erase( strx.size() - 1 );
+
+    while( *stry.rbegin() == '0' )
+        stry.erase( stry.size() - 1 );
+}
+
+
+void FormatSinglet( double x, int precision, std::string& strx )
+{
+    std::ostringstream ostr;
+
+    ostr << std::fixed << std::setprecision( precision );
+
+    ostr << x;
+    strx = ostr.str();
+
+    while( *strx.rbegin() == '0' )
+        strx.erase( strx.size() - 1 );
+}
+
+
+int CalcNSides( double rad, double dev )
+{
+    if( dev <= 0 || rad <= 0 )
+        return 6;
+
+    int csides;
+    double n = dev / rad;
+
+    // note: in the following, the first comparison and csides is chosen to
+    // yield a maximum of 360 segments; in practice we probably want a smaller limit.
+    if( n < 0.0001523048 )
+        csides = 360;
+    else if( n >= 0.5 ) // 0.5 yields an angle >= 60 deg. (6 or fewer sides)
+        csides = 6;
+    else
+        csides = M_PI * 2.0 / acos( 1.0 - n ) + 1;
+
+    if( csides < 6 )
+        csides = 6;
+
+    return csides;
+}
+
+
+static void CALLBACK vrml_tess_begin( GLenum cmd, void* user_data )
+{
+    VRML_LAYER* lp = (VRML_LAYER*) user_data;
+
+    lp->glStart( cmd );
+}
+
+
+static void CALLBACK vrml_tess_end( void* user_data )
+{
+    VRML_LAYER* lp = (VRML_LAYER*) user_data;
+
+    lp->glEnd();
+}
+
+
+static void CALLBACK vrml_tess_vertex( void* vertex_data, void* user_data )
+{
+    VRML_LAYER* lp = (VRML_LAYER*) user_data;
+
+    lp->glPushVertex( (VERTEX_3D*) vertex_data );
+}
+
+
+static void CALLBACK vrml_tess_err( GLenum errorID, void* user_data )
+{
+    VRML_LAYER* lp = (VRML_LAYER*) user_data;
+
+    lp->Fault = true;
+    lp->SetGLError( errorID );
+}
+
+
+static void CALLBACK vrml_tess_combine( GLdouble coords[3], void* vertex_data[4],
+        GLfloat weight[4], void** outData, void* user_data )
+{
+    VRML_LAYER* lp = (VRML_LAYER*) user_data;
+
+    *outData = lp->AddExtraVertex( coords[0], coords[1] );
+}
+
+
+VRML_LAYER::VRML_LAYER()
+{
+    fix = false;
+    Fault = false;
+    idx = 0;
+    ord = 0;
+    glcmd   = 0;
+    pholes  = NULL;
+    maxdev  = 0.02;
+
+    tess = gluNewTess();
+
+    if( !tess )
+        return;
+
+    // set up the tesselator callbacks
+    gluTessCallback( tess, GLU_TESS_BEGIN_DATA, GLCALLBACK( vrml_tess_begin ) );
+
+    gluTessCallback( tess, GLU_TESS_VERTEX_DATA, GLCALLBACK( vrml_tess_vertex ) );
+
+    gluTessCallback( tess, GLU_TESS_END_DATA, GLCALLBACK( vrml_tess_end ) );
+
+    gluTessCallback( tess, GLU_TESS_ERROR_DATA, GLCALLBACK( vrml_tess_err ) );
+
+    gluTessCallback( tess, GLU_TESS_COMBINE_DATA, GLCALLBACK( vrml_tess_combine ) );
+
+    gluTessProperty( tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_POSITIVE );
+
+    gluTessNormal( tess, 0, 0, 1 );
+}
+
+
+VRML_LAYER::~VRML_LAYER()
+{
+    Clear();
+
+    if( tess )
+    {
+        gluDeleteTess( tess );
+        tess = NULL;
+    }
+}
+
+
+// clear all data
+void VRML_LAYER::Clear( void )
+{
+    int i;
+
+    fix = false;
+    idx = 0;
+
+    for( i = contours.size(); i > 0; --i )
+    {
+        delete contours.back();
+        contours.pop_back();
+    }
+
+    while( !areas.empty() )
+        areas.pop_back();
+
+    for( i = vertices.size(); i > 0; --i )
+    {
+        delete vertices.back();
+        vertices.pop_back();
+    }
+
+    clearTmp();
+}
+
+
+// set the max. deviation of an arc segment
+bool VRML_LAYER::SetMaxDev( double max )
+{
+    // assure max. dev > 2 microns regardless of the
+    // prevailing units ( inch, mm, m, 0.1 inch )
+    if( max < 0.000002 )
+    {
+        error = "SetMaxDev(): specified value is < 0.000002";
+        return false;
+    }
+
+    maxdev = max;
+
+    return true;
+}
+
+
+// clear ephemeral data in between invocations of the tesselation routine
+void VRML_LAYER::clearTmp( void )
+{
+    unsigned int i;
+
+    Fault   = false;
+    hidx    = 0;
+    eidx    = 0;
+    ord = 0;
+    glcmd = 0;
+
+    while( !triplets.empty() )
+        triplets.pop_back();
+
+    for( i = outline.size(); i > 0; --i )
+    {
+        delete outline.back();
+        outline.pop_back();
+    }
+
+    for( i = ordmap.size(); i > 0; --i )
+        ordmap.pop_back();
+
+    for( i = extra_verts.size(); i > 0; --i )
+    {
+        delete extra_verts.back();
+        extra_verts.pop_back();
+    }
+
+    // note: unlike outline and extra_verts,
+    // vlist is not responsible for memory management
+    for( i = vlist.size(); i > 0; --i )
+        vlist.pop_back();
+
+    // go through the vertex list and reset ephemeral parameters
+    for( i = 0; i < vertices.size(); ++i )
+    {
+        vertices[i]->o = -1;
+    }
+}
+
+
+// create a new contour to be populated; returns an index
+// into the contour list or -1 if there are problems
+int VRML_LAYER::NewContour( void )
+{
+    if( fix )
+        return -1;
+
+    std::list<int>* contour = new std::list<int>;
+
+    if( !contour )
+        return -1;
+
+    contours.push_back( contour );
+    areas.push_back( 0.0 );
+
+    return contours.size() - 1;
+}
+
+
+// adds a vertex to the existing list and places its index in
+// an existing contour; returns true if OK,
+// false otherwise (indexed contour does not exist)
+bool VRML_LAYER::AddVertex( int aContour, double x, double y )
+{
+    if( fix )
+    {
+        error = "AddVertex(): no more vertices may be added (Tesselate was previously executed)";
+        return false;
+    }
+
+    if( aContour < 0 || (unsigned int) aContour >= contours.size() )
+    {
+        error = "AddVertex(): aContour is not within a valid range";
+        return false;
+    }
+
+    VERTEX_3D* vertex = new VERTEX_3D;
+
+    if( !vertex )
+    {
+        error = "AddVertex(): a new vertex could not be allocated";
+        return false;
+    }
+
+    vertex->x   = x;
+    vertex->y   = y;
+    vertex->i   = idx++;
+    vertex->o   = -1;
+
+    VERTEX_3D* v2 = NULL;
+
+    if( contours[aContour]->size() > 0 )
+        v2 = vertices[ contours[aContour]->back() ];
+
+    vertices.push_back( vertex );
+    contours[aContour]->push_back( vertex->i );
+
+    if( v2 )
+        areas[aContour] += ( x - v2->x ) * ( y + v2->y );
+
+    return true;
+}
+
+
+// ensure the winding of a contour with respect to the normal (0, 0, 1);
+// set 'hole' to true to ensure a hole (clockwise winding)
+bool VRML_LAYER::EnsureWinding( int aContour, bool hole )
+{
+    if( aContour < 0 || (unsigned int) aContour >= contours.size() )
+    {
+        error = "EnsureWinding(): aContour is outside the valid range";
+        return false;
+    }
+
+    std::list<int>* cp = contours[aContour];
+
+    if( cp->size() < 3 )
+    {
+        error = "EnsureWinding(): there are fewer than 3 vertices";
+        return false;
+    }
+
+    double dir = areas[aContour];
+
+    VERTEX_3D* vp0 = vertices[ cp->back() ];
+    VERTEX_3D* vp1 = vertices[ cp->front() ];
+
+    dir += ( vp1->x - vp0->x ) * ( vp1->y + vp0->y );
+
+    // if dir is positive, winding is CW
+    if( ( hole && dir < 0 ) || ( !hole && dir > 0 ) )
+    {
+        cp->reverse();
+        areas[aContour] = -areas[aContour];
+    }
+
+    return true;
+}
+
+
+// adds a circle the existing list; if 'hole' is true the contour is
+// a hole. Returns true if OK.
+bool VRML_LAYER::AddCircle( double x, double y, double rad, int csides, bool hole )
+{
+    int pad = NewContour();
+
+    if( pad < 0 )
+    {
+        error = "AddCircle(): failed to add a contour";
+        return false;
+    }
+
+    if( csides < 6 )
+        csides = CalcNSides( rad, maxdev );
+
+    // even numbers give prettier results
+    if( csides & 1 )
+        csides += 1;
+
+    double da = M_PI * 2.0 / csides;
+
+    bool fail = false;
+
+    if( hole )
+    {
+        for( double angle = 0; angle < M_PI * 2; angle += da )
+            fail |= !AddVertex( pad, x + rad * cos( angle ), y - rad * sin( angle ) );
+    }
+    else
+    {
+        for( double angle = 0; angle < M_PI * 2; angle += da )
+            fail |= !AddVertex( pad, x + rad * cos( angle ), y + rad * sin( angle ) );
+    }
+
+    return !fail;
+}
+
+
+// adds a slotted pad with orientation given by angle; if 'hole' is true the
+// contour is a hole. Returns true if OK.
+bool VRML_LAYER::AddSlot( double cx, double cy, double length, double width,
+        double angle, int csides, bool hole )
+{
+    if( width > length )
+    {
+        angle += M_PI2;
+        std::swap( length, width );
+    }
+
+    width   /= 2.0;
+    length  = length / 2.0 - width;
+
+    if( csides < 6 )
+        csides = CalcNSides( width, maxdev );
+
+    if( csides & 1 )
+        csides += 1;
+
+    csides /= 2;
+
+    double capx, capy;
+
+    capx    = cx + cos( angle ) * length;
+    capy    = cy + sin( angle ) * length;
+
+    double ang, da;
+    int i;
+    int pad = NewContour();
+
+    if( pad < 0 )
+    {
+        error = "AddCircle(): failed to add a contour";
+        return false;
+    }
+
+    da = M_PI / csides;
+    bool fail = false;
+
+    if( hole )
+    {
+        for( ang = angle + M_PI2, i = 0; i < csides; ang -= da, ++i )
+            fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        ang = angle - M_PI2;
+        fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        capx    = cx - cos( angle ) * length;
+        capy    = cy - sin( angle ) * length;
+
+        for( ang = angle - M_PI2, i = 0; i < csides; ang -= da, ++i )
+            fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        ang = angle + M_PI2;
+        fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+    }
+    else
+    {
+        for( ang = angle - M_PI2, i = 0; i < csides; ang += da, ++i )
+            fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        ang = angle + M_PI2;
+        fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        capx    = cx - cos( angle ) * length;
+        capy    = cy - sin( angle ) * length;
+
+        for( ang = angle + M_PI2, i = 0; i < csides; ang += da, ++i )
+            fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+        ang = angle - M_PI2;
+        fail |= !AddVertex( pad, capx + width * cos( ang ), capy + width * sin( ang ) );
+    }
+
+    return !fail;
+}
+
+
+// adds an arc with the given center, start point, pen width, and angle.
+bool VRML_LAYER::AddArc( double cx, double cy, double startx, double starty,
+        double width, double angle, int csides, bool hole )
+{
+    // we don't accept small angles; in fact, 1 degree ( 0.01745 ) is already
+    // way too small but we must set a limit somewhere
+    if( angle < 0.01745 && angle > -0.01745 )
+    {
+        error = "AddArc(): angle is too small: abs( angle ) < 0.01745";
+        return false;
+    }
+
+    double rad = sqrt( (startx - cx) * (startx - cx) + (starty - cy) * (starty - cy) );
+
+    width /= 2.0;    // this is the radius of the caps
+
+    // we will not accept an arc with an inner radius close to zero so we
+    // set a limit here. the end result will vary somewhat depending on
+    // the output units
+    if( width >= ( rad * 1.01 ) )
+    {
+        error = "AddArc(): width/2 exceeds radius*1.01";
+        return false;
+    }
+
+    // calculate the radii of the outer and inner arcs
+    double  orad    = rad + width;
+    double  irad    = rad - width;
+
+    int osides  = csides * angle / ( M_PI * 2.0 );
+    int isides  = csides * angle / ( M_PI * 2.0 );
+
+    if( osides < 0 )
+        osides = -osides;
+
+    if( osides < 3 )
+    {
+        osides = CalcNSides( orad, maxdev ) * angle / ( M_PI * 2.0 );
+
+        if( osides < 0 )
+            osides = -osides;
+
+        if( osides < 3 )
+            osides = 3;
+    }
+
+    if( isides < 0 )
+        isides = -isides;
+
+    if( isides < 3 )
+    {
+        isides = CalcNSides( irad, maxdev ) * angle / ( M_PI * 2.0 );
+
+        if( isides < 0 )
+            isides = -isides;
+
+        if( isides < 3 )
+            isides = 3;
+    }
+
+    if( csides < 6 )
+        csides = CalcNSides( width, maxdev );
+
+    if( csides & 1 )
+        csides += 1;
+
+    csides /= 2;
+
+    double  stAngle     = atan2( starty - cy, startx - cx );
+    double  endAngle    = stAngle + angle;
+
+    // calculate ends of inner and outer arc
+    double  oendx   = cx + orad* cos( endAngle );
+    double  oendy   = cy + orad* sin( endAngle );
+    double  ostx    = cx + orad* cos( stAngle );
+    double  osty    = cy + orad* sin( stAngle );
+
+    double  iendx   = cx + irad* cos( endAngle );
+    double  iendy   = cy + irad* sin( endAngle );
+    double  istx    = cx + irad* cos( stAngle );
+    double  isty    = cy + irad* sin( stAngle );
+
+    if( ( angle < 0 && !hole ) || ( angle > 0 && hole ) )
+    {
+        angle = -angle;
+        std::swap( stAngle, endAngle );
+        std::swap( oendx, ostx );
+        std::swap( oendy, osty );
+        std::swap( iendx, istx );
+        std::swap( iendy, isty );
+    }
+
+    int arc = NewContour();
+
+    if( arc < 0 )
+    {
+        error = "AddArc(): could not create a contour";
+        return false;
+    }
+
+    // trace the outer arc:
+    int i;
+    double  ang;
+    double  da = angle / osides;
+
+    for( ang = stAngle, i = 0; i < osides; ang += da, ++i )
+        AddVertex( arc, cx + orad * cos( ang ), cy + orad * sin( ang ) );
+
+    // trace the first cap
+    double  capx    = ( iendx + oendx ) / 2.0;
+    double  capy    = ( iendy + oendy ) / 2.0;
+
+    if( hole )
+        da = -M_PI / csides;
+    else
+        da = M_PI / csides;
+
+    for( ang = endAngle + da, i = 2; i < csides; ang += da, ++i )
+        AddVertex( arc, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+    // trace the inner arc:
+    da = -angle / isides;
+
+    for( ang = endAngle, i = 0; i < isides; ang += da, ++i )
+        AddVertex( arc, cx + irad * cos( ang ), cy + irad * sin( ang ) );
+
+    // trace the final cap
+    capx    = ( istx + ostx ) / 2.0;
+    capy    = ( isty + osty ) / 2.0;
+
+    if( hole )
+        da = -M_PI / csides;
+    else
+        da = M_PI / csides;
+
+    for( ang = stAngle + M_PI + da, i = 2; i < csides; ang += da, ++i )
+        AddVertex( arc, capx + width * cos( ang ), capy + width * sin( ang ) );
+
+    return true;
+}
+
+
+// tesselates the contours in preparation for a 3D output;
+// returns true if all was fine, false otherwise
+bool VRML_LAYER::Tesselate( VRML_LAYER* holes )
+{
+    if( !tess )
+    {
+        error = "Tesselate(): GLU tesselator was not initialized";
+        return false;
+    }
+
+    pholes  = holes;
+    Fault   = false;
+
+    if( contours.size() < 1 || vertices.size() < 3 )
+    {
+        error = "Tesselate(): not enough vertices";
+        return false;
+    }
+
+    // finish the winding calculation on all vertices prior to setting 'fix'
+    if( !fix )
+    {
+        for( unsigned int i = 0; i < contours.size(); ++i )
+        {
+            if( contours[i]->size() < 3 )
+                continue;
+
+            VERTEX_3D* vp0 = vertices[ contours[i]->back() ];
+            VERTEX_3D* vp1 = vertices[ contours[i]->front() ];
+            areas[i] += ( vp1->x - vp0->x ) * ( vp1->y + vp0->y );
+        }
+    }
+
+    // prevent the addition of any further contours and contour vertices
+    fix = true;
+
+    // clear temporary internals which may have been used in a previous run
+    clearTmp();
+
+    // request an outline
+    gluTessProperty( tess, GLU_TESS_BOUNDARY_ONLY, GL_TRUE );
+
+    // adjust internal indices for extra points and holes
+    if( holes )
+        hidx = holes->GetSize();
+    else
+        hidx = 0;
+
+    eidx = idx + hidx;
+
+    // open the polygon
+    gluTessBeginPolygon( tess, this );
+
+    pushVertices( false );
+
+    // close the polygon
+    gluTessEndPolygon( tess );
+
+    if( Fault )
+        return false;
+
+    // push the (solid) outline to the tesselator
+    if( !pushOutline( holes ) )
+        return false;
+
+    // add the holes contained by this object
+    pushVertices( true );
+
+    // import external holes (if any)
+    if( hidx && ( holes->Import( idx, tess ) < 0 ) )
+    {
+        std::ostringstream ostr;
+        ostr << "Tesselate():FAILED: " << holes->GetError();
+        error = ostr.str();
+        return NULL;
+    }
+
+    if( Fault )
+        return false;
+
+    // erase the previous outline data and vertex order
+    // but preserve the extra vertices
+    for( int i = outline.size(); i > 0; --i )
+    {
+        delete outline.back();
+        outline.pop_back();
+    }
+
+    for( unsigned int i = ordmap.size(); i > 0; --i )
+        ordmap.pop_back();
+
+    // go through the vertex lists and reset ephemeral parameters
+    for( unsigned int i = 0; i < vertices.size(); ++i )
+    {
+        vertices[i]->o = -1;
+    }
+
+    for( unsigned int i = 0; i < extra_verts.size(); ++i )
+    {
+        extra_verts[i]->o = -1;
+    }
+
+    ord = 0;
+
+    // close the polygon; we now have all the data necessary for the tesselation
+    gluTessEndPolygon( tess );
+
+    // request a tesselated surface
+    gluTessProperty( tess, GLU_TESS_BOUNDARY_ONLY, GL_FALSE );
+
+    if( !pushOutline( holes ) )
+        return false;
+
+    gluTessEndPolygon( tess );
+
+    if( Fault )
+        return false;
+
+    return true;
+}
+
+
+bool VRML_LAYER::pushOutline( VRML_LAYER* holes )
+{
+    // traverse the outline list to push all used vertices
+    if( outline.size() < 1 )
+    {
+        error = "pushOutline() failed: no vertices to push";
+        return false;
+    }
+
+    gluTessBeginPolygon( tess, this );
+
+    std::list<std::list<int>*>::const_iterator obeg = outline.begin();
+    std::list<std::list<int>*>::const_iterator oend = outline.end();
+
+    int pi;
+    std::list<int>::const_iterator  begin;
+    std::list<int>::const_iterator  end;
+    GLdouble pt[3];
+    VERTEX_3D* vp;
+
+    while( obeg != oend )
+    {
+        if( (*obeg)->size() < 3 )
+        {
+            ++obeg;
+            continue;
+        }
+
+        gluTessBeginContour( tess );
+
+        begin = (*obeg)->begin();
+        end = (*obeg)->end();
+
+        while( begin != end )
+        {
+            pi = *begin;
+
+            if( pi < 0 || (unsigned int) pi > ordmap.size() )
+            {
+                error = "pushOutline():BUG: *outline.begin() is not a valid index to ordmap";
+                return false;
+            }
+
+            // retrieve the actual index
+            pi = ordmap[pi];
+
+            vp = getVertexByIndex( pi, holes );
+
+            if( !vp )
+            {
+                error = "pushOutline():: BUG: ordmap[n] is not a valid index to vertices[]";
+                return false;
+            }
+
+            pt[0]   = vp->x;
+            pt[1]   = vp->y;
+            pt[2]   = 0.0;
+            gluTessVertex( tess, pt, vp );
+            ++begin;
+        }
+
+        gluTessEndContour( tess );
+        ++obeg;
+    }
+
+    return true;
+}
+
+
+// writes out the vertex list;
+// 'z' is the Z coordinate of every point
+bool VRML_LAYER::WriteVertices( double z, FILE* fp )
+{
+    if( !fp )
+    {
+        error = "WriteVertices(): invalid file pointer";
+        return false;
+    }
+
+    if( ordmap.size() < 3 )
+    {
+        error = "WriteVertices(): not enough vertices";
+        return false;
+    }
+
+    int i, j;
+
+    VERTEX_3D* vp = getVertexByIndex( ordmap[0], pholes );
+
+    if( !vp )
+        return false;
+
+    std::string strx, stry, strz;
+    FormatDoublet( vp->x, vp->y, 6, strx, stry );
+    FormatSinglet( z, 6, strz );
+
+    fprintf( fp, "%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+
+    for( i = 1, j = ordmap.size(); i < j; ++i )
+    {
+        vp = getVertexByIndex( ordmap[i], pholes );
+
+        if( !vp )
+            return false;
+
+        FormatDoublet( vp->x, vp->y, 6, strx, stry );
+
+        if( i & 1 )
+            fprintf( fp, ", %s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+        else
+            fprintf( fp, ",\n%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+    }
+
+    return true;
+}
+
+
+// writes out the vertex list for a 3D feature; top and bottom are the
+// Z values for the top and bottom; top must be > bottom
+bool VRML_LAYER::Write3DVertices( double top, double bottom, FILE* fp )
+{
+    if( !fp )
+    {
+        error = "Write3DVertices(): NULL file pointer";
+        return false;
+    }
+
+    if( ordmap.size() < 3 )
+    {
+        error = "Write3DVertices(): insufficient vertices";
+        return false;
+    }
+
+    if( top <= bottom )
+    {
+        error = "Write3DVertices(): top <= bottom";
+        return false;
+    }
+
+    int i, j;
+
+    VERTEX_3D* vp = getVertexByIndex( ordmap[0], pholes );
+
+    if( !vp )
+        return false;
+
+    std::string strx, stry, strz;
+    FormatDoublet( vp->x, vp->y, 6, strx, stry );
+    FormatSinglet( top, 6, strz );
+
+    fprintf( fp, "%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+
+    for( i = 1, j = ordmap.size(); i < j; ++i )
+    {
+        vp = getVertexByIndex( ordmap[i], pholes );
+
+        if( !vp )
+            return false;
+
+        FormatDoublet( vp->x, vp->y, 6, strx, stry );
+
+        if( i & 1 )
+            fprintf( fp, ", %s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+        else
+            fprintf( fp, ",\n%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+    }
+
+    // repeat for the bottom layer
+    vp = getVertexByIndex( ordmap[0], pholes );
+    FormatDoublet( vp->x, vp->y, 6, strx, stry );
+    FormatSinglet( bottom, 6, strz );
+
+    bool endl;
+
+    if( i & 1 )
+    {
+        fprintf( fp, ", %s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+        endl = false;
+    }
+    else
+    {
+        fprintf( fp, ",\n%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+        endl = true;
+    }
+
+    for( i = 1, j = ordmap.size(); i < j; ++i )
+    {
+        vp = getVertexByIndex( ordmap[i], pholes );
+        FormatDoublet( vp->x, vp->y, 6, strx, stry );
+
+        if( endl )
+        {
+            fprintf( fp, ", %s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+            endl = false;
+        }
+        else
+        {
+            fprintf( fp, ",\n%s %s %s", strx.c_str(), stry.c_str(), strz.c_str() );
+            endl = true;
+        }
+    }
+
+    return true;
+}
+
+
+// writes out the index list;
+// 'top' indicates the vertex ordering and should be
+// true for a polygon visible from above the PCB
+bool VRML_LAYER::WriteIndices( bool top, FILE* fp )
+{
+    if( triplets.empty() )
+    {
+        error = "WriteIndices(): no triplets (triangular facets) to write";
+        return false;
+    }
+
+    // go through the triplet list and write out the indices based on order
+    std::list<TRIPLET_3D>::const_iterator   tbeg    = triplets.begin();
+    std::list<TRIPLET_3D>::const_iterator   tend    = triplets.end();
+
+    int i = 1;
+
+    if( top )
+        fprintf( fp, "%d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+    else
+        fprintf( fp, "%d, %d, %d, -1", tbeg->i2, tbeg->i1, tbeg->i3 );
+
+    ++tbeg;
+
+    while( tbeg != tend )
+    {
+        if( (i++ & 7) == 4 )
+        {
+            i = 1;
+
+            if( top )
+                fprintf( fp, ",\n%d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+            else
+                fprintf( fp, ",\n%d, %d, %d, -1", tbeg->i2, tbeg->i1, tbeg->i3 );
+        }
+        else
+        {
+            if( top )
+                fprintf( fp, ", %d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+            else
+                fprintf( fp, ", %d, %d, %d, -1", tbeg->i2, tbeg->i1, tbeg->i3 );
+        }
+
+        ++tbeg;
+    }
+
+    return true;
+}
+
+
+// writes out the index list for a 3D feature
+bool VRML_LAYER::Write3DIndices( FILE* fp )
+{
+    if( triplets.empty() )
+    {
+        error = "Write3DIndices(): no triplets (triangular facets) to write";
+        return false;
+    }
+
+    if( outline.empty() )
+    {
+        error = "WriteIndices(): no outline available";
+        return false;
+    }
+
+    // go through the triplet list and write out the indices based on order
+    std::list<TRIPLET_3D>::const_iterator   tbeg    = triplets.begin();
+    std::list<TRIPLET_3D>::const_iterator   tend    = triplets.end();
+
+    int i = 1;
+    int idx2 = ordmap.size();    // index to the bottom vertices
+
+    // print out the top vertices
+    fprintf( fp, "%d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+    ++tbeg;
+
+    while( tbeg != tend )
+    {
+        if( (i++ & 7) == 4 )
+        {
+            i = 1;
+            fprintf( fp, ",\n%d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+        }
+        else
+        {
+            fprintf( fp, ", %d, %d, %d, -1", tbeg->i1, tbeg->i2, tbeg->i3 );
+        }
+
+        ++tbeg;
+    }
+
+    // print out the bottom vertices
+    tbeg = triplets.begin();
+
+    while( tbeg != tend )
+    {
+        if( (i++ & 7) == 4 )
+        {
+            i = 1;
+            fprintf( fp, ",\n%d, %d, %d, -1", tbeg->i2 + idx2, tbeg->i1 + idx2, tbeg->i3 + idx2 );
+        }
+        else
+        {
+            fprintf( fp, ", %d, %d, %d, -1", tbeg->i2 + idx2, tbeg->i1 + idx2, tbeg->i3 + idx2 );
+        }
+
+        ++tbeg;
+    }
+
+    int firstPoint;
+    int lastPoint;
+    int curPoint;
+
+    std::list<std::list<int>*>::const_iterator  obeg    = outline.begin();
+    std::list<std::list<int>*>::const_iterator  oend    = outline.end();
+    std::list<int>* cp;
+    std::list<int>::const_iterator  cbeg;
+    std::list<int>::const_iterator  cend;
+
+    while( obeg != oend )
+    {
+        cp = *obeg;
+
+        if( cp->size() < 3 )
+        {
+            ++obeg;
+            continue;
+        }
+
+        cbeg    = cp->begin();
+        cend    = cp->end();
+
+        firstPoint  = *(cbeg++);
+        lastPoint   = firstPoint;
+
+        while( cbeg != cend )
+        {
+            curPoint = *(cbeg++);
+            fprintf( fp, ",\n %d, %d, %d, -1, %d, %d, %d, -1",
+                    curPoint, lastPoint, curPoint + idx2,
+                    curPoint + idx2, lastPoint, lastPoint + idx2 );
+            lastPoint = curPoint;
+        }
+
+        fprintf( fp, ",\n %d, %d, %d, -1, %d, %d, %d, -1",
+                firstPoint, lastPoint, firstPoint + idx2,
+                firstPoint + idx2, lastPoint, lastPoint + idx2 );
+
+        ++obeg;
+    }
+
+    return true;
+}
+
+
+// add a triangular facet (triplet) to the ouptut index list
+bool VRML_LAYER::addTriplet( VERTEX_3D* p0, VERTEX_3D* p1, VERTEX_3D* p2 )
+{
+    double  dx0 = p1->x - p0->x;
+    double  dx1 = p2->x - p0->x;
+
+    double  dy0 = p1->y - p0->y;
+    double  dy1 = p2->y - p0->y;
+
+    // this number is chosen because we shall only write 6 decimal places
+    // on the VRML output
+    double err = 0.000001;
+
+    // test if the triangles are degenerate (parallel sides)
+
+    if( dx0 < err && dx0 > -err && dx1 < err && dx1 > -err )
+        return false;
+
+    if( dy0 < err && dy0 > -err && dy1 < err && dy1 > -err )
+        return false;
+
+    double  sl0 = dy0 / dx0;
+    double  sl1 = dy1 / dx1;
+
+    double dsl = sl1 - sl0;
+
+    if( dsl < err && dsl > -err )
+        return false;
+
+    triplets.push_back( TRIPLET_3D( p0->o, p1->o, p2->o ) );
+
+    return true;
+}
+
+
+// add an extra vertex (to be called only by the COMBINE callback)
+VERTEX_3D* VRML_LAYER::AddExtraVertex( double x, double y )
+{
+    VERTEX_3D* vertex = new VERTEX_3D;
+
+    if( !vertex )
+    {
+        error = "AddExtraVertex(): could not allocate a new vertex";
+        return NULL;
+    }
+
+    if( eidx == 0 )
+        eidx = idx + hidx;
+
+    vertex->x   = x;
+    vertex->y   = y;
+    vertex->i   = eidx++;
+    vertex->o   = -1;
+
+    extra_verts.push_back( vertex );
+
+    return vertex;
+}
+
+
+// start a GL command list
+void VRML_LAYER::glStart( GLenum cmd )
+{
+    glcmd = cmd;
+
+    while( !vlist.empty() )
+        vlist.pop_back();
+}
+
+
+// process a vertex
+void VRML_LAYER::glPushVertex( VERTEX_3D* vertex )
+{
+    if( vertex->o < 0 )
+    {
+        vertex->o = ord++;
+        ordmap.push_back( vertex->i );
+    }
+
+    vlist.push_back( vertex );
+}
+
+
+// end a GL command list
+void VRML_LAYER::glEnd( void )
+{
+    switch( glcmd )
+    {
+    case GL_LINE_LOOP:
+        {
+            // add the loop to the list of outlines
+            std::list<int>* loop = new std::list<int>;
+
+            if( !loop )
+                break;
+
+            for( unsigned int i = 0; i < vlist.size(); ++i )
+            {
+                loop->push_back( vlist[i]->o );
+            }
+
+            outline.push_back( loop );
+        }
+        break;
+
+    case GL_TRIANGLE_FAN:
+        processFan();
+        break;
+
+    case GL_TRIANGLE_STRIP:
+        processStrip();
+        break;
+
+    case GL_TRIANGLES:
+        processTri();
+        break;
+
+    default:
+        break;
+    }
+
+    while( !vlist.empty() )
+        vlist.pop_back();
+
+    glcmd = 0;
+}
+
+
+// set the error message
+void VRML_LAYER::SetGLError( GLenum errorID )
+{
+    error = "";
+    error = (const char*)gluGetString( errorID );
+
+    if( error.empty() )
+    {
+        std::ostringstream ostr;
+        ostr << "Unknown OpenGL error: " << errorID;
+        error = ostr.str();
+    }
+}
+
+
+// process a GL_TRIANGLE_FAN list
+void VRML_LAYER::processFan( void )
+{
+    if( vlist.size() < 3 )
+        return;
+
+    VERTEX_3D* p0 = vlist[0];
+
+    int i;
+    int end = vlist.size();
+
+    for( i = 2; i < end; ++i )
+    {
+        addTriplet( p0, vlist[i - 1], vlist[i] );
+    }
+}
+
+
+// process a GL_TRIANGLE_STRIP list
+void VRML_LAYER::processStrip( void )
+{
+    // note: (source: http://www.opengl.org/wiki/Primitive)
+    // GL_TRIANGLE_STRIP​: Every group of 3 adjacent vertices forms a triangle.
+    // The face direction of the strip is determined by the winding of the
+    // first triangle. Each successive triangle will have its effective face
+    // order reverse, so the system compensates for that by testing it in the
+    // opposite way. A vertex stream of n length will generate n-2 triangles.
+
+    if( vlist.size() < 3 )
+        return;
+
+    int i;
+    int end = vlist.size();
+    bool flip = false;
+
+    for( i = 2; i < end; ++i )
+    {
+        if( flip )
+        {
+            addTriplet( vlist[i - 1], vlist[i - 2], vlist[i] );
+            flip = false;
+        }
+        else
+        {
+            addTriplet( vlist[i - 2], vlist[i - 1], vlist[i] );
+            flip = true;
+        }
+    }
+}
+
+
+// process a GL_TRIANGLES list
+void VRML_LAYER::processTri( void )
+{
+    // notes:
+    // 1. each successive group of 3 vertices is a triangle
+    // 2. as per OpenGL specification, any incomplete triangles are to be ignored
+
+    if( vlist.size() < 3 )
+        return;
+
+    int i;
+    int end = vlist.size();
+
+    for( i = 2; i < end; i += 3 )
+        addTriplet( vlist[i - 2], vlist[i - 1], vlist[i] );
+}
+
+
+// push the internally held vertices
+void VRML_LAYER::pushVertices( bool holes )
+{
+    // push the internally held vertices
+    unsigned int i;
+
+    std::list<int>::const_iterator  begin;
+    std::list<int>::const_iterator  end;
+    GLdouble pt[3];
+    VERTEX_3D* vp;
+
+    for( i = 0; i < contours.size(); ++i )
+    {
+        if( contours[i]->size() < 3 )
+            continue;
+
+        if( ( holes && areas[i] <= 0.0 ) || ( !holes && areas[i] > 0.0 ) )
+            continue;
+
+        gluTessBeginContour( tess );
+
+        begin = contours[i]->begin();
+        end = contours[i]->end();
+
+        while( begin != end )
+        {
+            vp = vertices[ *begin ];
+            pt[0]   = vp->x;
+            pt[1]   = vp->y;
+            pt[2]   = 0.0;
+            gluTessVertex( tess, pt, vp );
+            ++begin;
+        }
+
+        gluTessEndContour( tess );
+    }
+}
+
+
+VERTEX_3D* VRML_LAYER::getVertexByIndex( int index, VRML_LAYER* holes )
+{
+    if( index < 0 || (unsigned int) index >= ( idx + hidx + extra_verts.size() ) )
+    {
+        error = "getVertexByIndex():BUG: invalid index";
+        return NULL;
+    }
+
+    if( index < idx )
+    {
+        // vertex is in the vertices[] list
+        return vertices[ index ];
+    }
+    else if( index >= idx + hidx )
+    {
+        // vertex is in the extra_verts[] list
+        return extra_verts[index - idx - hidx];
+    }
+
+    // vertex is in the holes object
+    if( !holes )
+    {
+        error = "getVertexByIndex():BUG: invalid index";
+        return NULL;
+    }
+
+    VERTEX_3D* vp = holes->GetVertexByIndex( index );
+
+    if( !vp )
+    {
+        std::ostringstream ostr;
+        ostr << "getVertexByIndex():FAILED: " << holes->GetError();
+        error = ostr.str();
+        return NULL;
+    }
+
+    return vp;
+}
+
+
+// retrieve the total number of vertices
+int VRML_LAYER::GetSize( void )
+{
+    return vertices.size();
+}
+
+
+// Inserts all contours into the given tesselator; this results in the
+// renumbering of all vertices from 'start'. Returns the end number.
+// Take care when using this call since tesselators cannot work on
+// the internal data concurrently
+int VRML_LAYER::Import( int start, GLUtesselator* tess )
+{
+    if( start < 0 )
+    {
+        error = "Import(): invalid index ( start < 0 )";
+        return -1;
+    }
+
+    if( !tess )
+    {
+        error = "Import(): NULL tesselator pointer";
+        return -1;
+    }
+
+    unsigned int i, j;
+
+    // renumber from 'start'
+    for( i = 0, j = vertices.size(); i < j; ++i )
+    {
+        vertices[i]->i = start++;
+        vertices[i]->o = -1;
+    }
+
+    // push each contour to the tesselator
+    VERTEX_3D* vp;
+    GLdouble pt[3];
+
+    std::list<int>::const_iterator cbeg;
+    std::list<int>::const_iterator cend;
+
+    for( i = 0; i < contours.size(); ++i )
+    {
+        if( contours[i]->size() < 3 )
+            continue;
+
+        cbeg = contours[i]->begin();
+        cend = contours[i]->end();
+
+        gluTessBeginContour( tess );
+
+        while( cbeg != cend )
+        {
+            vp = vertices[ *cbeg++ ];
+            pt[0] = vp->x;
+            pt[1] = vp->y;
+            pt[2] = 0.0;
+            gluTessVertex( tess, pt, vp );
+        }
+
+        gluTessEndContour( tess );
+    }
+
+    return start;
+}
+
+
+// return the vertex identified by index
+VERTEX_3D* VRML_LAYER::GetVertexByIndex( int index )
+{
+    int i0 = vertices[0]->i;
+
+    if( index < i0 || index >= ( i0 + (int) vertices.size() ) )
+    {
+        error = "GetVertexByIndex(): invalid index";
+        return NULL;
+    }
+
+    return vertices[index - i0];
+}
+
+
+// return the error string
+const std::string& VRML_LAYER::GetError( void )
+{
+    return error;
+}

=== added file 'utils/idftools/vrml_board.h'
--- utils/idftools/vrml_board.h	1970-01-01 00:00:00 +0000
+++ utils/idftools/vrml_board.h	2014-04-08 07:49:38 +0000
@@ -0,0 +1,379 @@
+/*
+ * file: vrml_board.h
+ *
+ * This program source code file is part of KiCad, a free EDA CAD application.
+ *
+ * Copyright (C) 2013  Cirilo Bernardo
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you may find one here:
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * or you may search the http://www.gnu.org website for the version 2 license,
+ * or you may write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+/**
+ *  @file vrml_board.h
+ */
+
+/*
+ *  Classes and structures to support the tesselation of a
+ *  PCB for VRML output.
+ */
+
+#ifndef VRML_BOARD_H
+#define VRML_BOARD_H
+
+#ifdef __WXMAC__
+#  ifdef __DARWIN__
+#    include <OpenGL/glu.h>
+#  else
+#    include <glu.h>
+#  endif
+#else
+#  include <GL/glu.h>
+#endif
+
+#include <cstdio>
+#include <vector>
+#include <list>
+#include <utility>
+
+#ifndef M_PI2
+#define M_PI2 ( M_PI / 2.0 )
+#endif
+
+#ifndef M_PI4
+#define M_PI4 ( M_PI / 4.0 )
+#endif
+
+struct GLUtesselator;
+
+struct VERTEX_3D
+{
+    double  x;
+    double  y;
+    int i;          // vertex index
+    int o;          // vertex order
+};
+
+struct TRIPLET_3D
+{
+    int i1, i2, i3;
+
+    TRIPLET_3D( int p1, int p2, int p3 )
+    {
+        i1  = p1;
+        i2  = p2;
+        i3  = p3;
+    }
+};
+
+
+class VRML_LAYER
+{
+private:
+    bool    fix;                            // when true, no more vertices may be added by the user
+    int     idx;                            // vertex index (number of contained vertices)
+    int     ord;                            // vertex order (number of ordered vertices)
+    std::vector<VERTEX_3D*> vertices;       // vertices of all contours
+    std::vector<std::list<int>*> contours;  // lists of vertices for each contour
+    std::vector< double > areas;            // area of the contours (positive if winding is CCW)
+    std::list<TRIPLET_3D> triplets;         // output facet triplet list (triplet of ORDER values)
+    std::list<std::list<int>*> outline;     // indices for outline outputs (index by ORDER values)
+    std::vector<int> ordmap;                // mapping of ORDER to INDEX
+
+    std::string error;                      // error message
+
+    double maxdev;                          // max. deviation from circle when calculating N sides
+
+    int hidx;                               // number of vertices in the holes
+    int eidx;                               // index for extra vertices
+    std::vector<VERTEX_3D*> extra_verts;    // extra vertices added for outlines and facets
+    std::vector<VERTEX_3D*> vlist;          // vertex list for the GL command in progress
+    VRML_LAYER* pholes;                     // pointer to another layer object used for tesselation;
+                                            // this object is normally expected to hold only holes
+
+    GLUtesselator* tess;                    // local instance of the GLU tesselator
+
+    GLenum glcmd;                           // current GL command type ( fan, triangle, tri-strip, loop )
+
+    void clearTmp( void );                  // clear ephemeral data used by the tesselation routine
+
+    // add a triangular facet (triplet) to the output index list
+    bool addTriplet( VERTEX_3D* p0, VERTEX_3D* p1, VERTEX_3D* p2 );
+
+    // retrieve a vertex given its index; the vertex may be contained in the
+    // vertices vector, extra_verts vector, or foreign VRML_LAYER object
+    VERTEX_3D* getVertexByIndex( int index, VRML_LAYER* holes );
+
+    void    processFan( void );                 // process a GL_TRIANGLE_FAN list
+    void    processStrip( void );               // process a GL_TRIANGLE_STRIP list
+    void    processTri( void );                 // process a GL_TRIANGLES list
+
+    void pushVertices( bool holes );            // push the internal vertices
+    bool pushOutline( VRML_LAYER* holes );      // push the outline vertices
+
+public:
+    /// set to true when a fault is encountered during tesselation
+    bool Fault;
+
+    VRML_LAYER();
+    virtual ~VRML_LAYER();
+
+    /**
+     * Function Clear
+     * erases all data.
+     */
+    void Clear( void );
+
+    /**
+     * Function GetSize
+     * returns the total number of vertices indexed
+     */
+    int GetSize( void );
+
+    /**
+     * Function SetMaxDev
+     * sets the maximum deviation from a circle; this parameter is
+     * used for the automatic calculation of segments within a
+     * circle or an arc.
+     *
+     * @param max is the maximum deviation from a perfect circle or arc;
+     * minimum value is 0.000002 units
+     *
+     * @return bool: true if the value was accepted
+     */
+    bool SetMaxDev( double max );
+
+    /**
+     * Function NewContour
+     * creates a new list of vertices and returns an index to the list
+     *
+     * @return int: index to the list or -1 if the operation failed
+     */
+    int NewContour( void );
+
+    /**
+     * Function AddVertex
+     * adds a point to the requested contour
+     *
+     * @param aContour is an index previously returned by a call to NewContour()
+     * @param x is the X coordinate of the vertex
+     * @param y is the Y coordinate of the vertex
+     *
+     * @return bool: true if the vertex was added
+     */
+    bool AddVertex( int aContour, double x, double y );
+
+    /**
+     * Function EnsureWinding
+     * checks the winding of a contour and ensures that it is a hole or
+     * a solid depending on the value of @param hole
+     *
+     * @param aContour is an index to a contour as returned by NewContour()
+     * @param hole determines if the contour must be a hole
+     *
+     * @return bool: true if the operation suceeded
+     */
+    bool EnsureWinding( int aContour, bool hole );
+
+    /**
+     * Function AddCircle
+     * creates a circular contour and adds it to the internal list
+     *
+     * @param x is the X coordinate of the hole center
+     * @param y is the Y coordinate of the hole center
+     * @param rad is the radius of the hole
+     * @param csides is the number of sides (segments) in a circle;
+     *      use a value of 1 to automatically calculate a suitable number.
+     * @param hole determines if the contour to be created is a cutout
+     *
+     * @return bool: true if the new contour was successfully created
+     */
+    bool AddCircle( double x, double y, double rad, int csides, bool hole = false );
+
+    /**
+     * Function AddSlot
+     * creates and adds a slot feature to the list of contours
+     *
+     * @param cx is the X coordinate of the slot
+     * @param cy is the Y coordinate of the slot
+     * @param length is the length of the slot along the major axis
+     * @param width is the width of the slot along the minor axis
+     * @param angle (radians) is the orientation of the slot
+     * @param csides is the number of sides to a circle; use 1 to
+     *  take advantage of automatic calculations.
+     * @param hole determines whether the slot is a hole or a solid
+     *
+     * @return bool: true if the slot was successfully created
+     */
+    bool AddSlot( double cx, double cy, double length, double width,
+            double angle, int csides, bool hole = false );
+
+    /**
+     * Function AddArc
+     * creates an arc and adds it to the internal list of contours
+     *
+     * @param cx is the X coordinate of the arc's center
+     * @param cy is the Y coordinate of the arc's center
+     * @param startx is the X coordinate of the starting point
+     * @param starty is the Y coordinate of the starting point
+     * @param width is the width of the arc
+     * @param angle is the included angle
+     * @param csides is the number of segments in a circle; use 1
+     *  to take advantage of automatic calculations of this number
+     * @param hole determined whether the arc is to be a hole or a solid
+     *
+     * @return bool: true if the feature was successfully created
+     */
+    bool AddArc( double cx, double cy, double startx, double starty,
+            double width, double angle, int csides, bool hole = false );
+
+
+    /**
+     * Function Tesselate
+     * creates a list of outline vertices as well as the
+     * vertex sets required to render the surface.
+     *
+     * @param holes  is a pointer to cutouts to be imposed on the
+     * surface.
+     *
+     * @return bool: true if the operation succeeded
+     */
+    bool Tesselate( VRML_LAYER* holes );
+
+    /**
+     * Function WriteVertices
+     * writes out the list of vertices required to render a
+     * planar surface.
+     *
+     * @param z is the Z coordinate of the plane
+     * @param fp is the file to write to
+     *
+     * @return bool: true if the operation succeeded
+     */
+    bool WriteVertices( double z, FILE* fp );
+
+    /**
+     * Function Write3DVertices
+     * writes out the list of vertices required to render an extruded solid
+     *
+     * @param top is the Z coordinate of the top plane
+     * @param bottom is the Z coordinate of the bottom plane
+     * @param fp is the file to write to
+     *
+     * @return bool: true if the operation succeeded
+     */
+    bool Write3DVertices( double top, double bottom, FILE* fp );
+
+    /**
+     * Function WriteIndices
+     * writes out the vertex sets required to render a planar
+     * surface.
+     *
+     * @param top is true if the surface is to be visible from above;
+     * if false the surface will be visible from below.
+     * @param fp is the file to write to
+     *
+     * @return bool: true if the operation succeeded
+     */
+    bool WriteIndices( bool top, FILE* fp );
+
+    /**
+     * Function Write3DIndices
+     * writes out the vertex sets required to render an extruded solid
+     *
+     * @param fp is the file to write to
+     *
+     * @return bool: true if the operation succeeded
+     */
+    bool Write3DIndices( FILE* fp );
+
+    /**
+     * Function AddExtraVertex
+     * adds an extra vertex as required by the GLU tesselator
+     *
+     * @return VERTEX_3D*: is the new vertex or NULL if a vertex
+     * could not be created.
+     */
+    VERTEX_3D* AddExtraVertex( double x, double y );
+
+    /**
+     * Function glStart
+     * is invoked by the GLU tesselator callback to notify this object
+     * of the type of GL command which is applicable to the upcoming
+     * vertex list.
+     *
+     * @param cmd is the GL command
+     */
+    void glStart( GLenum cmd );
+
+    /**
+     * Function glPushVertex
+     * is invoked by the GLU tesselator callback; the supplied vertex is
+     * added to the internal list of vertices awaiting processing upon
+     * execution of glEnd()
+     *
+     * @param vertex is a vertex forming part of the GL command as previously
+     * set by glStart
+     */
+    void glPushVertex( VERTEX_3D* vertex );
+
+    /**
+     * Function glEnd
+     * is invoked by the GLU tesselator callback to notify this object
+     * that the vertex list is complete and ready for processing
+     */
+    void glEnd( void );
+
+    /**
+     * Function SetGLError
+     * sets the error message according to the specified OpenGL error
+     */
+    void SetGLError( GLenum error_id );
+
+    /**
+     * Function Import
+     * inserts all contours into the given tesselator; this
+     * results in the renumbering of all vertices from @param start.
+     * Take care when using this call since tesselators cannot work on
+     * the internal data concurrently.
+     *
+     * @param start is the starting number for vertex indices
+     * @param tess is a pointer to a GLU Tesselator object
+     *
+     * @return int: the number of vertices exported
+     */
+    int Import( int start, GLUtesselator* tess );
+
+    /**
+     * Function GetVertexByIndex
+     * returns a pointer to the requested vertex or
+     * NULL if no such vertex exists.
+     *
+     * @param ptindex is a vertex index
+     *
+     * @return VERTEX_3D*: the requested vertex or NULL
+     */
+    VERTEX_3D* GetVertexByIndex( int ptindex );
+
+    /*
+     * Function GetError
+     * Returns the error message related to the last failed operation
+     */
+    const std::string& GetError( void );
+};
+
+#endif    // VRML_BOARD_H

