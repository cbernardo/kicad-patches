=== modified file 'utils/idftools/dxf2idfmain.cpp'
--- utils/idftools/dxf2idfmain.cpp	2014-05-28 12:24:44 +0000
+++ utils/idftools/dxf2idfmain.cpp	2014-05-29 07:49:20 +0000
@@ -187,4 +187,4 @@
     fprintf( fp, ".END_ELECTRICAL\n" );
 
     return 0;
-}
+}
\ No newline at end of file

=== modified file 'utils/idftools/idf2vrml.cpp'
--- utils/idftools/idf2vrml.cpp	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf2vrml.cpp	2014-05-29 07:51:44 +0000
@@ -215,10 +215,15 @@
 
     cout << "** Reading file: " << inputFilename << "\n";
 
-    if( !pcb.ReadFile( FROM_UTF8( inputFilename.c_str() ) ) )
-    {
-        CLEANUP;
-        cerr << "* Could not read file: " << inputFilename << "\n";
+    try
+    {
+        pcb.ReadFile( FROM_UTF8( inputFilename.c_str() ) );
+    }
+    catch( std::exception& e )
+    {
+        cerr << "** Failed to read IDF data\n";
+        cerr << e.what() << "\n\n";
+
         return -1;
     }
 
@@ -328,7 +333,7 @@
 
     vpcb.EnsureWinding( 0, false );
 
-    int nvcont = vpcb.GetNContours();
+    int nvcont = vpcb.GetNContours() - 1;
 
     while( nvcont > 0 )
         vpcb.EnsureWinding( nvcont--, true );
@@ -764,6 +769,12 @@
             if( !compact || !vcp->used )
             {
                 vpcb.EnsureWinding( 0, false );
+
+                int nvcont = vpcb.GetNContours() - 1;
+
+                while( nvcont > 0 )
+                    vpcb.EnsureWinding( nvcont--, true );
+
                 vpcb.Tesselate( NULL );
             }
 

=== modified file 'utils/idftools/idf_common.cpp'
--- utils/idftools/idf_common.cpp	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_common.cpp	2014-05-29 07:49:39 +0000
@@ -23,6 +23,8 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 
+// TODO: check ownership rules
+
 #include <list>
 #include <string>
 #include <iostream>
@@ -89,7 +91,7 @@
 }
 
 
-bool IDF_NOTE::ReadNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState,
+bool IDF_NOTE::readNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState,
                          IDF3::IDF_UNIT aBoardUnit )
 {
     std::string iline;      // the input line
@@ -104,19 +106,16 @@
 
     if( ( !aBoardFile.good() && !aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF;
-        cerr << "problems reading board notes\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, "problems reading board notes" ) );
     }
 
     if( isComment )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within a section (NOTES)\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: comment within a section (NOTES)" ) );
     }
 
     idx = 0;
@@ -124,21 +123,14 @@
 
     if( quoted )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: X position in NOTES section must not be in quotes\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: X position in NOTES section must not be in quotes" ) );
     }
 
     if( CompareToken( ".END_NOTES", token ) )
-    {
-        // the end of the note section is a special case; although we return 'false'
-        // we do not change the board's state variable and we ensure that errno is 0;
-        // all other false returns set the state to FILE_INVALID
-        errno = 0;
         return false;
-    }
 
     istringstream istr;
     istr.str( token );
@@ -146,29 +138,26 @@
     istr >> xpos;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: X position in NOTES section is not numeric\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: X position in NOTES section is not numeric" ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Y position in NOTES section is missing\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: Y position in NOTES section is missing" ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Y position in NOTES section must not be in quotes\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: Y position in NOTES section must not be in quotes" ) );
     }
 
     istr.clear();
@@ -177,29 +166,26 @@
     istr >> ypos;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Y position in NOTES section is not numeric\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: Y position in NOTES section is not numeric" ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text height in NOTES section is missing\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text height in NOTES section is missing" ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text height in NOTES section must not be in quotes\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text height in NOTES section must not be in quotes" ) );
     }
 
     istr.clear();
@@ -208,29 +194,26 @@
     istr >> height;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text height in NOTES section is not numeric\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text height in NOTES section is not numeric" ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text length in NOTES section is missing\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text length in NOTES section is missing" ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text length in NOTES section must not be in quotes\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text length in NOTES section must not be in quotes" ) );
     }
 
     istr.clear();
@@ -239,20 +222,18 @@
     istr >> length;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text length in NOTES section is not numeric\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text length in NOTES section is not numeric" ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: text value in NOTES section is missing\n";
         aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: text value in NOTES section is missing" ) );
     }
 
     text = token;
@@ -269,7 +250,7 @@
 }
 
 
-bool IDF_NOTE::WriteNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
+bool IDF_NOTE::writeNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
 {
     if( aBoardUnit == UNIT_THOU )
     {
@@ -422,7 +403,7 @@
     return false;
 }
 
-bool IDF_DRILL_DATA::Read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit,
+bool IDF_DRILL_DATA::read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit,
                            IDF3::FILE_STATE aBoardState )
 {
     std::string iline;      // the input line
@@ -436,134 +417,86 @@
     while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
 
     if( ( !aBoardFile.good() && !aBoardFile.eof() ) || iline.empty() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading board drilled holes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading board drilled holes" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within a section (DRILLED HOLES)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: comment within a section (DRILLED HOLES)" ) );
 
     idx = 0;
     GetIDFString( iline, token, quoted, idx );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: drill diameter must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: drill diameter must not be in quotes" ) );
 
     if( CompareToken( ".END_DRILLED_HOLES", token ) )
-    {
-        // the end of the section is a special case; although we return 'false'
-        // we do not change the board's state variable and we ensure that errno is 0;
-        // all other false returns set the state to FILE_INVALID
-        errno = 0;
         return false;
-    }
 
     istringstream istr;
     istr.str( token );
 
     istr >> dia;
     if( istr.fail() )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: drill diameter is not numeric\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: drill diameter is not numeric" ) );
 
     if( ( aBoardUnit == UNIT_MM && dia < IDF_MIN_DIA_MM )
         || ( aBoardUnit != UNIT_MM && dia < IDF_MIN_DIA_THOU ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Invalid drill diameter (too small): " << token << "\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* Invalid drill diameter (too small): '" << token << "'";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing X position for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing X position for drilled hole" ) );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: X position in DRILLED HOLES section must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: X position in DRILLED HOLES section must not be in quotes" ) );
 
     istr.clear();
     istr.str( token );
 
     istr >> x;
     if( istr.fail() )
-    {
-        ERROR_IDF;
-        cerr << "* Violation of specification: X position in DRILLED HOLES section is not numeric\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: X position in DRILLED HOLES section is not numeric" ) );
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing Y position for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing Y position for drilled hole" ) );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Y position in DRILLED HOLES section must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: Y position in DRILLED HOLES section must not be in quotes" ) );
 
     istr.clear();
     istr.str( token );
 
     istr >> y;
     if( istr.fail() )
-    {
-        ERROR_IDF;
-        cerr << "* Violation of specification: Y position in DRILLED HOLES section is not numeric\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: Y position in DRILLED HOLES section is not numeric" ) );
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing PLATING for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing PLATING for drilled hole" ) );
 
     if( CompareToken( "PTH", token ) )
     {
@@ -575,21 +508,17 @@
     }
     else
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: invalid PLATING type ('" << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* Violation of specification: invalid PLATING type ('" << token << "')";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing REFDES for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing REFDES for drilled hole" ) );
 
     if( CompareToken( "BOARD", token ) )
     {
@@ -611,11 +540,9 @@
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing HOLE TYPE for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing HOLE TYPE for drilled hole" ) );
     }
 
     if( CompareToken( "PIN", token ) )
@@ -641,21 +568,17 @@
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: missing OWNER for drilled hole\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: missing OWNER for drilled hole" ) );
 
     if( !ParseOwner( token, owner ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: invalid OWNER for drilled hole ('" << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* Violation of specification: invalid OWNER for drilled hole ('" << token << "')";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( aBoardUnit == UNIT_THOU )
@@ -668,7 +591,7 @@
     return true;
 }
 
-bool IDF_DRILL_DATA::Write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
+bool IDF_DRILL_DATA::write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit )
 {
     std::string holestr;
     std::string refstr;

=== modified file 'utils/idftools/idf_common.h'
--- utils/idftools/idf_common.h	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_common.h	2014-05-29 07:49:39 +0000
@@ -261,6 +261,7 @@
  */
 class IDF_NOTE
 {
+friend class IDF3_BOARD;
 private:
     std::string text;   // note text as per IDFv3
     double xpos;        // text X position as per IDFv3
@@ -268,9 +269,6 @@
     double height;      // text height as per IDFv3
     double length;      // text length as per IDFv3
 
-public:
-    IDF_NOTE();
-
     /**
      * Function ReadNote
      * reads a note entry from an IDFv3 file
@@ -282,7 +280,7 @@
      * @return bool: true if a note item was read, false otherwise. In case of unrecoverable errors
      * an exception is thrown
      */
-    bool ReadNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState, IDF3::IDF_UNIT aBoardUnit );
+    bool readNote( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState, IDF3::IDF_UNIT aBoardUnit );
 
     /**
      * Function WriteNote
@@ -294,7 +292,10 @@
      * @return bool: true if the item was successfully written, false otherwise. In case of
      * unrecoverable errors an exception is thrown
      */
-    bool WriteNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
+    bool writeNote( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
+
+public:
+    IDF_NOTE();
 
     /**
      * Function SetText
@@ -341,6 +342,8 @@
  */
 class IDF_DRILL_DATA
 {
+friend class IDF3_BOARD;
+friend class IDF3_COMPONENT;
 private:
     double dia;
     double x;
@@ -352,6 +355,31 @@
     std::string holetype;
     IDF3::KEY_OWNER owner;
 
+    /**
+     * Function Read
+     * read a drill entry from an IDFv3 file
+     *
+     * @param aBoardFile is an open IDFv3 file; the file position must be within the DRILLED_HOLES section
+     * @param aBoardUnit is the board file's native unit (MM or THOU)
+     * @param aBoardState is the state value of the parser
+     *
+     * @return bool: true if data was successfully read, otherwise false. In case of an
+     * unrecoverable error an exception is thrown
+     */
+    bool read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit, IDF3::FILE_STATE aBoardState );
+
+    /**
+     * Function Write
+     * writes a single line representing a hole within a .DRILLED_HOLES section
+     *
+     * @param aBoardFile is an open BOARD file
+     * @param aBoardUnit is the native unit of the output file
+     *
+     * @return bool: true if the data was successfully written, otherwise false. In case of
+     * an unrecoverable error an exception is thrown
+     */
+    bool write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
+
 public:
     /**
      * Constructor IDF_DRILL_DATA
@@ -392,31 +420,6 @@
     bool Matches( double aDrillDia, double aPosX, double aPosY );
 
     /**
-     * Function Read
-     * read a drill entry from an IDFv3 file
-     *
-     * @param aBoardFile is an open IDFv3 file; the file position must be within the DRILLED_HOLES section
-     * @param aBoardUnit is the board file's native unit (MM or THOU)
-     * @param aBoardState is the state value of the parser
-     *
-     * @return bool: true if data was successfully read, otherwise false. In case of an
-     * unrecoverable error an exception is thrown
-     */
-    bool Read( std::ifstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit, IDF3::FILE_STATE aBoardState );
-
-    /**
-     * Function Write
-     * writes a single line representing a hole within a .DRILLED_HOLES section
-     *
-     * @param aBoardFile is an open BOARD file
-     * @param aBoardUnit is the native unit of the output file
-     *
-     * @return bool: true if the data was successfully written, otherwise false. In case of
-     * an unrecoverable error an exception is thrown
-     */
-    bool Write( std::ofstream& aBoardFile, IDF3::IDF_UNIT aBoardUnit );
-
-    /**
      * Function GettDrillDia
      * returns the drill diameter in mm
      */

=== modified file 'utils/idftools/idf_helpers.cpp'
--- utils/idftools/idf_helpers.cpp	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_helpers.cpp	2014-05-29 07:50:01 +0000
@@ -229,8 +229,13 @@
             break;
 
         default:
-            ERROR_IDF << "Invalid IDF layer" << aLayer << "\n";
-            return false;
+            do{
+                std::ostringstream ostr;
+                ostr << "invalid IDF layer: " << aLayer;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            } while( 0 );
+
             break;
     }
 
@@ -293,3 +298,26 @@
 
     return ostr.str();
 }
+
+std::string IDF3::GetOwnerString( IDF3::KEY_OWNER aOwner )
+{
+    switch( aOwner )
+    {
+        case IDF3::UNOWNED:
+            return "UNOWNED";
+
+        case IDF3::MCAD:
+            return "MCAD";
+
+        case IDF3::ECAD:
+            return "ECAD";
+
+        default:
+            break;
+    }
+
+    ostringstream ostr;
+    ostr << "UNKNOWN: " << aOwner;
+
+    return ostr.str();
+}

=== modified file 'utils/idftools/idf_helpers.h'
--- utils/idftools/idf_helpers.h	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_helpers.h	2014-05-29 07:50:01 +0000
@@ -166,6 +166,7 @@
  */
 std::string GetLayerString( IDF3::IDF_LAYER aLayer );
 
+std::string GetOwnerString( IDF3::KEY_OWNER aOwner );
 }
 
 #endif // IDF_HELPERS_H

=== modified file 'utils/idftools/idf_outlines.cpp'
--- utils/idftools/idf_outlines.cpp	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_outlines.cpp	2014-05-29 07:50:28 +0000
@@ -34,6 +34,97 @@
 using namespace std;
 
 
+static std::string GetOutlineTypeString( IDF3::OUTLINE_TYPE aOutlineType )
+{
+    switch( aOutlineType )
+    {
+        case OTLN_BOARD:
+            return ".BOARD_OUTLINE";
+
+        case OTLN_OTHER:
+            return ".OTHER_OUTLINE";
+
+        case OTLN_PLACE:
+            return ".PLACEMENT_OUTLINE";
+
+        case OTLN_ROUTE:
+            return ".ROUTE_OUTLINE";
+
+        case OTLN_PLACE_KEEPOUT:
+            return ".PLACE_KEEPOUT";
+
+        case OTLN_ROUTE_KEEPOUT:
+            return ".ROUTE_KEEPOUT";
+
+        case OTLN_VIA_KEEPOUT:
+            return ".VIA_KEEPOUT";
+
+        case OTLN_GROUP_PLACE:
+            return ".PLACE_REGION";
+
+        case OTLN_COMPONENT:
+            return "COMPONENT OUTLINE";
+
+        default:
+            break;
+    }
+
+    std::ostringstream ostr;
+    ostr << "[INVALID OUTLINE TYPE VALUE]:" << aOutlineType;
+
+    return ostr.str();
+}
+
+
+static bool CheckOwnership( const char* aSourceFile, int aSourceLine, const char* aSourceFunc,
+                            IDF3_BOARD* aParent, IDF3::KEY_OWNER aOwnerCAD,
+                            IDF3::OUTLINE_TYPE aOutlineType, std::string& aErrorString )
+{
+    if( aParent == NULL )
+    {
+        ostringstream ostr;
+        ostr << aSourceFile << ":" << aSourceLine << ":" << aSourceFunc << "():\n";
+        ostr << "* BUG: outline's parent not set; cannot enforce ownership rules\n";
+        ostr << "* outline type: " << GetOutlineTypeString( aOutlineType );
+        aErrorString = ostr.str();
+
+        return false;
+    }
+
+    // note: component outlines have no owner so we don't care about
+    // who modifies them
+    if( aOwnerCAD == UNOWNED || aOutlineType == IDF3::OTLN_COMPONENT )
+        return true;
+
+    IDF3::CAD_TYPE parentCAD = aParent->GetCadType();
+
+    if( aOwnerCAD == MCAD && parentCAD == CAD_MECH )
+        return true;
+
+    if( aOwnerCAD == ECAD && parentCAD == CAD_ELEC )
+        return true;
+
+    do
+    {
+        ostringstream ostr;
+        ostr << aSourceFile << ":" << aSourceLine << ":" << aSourceFunc << "():\n";
+        ostr << "* ownership violation; CAD type is ";
+
+        if( parentCAD == CAD_MECH )
+            ostr << "MCAD ";
+        else
+            ostr << "ECAD ";
+
+        ostr << "while outline owner is " << GetOwnerString( aOwnerCAD ) << "\n";
+        ostr << "* outline type: " << GetOutlineTypeString( aOutlineType );
+        aErrorString = ostr.str();
+
+    } while( 0 );
+
+    return false;
+}
+
+
 /*
  * CLASS: BOARD OUTLINE
  */
@@ -50,7 +141,7 @@
 
 BOARD_OUTLINE::~BOARD_OUTLINE()
 {
-    Clear();
+    clear();
     return;
 }
 
@@ -59,7 +150,7 @@
     return outlineType;
 }
 
-bool BOARD_OUTLINE::readOutlines( std::ifstream& aBoardFile )
+void BOARD_OUTLINE::readOutlines( std::ifstream& aBoardFile )
 {
     // reads the outline data from a file
     double x, y, ang;
@@ -81,7 +172,7 @@
     std::streampos pos;
 
     // destroy any existing outline data
-    ClearOutlines();
+    clearOutlines();
 
     while( aBoardFile.good() )
     {
@@ -93,9 +184,13 @@
 
         if( quoted )
         {
-            ERROR_IDF << "invalid outline; FIELD 1 is quoted\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+            ostr << " is quoted\n";
+            ostr << "* line: '" << iline << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         // check for the end of the section
@@ -110,8 +205,11 @@
             {
                 if( npts > 0 && !closed )
                 {
-                    ERROR_IDF << "invalid outline (not closed)\n";
-                    return false;
+                    ostringstream ostr;
+                    ostr << "invalid outline (not closed)\n";
+                    ostr << "* file position: " << pos;
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                 }
 
                 // verify winding
@@ -121,23 +219,24 @@
                     {
                         ERROR_IDF << "invalid IDF3 file (BOARD_OUTLINE)\n";
                         cerr << "* first outline is not in CCW order\n";
-//#warning TO BE IMPLEMENTED
+#warning TO BE IMPLEMENTED
                         // outlines.front()->EnsureWinding( false );
-                        return true;
+                        return;
                     }
 
                     if( outlines.size() > 1 && outlines.back()->IsCCW() && !outlines.back()->IsCircle() )
                     {
                         ERROR_IDF << "invalid IDF3 file (BOARD_OUTLINE)\n";
-                        cerr << "* cutout points are not in CW order\n";
-//#warning TO BE IMPLEMENTED
+                        cerr << "* final cutout does not have points in CW order\n";
+                        cerr << "* file position: " << pos << "\n";
+#warning TO BE IMPLEMENTED
                         // outlines.front()->EnsureWinding( true );
-                        return true;
+                        return;
                     }
                 }
             }
 
-            return true;
+            return;
         }
 
         tstr.clear();
@@ -149,12 +248,20 @@
             if( outlineType == OTLN_COMPONENT && CompareToken( "PROP", entry ) )
             {
                 aBoardFile.seekg( pos );
-                return true;
+                return;
             }
 
-            ERROR_IDF << "invalid outline; FIELD 1 is not numeric\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            do{
+                ostringstream ostr;
+
+                ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+                ostr << " is not numeric\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* file position: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+
+            } while( 0 );
         }
 
         if( tmp != loopidx )
@@ -163,9 +270,14 @@
 
             if( tmp < 0 )
             {
-                ERROR_IDF << "invalid outline; FIELD 1 is invalid\n";
-                std::cerr << "    LINE: " << iline << "\n";
-                return false;
+                ostringstream ostr;
+
+                ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+                ostr << " is invalid\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* file position: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
 
             if( loopidx == -1 )
@@ -177,19 +289,27 @@
                     if( tmp == 0 || tmp == 1 )
                     {
                         op = new IDF_OUTLINE;
+
                         if( op == NULL )
                         {
-                            ERROR_IDF << "memory allocation failed\n";
-                            return false;
+                            clearOutlines();
+                            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                              "memory allocation failed" ) );
                         }
+
                         outlines.push_back( op );
                         loopidx = tmp;
                     }
                     else
                     {
-                        ERROR_IDF << "invalid outline; FIELD 1 is invalid (must be 0 or 1)\n";
-                        std::cerr << "    LINE: " << iline << "\n";
-                        return false;
+                        ostringstream ostr;
+
+                        ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+                        ostr << " is invalid (must be 0 or 1)\n";
+                        ostr << "* line: '" << iline << "'\n";
+                        ostr << "* file position: " << pos;
+
+                        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                     }
                 }
                 else
@@ -197,17 +317,23 @@
                     // outline *MUST* have a Loop Index of 0
                     if( tmp != 0 )
                     {
-                        ERROR_IDF << "invalid outline; first outline of a BOARD or PANEL must have a Loop Index of 0\n";
-                        std::cerr << "    LINE: " << iline << "\n";
-                        return false;
+                        ostringstream ostr;
+
+                        ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+                        ostr << " is invalid (must be 0)\n";
+                        ostr << "* line: '" << iline << "'\n";
+                        ostr << "* file position: " << pos;
+
+                        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                     }
 
                     op = new IDF_OUTLINE;
 
                     if( op == NULL )
                     {
-                        ERROR_IDF << "memory allocation failed\n";
-                        return false;
+                        clearOutlines();
+                        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                          "memory allocation failed" ) );
                     }
 
                     outlines.push_back( op );
@@ -220,33 +346,49 @@
                 // outline for cutout
                 if( single )
                 {
-                    ERROR_IDF << "invalid outline; a simple outline type may only have one outline\n";
-                    std::cerr << "    LINE: " << iline << "\n";
-                    return false;
+                    ostringstream ostr;
+
+                    ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType );
+                    ostr << " section may only have one outline\n";
+                    ostr << "* line: '" << iline << "'\n";
+                    ostr << "* file position: " << pos;
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                 }
 
                 if( tmp - loopidx != 1 )
                 {
-                    ERROR_IDF << "invalid outline; cutouts must be numbered in order from 1 onwards\n";
-                    std::cerr << "    LINE: " << iline << "\n";
-                    return false;
+                    ostringstream ostr;
+
+                    ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType );
+                    ostr << " section must have cutouts in numeric order from 1 onwards\n";
+                    ostr << "* line: '" << iline << "'\n";
+                    ostr << "* file position: " << pos;
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                 }
 
                 // verify winding of previous outline
                 if( ( loopidx = 0 && !op->IsCCW() )
                     || ( loopidx > 0 && op->IsCCW() ) )
                 {
-                    ERROR_IDF << "invalid outline (violation of loop point order rules by Loop Index "
-                    << loopidx << ")\n";
-                    return false;
+                    ostringstream ostr;
+
+                    ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+                    ostr << "* violation of loop point order rules by Loop Index " << loopidx << "\n";
+                    ostr << "* line: '" << iline << "'\n";
+                    ostr << "* file position: " << pos;
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                 }
 
                 op = new IDF_OUTLINE;
 
                 if( op == NULL )
                 {
-                    ERROR_IDF << "memory allocation failed\n";
-                    return false;
+                    clearOutlines();
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                      "memory allocation failed" ) );
                 }
 
                 outlines.push_back( op );
@@ -259,23 +401,38 @@
 
         if( op == NULL )
         {
-            ERROR_IDF << "invalid outline; FIELD 1 is invalid\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 1 of " << GetOutlineTypeString( outlineType );
+            ostr << " is invalid\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, entry, quoted, idx ) )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 2 does not exist\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 2 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " does not exist\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( quoted )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 2 is quoted\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 2 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " must not be in quotes\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         tstr.clear();
@@ -284,23 +441,38 @@
         tstr >> x;
         if( tstr.fail() )
         {
-            ERROR_IDF << "invalid RECORD 3, invalid X value in FIELD 2\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 2 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " is an invalid X value\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, entry, quoted, idx ) )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 3 does not exist\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 3 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " does not exist\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( quoted )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 3 is quoted\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 3 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " must not be in quotes\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         tstr.clear();
@@ -309,23 +481,38 @@
         tstr >> y;
         if( tstr.fail() )
         {
-            ERROR_IDF << "invalid RECORD 3, invalid Y value in FIELD 3\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 3 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " is an invalid Y value\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, entry, quoted, idx ) )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 4 does not exist\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 4 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " does not exist\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( quoted )
         {
-            ERROR_IDF << "invalid RECORD 3, FIELD 4 is quoted\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 4 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " must not be in quotes\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         tstr.clear();
@@ -334,9 +521,14 @@
         tstr >> ang;
         if( tstr.fail() )
         {
-            ERROR_IDF << "invalid ANGLE value in FIELD 3\n";
-            std::cerr << "    LINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: RECORD 3, FIELD 4 of ";
+            ostr << GetOutlineTypeString( outlineType ) << " is not a valid angle\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         // the line was successfully read; convert to mm if necessary
@@ -355,9 +547,15 @@
             // ensure that the first point is not an arc specification
             if( ang < -MIN_ANG || ang > MIN_ANG )
             {
-                ERROR_IDF << "invalid RECORD 3, first point has non-zero angle\n";
-                std::cerr << "    LINE: " << iline << "\n";
-                return false;
+                ostringstream ostr;
+
+                ostr << "\n* invalid outline: RECORD 3 of ";
+                ostr << GetOutlineTypeString( outlineType ) << "\n";
+                ostr << "* violation: first point of an outline has a non-zero angle\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* file position: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
         }
         else
@@ -365,9 +563,15 @@
             // Nth point
             if( closed )
             {
-                ERROR_IDF << "invalid RECORD 3; adding a segment to a closed outline\n";
-                std::cerr << "    LINE: " << iline << "\n";
-                return false;
+                ostringstream ostr;
+
+                ostr << "\n* invalid outline: RECORD 3 of ";
+                ostr << GetOutlineTypeString( outlineType ) << "\n";
+                ostr << "* violation: adding a segment to a closed outline\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* file position: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
 
             curPt.x = x;
@@ -384,8 +588,9 @@
 
             if( sp == NULL )
             {
-                ERROR_IDF << "memory allocation failure\n";
-                return false;
+                clearOutlines();
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "memory allocation failed" ) );
             }
 
             if( sp->IsCircle() )
@@ -393,10 +598,17 @@
                 // this is  a circle; the loop is closed
                 if( op->size() != 0 )
                 {
-                    ERROR_IDF << "invalid RECORD 3; adding a circle to a non-empty outline\n";
-                    std::cerr << "    LINE: " << iline << "\n";
                     delete sp;
-                    return false;
+
+                    ostringstream ostr;
+
+                    ostr << "\n* invalid outline: RECORD 3 of ";
+                    ostr << GetOutlineTypeString( outlineType ) << "\n";
+                    ostr << "* violation: adding a circle to a non-empty outline\n";
+                    ostr << "* line: '" << iline << "'\n";
+                    ostr << "* file position: " << pos;
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
                 }
 
                 closed = true;
@@ -414,10 +626,12 @@
     }   //  while( aBoardFile.good() )
 
     // NOTE:
-    // 1. ideally we would ensure that there are no arcs with a radius of 0; this entails
-    //    actively calculating the last point as the previous entry could have been an instruction
-
-    return false;
+    // 1. ideally we would ensure that there are no arcs with a radius of 0
+
+    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                      "problems reading file (premature end of outline)" ) );
+
+    return;
 }
 
 bool BOARD_OUTLINE::writeComments( std::ofstream& aBoardFile )
@@ -457,21 +671,16 @@
     return !aBoardFile.fail();
 }
 
-bool BOARD_OUTLINE::writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex )
+void BOARD_OUTLINE::writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex )
 {
-    // TODO: check the stream integrity
-
     std::list<IDF_SEGMENT*>::iterator bo;
     std::list<IDF_SEGMENT*>::iterator eo;
 
     if( aOutline->size() == 1 )
     {
         if( !aOutline->front()->IsCircle() )
-        {
-            // this is a bad outline
-            ERROR_IDF << "bad outline (single segment item, not circle)\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "bad outline (single segment item, not circle)" ) );
 
         if( single )
             aIndex = 0;
@@ -499,7 +708,7 @@
             << (aOutline->front()->endPoint.y / IDF_MM_TO_THOU) << " 360\n";
         }
 
-        return !aBoardFile.fail();
+        return;
     }
 
     // ensure that the very last point is the same as the very first point
@@ -709,13 +918,13 @@
         }
     }
 
-    return !aBoardFile.fail();
+    return;
 }
 
-bool BOARD_OUTLINE::writeOutlines( std::ofstream& aBoardFile )
+void BOARD_OUTLINE::writeOutlines( std::ofstream& aBoardFile )
 {
     if( outlines.empty() )
-        return true;
+        return;
 
     int idx = 0;
     std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
@@ -723,19 +932,28 @@
 
     while( itS != itE )
     {
-        if( !writeOutline( aBoardFile, *itS, idx++ ) )
-            return false;
-
+        writeOutline( aBoardFile, *itS, idx++ );
         ++itS;
     }
 
-    return true;
+    return;
 }
 
-void BOARD_OUTLINE::SetUnit( IDF3::IDF_UNIT aUnit )
+bool BOARD_OUTLINE::SetUnit( IDF3::IDF_UNIT aUnit )
 {
+    if( aUnit != UNIT_MM && aUnit != UNIT_THOU )
+    {
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+        ostr << "* BUG: invalid IDF UNIT (must be one of UNIT_MM or UNIT_THOU): " << aUnit << "\n";
+        ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+        errormsg = ostr.str();
+
+        return false;
+    }
+
     unit = aUnit;
-    return;
+    return true;
 }
 
 IDF3::IDF_UNIT BOARD_OUTLINE::GetUnit( void )
@@ -743,21 +961,37 @@
     return unit;
 }
 
-bool BOARD_OUTLINE::SetThickness( double aThickness )
+bool BOARD_OUTLINE::setThickness( double aThickness )
 {
     if( aThickness < 0.0 )
+    {
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+        ostr << "* BUG: aThickness < 0.0\n";
+        ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+        errormsg = ostr.str();
+
         return false;
+    }
 
     thickness = aThickness;
     return true;
 }
 
+bool BOARD_OUTLINE::SetThickness( double aThickness )
+{
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    return setThickness( aThickness );
+}
+
 double BOARD_OUTLINE::GetThickness( void )
 {
     return thickness;
 }
 
-bool BOARD_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+void BOARD_OUTLINE::readData( std::ifstream& aBoardFile, const std::string& aHeader )
 {
     //  BOARD_OUTLINE (PANEL_OUTLINE)
     //      .BOARD_OUTLINE  [OWNER]
@@ -768,25 +1002,35 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos;
+
+    pos = aBoardFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
-    {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, "invalid invocation: blank header line" ) );
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section names may not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !CompareToken( ".BOARD_OUTLINE", token ) )
     {
-        ERROR_IDF << "not a board outline:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: not a board outline\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
@@ -806,27 +1050,41 @@
     // check RECORD 2
     std::string iline;
     bool comment = false;
-    std::streampos pos;
-
     while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
 
     if( ( !aBoardFile.good() && !aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .BOARD_OUTLINE section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .BOARD_OUTLINE section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within .BOARD_OUTLINE section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .BOARD_OUTLINE section (no thickness)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no thickness specified\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     std::stringstream teststr;
@@ -835,16 +1093,20 @@
     teststr >> thickness;
     if( teststr.fail() )
     {
-        ERROR_IDF << "bad .BOARD_OUTLINE section (invalid RECORD 2)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid RECORD 2 (thickness)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( unit == UNIT_THOU )
         thickness *= IDF_MM_TO_THOU;
 
     // read RECORD 3 values
-    // XXX - check the return value - we may have empty lines and what-not
     readOutlines( aBoardFile );
 
     // check RECORD 4
@@ -852,27 +1114,44 @@
 
     if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .BOARD_OUTLINE section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .BOARD_OUTLINE section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !CompareToken( ".END_BOARD_OUTLINE", iline ) )
     {
-        ERROR_IDF << "bad .BOARD_OUTLINE section (no .END_BOARD_OUTLINE)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no .END_BOARD_OUTLINE found\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
-    return true;
+    return;
 }
 
-bool BOARD_OUTLINE::WriteData( std::ofstream& aBoardFile )
+
+void BOARD_OUTLINE::writeData( std::ofstream& aBoardFile )
 {
     writeComments( aBoardFile );
 
@@ -886,24 +1165,33 @@
     else
         aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (thickness / IDF_MM_TO_THOU) << "\n";
 
-    if( !writeOutlines( aBoardFile ) )
-        return false;
+    writeOutlines( aBoardFile );
 
     aBoardFile << ".END_BOARD_OUTLINE\n\n";
 
-    return !aBoardFile.fail();
+    return;
 }
 
-void BOARD_OUTLINE::Clear( void )
+void BOARD_OUTLINE::clear( void )
 {
     comments.clear();
-    ClearOutlines();
+    clearOutlines();
 
     owner = UNOWNED;
     return;
 }
 
-void BOARD_OUTLINE::SetParent( IDF3_BOARD* aParent )
+bool BOARD_OUTLINE::Clear( void )
+{
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
+
+    return true;
+}
+
+void BOARD_OUTLINE::setParent( IDF3_BOARD* aParent )
 {
     parent = aParent;
 }
@@ -913,21 +1201,41 @@
     return parent;
 }
 
+bool BOARD_OUTLINE::addOutline( IDF_OUTLINE* aOutline )
+{
+    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
+    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
+
+    try
+    {
+        while( itS != itE )
+        {
+            if( *itS == aOutline )
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "duplicate outline pointer" ) );
+
+            ++itS;
+        }
+
+        outlines.push_back( aOutline );
+
+    }
+    catch( std::exception& e )
+    {
+        errormsg = e.what();
+
+        return false;
+    }
+
+    return true;
+}
+
 bool BOARD_OUTLINE::AddOutline( IDF_OUTLINE* aOutline )
 {
-    std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
-    std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
-
-    while( itS != itE )
-    {
-        if( *itS == aOutline )
-            return false;
-
-        ++itS;
-    }
-
-    outlines.push_back( aOutline );
-    return true;
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    return addOutline( aOutline );
 }
 
 bool BOARD_OUTLINE::DelOutline( IDF_OUTLINE* aOutline )
@@ -935,8 +1243,22 @@
     std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
     std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
 
+    if( !aOutline )
+    {
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+        ostr << "* BUG: NULL aOutline pointer\n";
+        ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+        errormsg = ostr.str();
+
+        return false;
+    }
+
     if( outlines.empty() )
+    {
+        errormsg.clear();
         return false;
+    }
 
     // if there are more than 1 outlines it makes no sense to delete
     // the first outline (board outline) since that would have the
@@ -944,7 +1266,15 @@
     if( aOutline == outlines.front() )
     {
         if( outlines.size() > 1 )
+        {
+            ostringstream ostr;
+            ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+            ostr << "* BUG: attempting to delete first outline in list\n";
+            ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+            errormsg = ostr.str();
+
             return false;
+        }
 
         outlines.clear();
         return true;
@@ -961,19 +1291,32 @@
         ++itS;
     }
 
+    errormsg.clear();
     return false;
 }
 
+
 bool BOARD_OUTLINE::DelOutline( size_t aIndex )
 {
     std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
     std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
 
     if( outlines.empty() )
+    {
+        errormsg.clear();
         return false;
+    }
 
     if( aIndex >= outlines.size() )
+    {
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+        ostr << "* BUG: index out of bounds (" << aIndex << " / " << outlines.size() << ")\n";
+        ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+        errormsg = ostr.str();
+
         return false;
+    }
 
     if( aIndex == 0 )
     {
@@ -981,7 +1324,15 @@
         // the first outline (board outline) since that would have the
         // undesirable effect of substituting a cutout outline as the board outline
         if( outlines.size() > 1 )
+        {
+            ostringstream ostr;
+            ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+            ostr << "* BUG: attempting to delete first outline in list\n";
+            ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+            errormsg = ostr.str();
+
             return false;
+        }
 
         delete *itS;
         outlines.clear();
@@ -1028,36 +1379,11 @@
 
 bool BOARD_OUTLINE::SetOwner( IDF3::KEY_OWNER aOwner )
 {
-    // if this is a COMPONENT OUTLINE there can be no owner
-    if( outlineType == IDF3::OTLN_COMPONENT )
-        return true;
-
-    // if no one owns the outline, any system may
-    // set the owner
-    if( owner == UNOWNED )
-    {
-        owner = aOwner;
-        return true;
-    }
-
-    // if the outline is owned, only the owning
-    // CAD system can make alterations
-    if( parent == NULL )
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
         return false;
 
-    if( owner == MCAD && parent->GetCadType() == CAD_MECH )
-    {
-        owner = aOwner;
-        return true;
-    }
-
-    if( owner == ECAD && parent->GetCadType() == CAD_ELEC )
-    {
-        owner = aOwner;
-        return true;
-    }
-
-    return false;
+    owner = aOwner;
+    return true;
 }
 
 bool BOARD_OUTLINE::IsSingle( void )
@@ -1065,7 +1391,7 @@
     return single;
 }
 
-void BOARD_OUTLINE::ClearOutlines( void )
+void BOARD_OUTLINE::clearOutlines( void )
 {
     std::list< IDF_OUTLINE* >::iterator itS = outlines.begin();
     std::list< IDF_OUTLINE* >::iterator itE = outlines.end();
@@ -1136,19 +1462,24 @@
 /*
  * CLASS: OTHER_OUTLINE
  */
-OTHER_OUTLINE::OTHER_OUTLINE()
+OTHER_OUTLINE::OTHER_OUTLINE( IDF3_BOARD* aParent )
 {
+    setParent( aParent );
     outlineType = OTLN_OTHER;
     side = LYR_INVALID;
-    single = true;
+    single = false;
 
     return;
 }
 
-void OTHER_OUTLINE::SetOutlineIdentifier( const std::string aUniqueID )
+bool OTHER_OUTLINE::SetOutlineIdentifier( const std::string aUniqueID )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     uniqueID = aUniqueID;
-    return;
+
+    return true;
 }
 
 const std::string& OTHER_OUTLINE::GetOutlineIdentifier( void )
@@ -1158,6 +1489,9 @@
 
 bool OTHER_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     switch( aSide )
     {
         case LYR_TOP:
@@ -1166,9 +1500,17 @@
             break;
 
         default:
-            ERROR_IDF << "invalid side (" << aSide << "); must be one of TOP/BOTTOM\n";
+            do{
+                ostringstream ostr;
+                ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+                ostr << "* BUG: invalid side (" << aSide << "); must be one of TOP/BOTTOM\n";
+                ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+                errormsg = ostr.str();
+            } while( 0 );
+
             side = LYR_INVALID;
             return false;
+
             break;
     }
 
@@ -1180,7 +1522,7 @@
     return side;
 }
 
-bool OTHER_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+void OTHER_OUTLINE::readData( std::ifstream& aBoardFile, const std::string& aHeader )
 {
     // OTHER_OUTLINE/VIA_KEEPOUT
     //     .OTHER_OUTLINE  [OWNER]
@@ -1191,36 +1533,50 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos = aBoardFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
     {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
+        ostringstream ostr;
+        ostr << "\n* BUG: invalid invocation: blank header line\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section names must not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_OTHER )
     {
         if( !CompareToken( ".OTHER_OUTLINE", token ) )
         {
-            ERROR_IDF << "not an OTHER outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* BUG: not an .OTHER outline\n";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
     else
     {
         if( !CompareToken( ".VIA_KEEPOUT", token ) )
         {
-            ERROR_IDF << "not a VIA_KEEPOUT outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* BUG: not a .VIA_KEEPOUT outline\n";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
@@ -1240,7 +1596,6 @@
 
     std::string iline;
     bool comment = false;
-    std::streampos pos;
 
     if( outlineType == OTLN_OTHER )
     {
@@ -1250,29 +1605,52 @@
 
         if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (premature end)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: premature end\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         idx = 0;
         if( comment )
         {
-            ERROR_IDF << "comment within .OTHER_OUTLINE section\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: comment within .OTHER_OUTLINE section\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (no outline identifier)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no outline identifier\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         uniqueID = token;
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (no thickness)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no thickness\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         std::stringstream teststr;
@@ -1281,9 +1659,14 @@
         teststr >> thickness;
         if( teststr.fail() )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (invalid RECORD 2 reading thickness)\n";
-            std::cerr << "\tLINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: invalid thickness\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( unit == UNIT_THOU )
@@ -1291,15 +1674,26 @@
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (no board side)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no board side\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !ParseIDFLayer( token, side ) || ( side != LYR_TOP && side != LYR_BOTTOM ) )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (invalid side, must be TOP/BOTTOM only)\n";
-            std::cerr << "\tLINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: invalid side (must be TOP or BOTTOM only)\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
@@ -1311,42 +1705,63 @@
 
     if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .OTHER_OUTLINE/.VIA_KEEPOUT section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .OTHER_OUTLINE/.VIA_KEEPOUT section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_OTHER )
     {
         if( !CompareToken( ".END_OTHER_OUTLINE", iline ) )
         {
-            ERROR_IDF << "bad .OTHER_OUTLINE section (no .END_OTHER_OUTLINE)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_OTHER_OUTLINE found\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
     else
     {
         if( !CompareToken( ".END_VIA_KEEPOUT", iline ) )
         {
-            ERROR_IDF << "bad .VIA_KEEPOUT section (no .END_VIA_KEEPOUT)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_VIA_KEEPOUT found\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
-    return true;
+    return;
 }
 
-bool OTHER_OUTLINE::WriteData( std::ofstream& aBoardFile )
+void OTHER_OUTLINE::writeData( std::ofstream& aBoardFile )
 {
     // this section is optional; do not write if not required
     if( outlines.empty() )
-        return true;
+        return;
 
     writeComments( aBoardFile );
 
@@ -1376,15 +1791,19 @@
                 break;
 
             default:
-                ERROR_IDF << "Invalid OTHER_OUTLINE side (neither top nor bottom): " << side << "\n";
-                return false;
+                do{
+                    ostringstream ostr;
+                    ostr << "\n* invalid OTHER_OUTLINE side (neither top nor bottom): ";
+                    ostr << side;
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+                } while( 0 );
+
                 break;
         }
     }
 
     // write RECORD 3
-    if( !writeOutlines( aBoardFile ) )
-        return false;
+    writeOutlines( aBoardFile );
 
     // write RECORD 4
     if( outlineType == OTLN_OTHER )
@@ -1392,33 +1811,42 @@
     else
         aBoardFile << ".END_VIA_KEEPOUT\n\n";
 
-    return !aBoardFile.fail();
+    return;
 }
 
-void OTHER_OUTLINE::Clear( void )
+
+bool OTHER_OUTLINE::Clear( void )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
     side = LYR_INVALID;
     uniqueID.clear();
 
-    BOARD_OUTLINE::Clear();
-
-    return;
+    return true;
 }
 
 
 /*
  * CLASS: ROUTE_OUTLINE
  */
-ROUTE_OUTLINE::ROUTE_OUTLINE()
+ROUTE_OUTLINE::ROUTE_OUTLINE( IDF3_BOARD* aParent )
 {
+    setParent( aParent );
     outlineType = OTLN_ROUTE;
     single = true;
     layers = LYR_INVALID;
 }
 
-void ROUTE_OUTLINE::SetLayers( IDF3::IDF_LAYER aLayer )
+bool ROUTE_OUTLINE::SetLayers( IDF3::IDF_LAYER aLayer )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     layers = aLayer;
+
+    return true;
 }
 
 IDF3::IDF_LAYER ROUTE_OUTLINE::GetLayers( void )
@@ -1426,7 +1854,7 @@
     return layers;
 }
 
-bool ROUTE_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+void ROUTE_OUTLINE::readData( std::ifstream& aBoardFile, const std::string& aHeader )
 {
     //  ROUTE_OUTLINE (or ROUTE_KEEPOUT)
     //      .ROUTE_OUTLINE [OWNER]
@@ -1437,37 +1865,37 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos = aBoardFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
     {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invalid invocation; blank header line" ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section names must not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_ROUTE )
     {
         if( !CompareToken( ".ROUTE_OUTLINE", token ) )
-        {
-            ERROR_IDF << "not a ROUTE outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* BUG: not a ROUTE outline" ) );
     }
     else
     {
         if( !CompareToken( ".ROUTE_KEEPOUT", token ) )
-        {
-            ERROR_IDF << "not a ROUTE KEEPOUT outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* BUG: not a ROUTE KEEPOUT outline" ) );
     }
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
@@ -1488,41 +1916,67 @@
     // [layers: TOP, BOTTOM, BOTH, INNER, ALL]
     std::string iline;
     bool comment = false;
-    std::streampos pos;
 
     while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
 
     if( !aBoardFile.good() )
     {
-        ERROR_IDF << "bad .ROUTE_OUTLINE/KEEPOUT section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .ROUTE_OUTLINE/KEEPOUT section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within a section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .ROUTE_OUTLINE/KEEPOUT section (no layers specification)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no layers specification\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( quoted )
     {
-        ERROR_IDF << "bad .ROUTE_OUTLINE/KEEPOUT section (layers may not be quoted)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: layers specification must not be in quotes\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !ParseIDFLayer( token, layers ) )
     {
-        ERROR_IDF << "bad .ROUTE_OUTLINE/KEEPOUT section (invalid layer)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid layers specification\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     // read RECORD 3 values
@@ -1533,49 +1987,68 @@
 
     if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .ROUTE_OUTLINE/KEEPOUT section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .ROUTE_OUTLINE/KEEPOUT section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_ROUTE )
     {
         if( !CompareToken( ".END_ROUTE_OUTLINE", iline ) )
         {
-            ERROR_IDF << "bad .ROUTE_OUTLINE section (no .END_ROUTE_OUTLINE)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_ROUTE_OUTLINE found\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
     else
     {
         if( !CompareToken( ".END_ROUTE_KEEPOUT", iline ) )
         {
-            ERROR_IDF << "bad .ROUTE_KEEPOUT section (no .END_ROUTE_KEEPOUT)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_ROUTE_KEEPOUT found\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
-    return true;
+    return;
 }
 
 
-bool ROUTE_OUTLINE::WriteData( std::ofstream& aBoardFile )
+void ROUTE_OUTLINE::writeData( std::ofstream& aBoardFile )
 {
     // this section is optional; do not write if not required
     if( outlines.empty() )
-        return true;
+        return;
 
     if( layers == LYR_INVALID )
-    {
-        ERROR_IDF << "layer not specified\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "layer not specified" ) );
 
     writeComments( aBoardFile );
 
@@ -1592,8 +2065,7 @@
     aBoardFile << "\n";
 
     // write RECORD 3
-    if( !writeOutlines( aBoardFile ) )
-        return false;
+    writeOutlines( aBoardFile );
 
     // write RECORD 4
     if( outlineType == OTLN_ROUTE )
@@ -1601,31 +2073,39 @@
     else
         aBoardFile << ".END_ROUTE_KEEPOUT\n\n";
 
-    return !aBoardFile.fail();
+    return;
 }
 
 
-void ROUTE_OUTLINE::Clear( void )
+bool ROUTE_OUTLINE::Clear( void )
 {
-    BOARD_OUTLINE::Clear();
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
     layers = LYR_INVALID;
-    return;
+
+    return true;
 }
 
 
 /*
  * CLASS: PLACE_OUTLINE
  */
-PLACE_OUTLINE::PLACE_OUTLINE()
+PLACE_OUTLINE::PLACE_OUTLINE( IDF3_BOARD* aParent )
 {
+    setParent( aParent );
     outlineType = OTLN_PLACE;
     single = true;
     thickness = 0.0;
     side = LYR_INVALID;
 }
 
-void PLACE_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
+bool PLACE_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     switch( aSide )
     {
         case LYR_TOP:
@@ -1635,32 +2115,52 @@
             break;
 
         default:
-            // XXX - throw
-            ERROR_IDF << "invalid layer (" << aSide << "): must be one of TOP/BOTTOM/BOTH\n";
-            side = LYR_INVALID;
-            return;
+            do{
+                side = LYR_INVALID;
+                ostringstream ostr;
+                ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+                ostr << "* BUG: invalid layer (" << aSide << "): must be one of TOP/BOTTOM/BOTH\n";
+                ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+                errormsg = ostr.str();
+
+                return false;
+            } while( 0 );
+
             break;
     }
 
-    return;
+    return true;
 }
 
+
 IDF3::IDF_LAYER PLACE_OUTLINE::GetSide( void )
 {
     return side;
 }
 
-void PLACE_OUTLINE::SetMaxHeight( double aHeight )
+
+bool PLACE_OUTLINE::SetMaxHeight( double aHeight )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     if( aHeight < 0.0 )
     {
-        ERROR_IDF << "invalid height (must be >= 0.0); default to 0\n";
         thickness = 0.0;
-        return;
+
+        do{
+            ostringstream ostr;
+            ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+            ostr << "* BUG: invalid height (" << aHeight << "): must be >= 0.0";
+            ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+            errormsg = ostr.str();
+
+            return false;
+        } while( 0 );
     }
 
     thickness = aHeight;
-    return;
+    return true;
 }
 
 double PLACE_OUTLINE::GetMaxHeight( void )
@@ -1668,7 +2168,7 @@
     return thickness;
 }
 
-bool PLACE_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+void PLACE_OUTLINE::readData( std::ifstream& aBoardFile, const std::string& aHeader )
 {
     //  PLACE_OUTLINE/KEEPOUT
     //      .PLACE_OUTLINE [OWNER]
@@ -1679,37 +2179,35 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos = aBoardFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
-    {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invalid invocation: blank header line\n" ) );
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section name must not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_PLACE )
     {
         if( !CompareToken( ".PLACE_OUTLINE", token ) )
-        {
-            ERROR_IDF << "not a PLACE outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* BUG: not a .PLACE_OUTLINE" ) );
     }
     else
     {
         if( !CompareToken( ".PLACE_KEEPOUT", token ) )
-        {
-            ERROR_IDF << "not a PLACE_KEEPOUT outline:\n";
-            std::cerr << "\tLINE: " << aHeader << "\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* BUG: not a .PLACE_KEEPOUT" ) );
     }
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
@@ -1730,41 +2228,68 @@
     // [board side: Top/Bot/Both] [height]
     std::string iline;
     bool comment = false;
-    std::streampos pos;
 
     while( aBoardFile.good() && !FetchIDFLine( aBoardFile, iline, comment, pos ) );
 
     if( !aBoardFile.good() )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .PLACE_OUTLINE/KEEPOUT section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within the section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (no board side information)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no board side information\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !ParseIDFLayer( token, side ) ||
         ( side != LYR_TOP && side != LYR_BOTTOM && side != LYR_BOTH ) )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (invalid side, must be one of TOP/BOTTOM/BOTH)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid board side: must be one of TOP/BOTTOM/BOTH\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (no height)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no height specified\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     std::stringstream teststr;
@@ -1773,9 +2298,14 @@
     teststr >> thickness;
     if( teststr.fail() )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (invalid RECORD 2 reading height)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid height\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( unit == UNIT_THOU )
@@ -1789,44 +2319,51 @@
 
     if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .PLACE_OUTLINE/KEEPOUT section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .PLACE_OUTLINE/KEEPOUT section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( outlineType == OTLN_PLACE )
     {
         if( !GetIDFString( iline, token, quoted, idx )
             || !CompareToken( ".END_PLACE_OUTLINE", token ) )
-        {
-            ERROR_IDF << "bad .PLACE_OUTLINE section (no .END_PLACE_OUTLINE)\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "invalid .PLACE_OUTLINE section: no .END_PLACE_OUTLINE found" ) );
     }
     else
     {
         if( !GetIDFString( iline, token, quoted, idx )
             || !CompareToken( ".END_PLACE_KEEPOUT", token ) )
-        {
-            ERROR_IDF << "bad .PLACE_KEEPOUT section (no .END_PLACE_KEEPOUT)\n";
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "invalid .PLACE_KEEPOUT section: no .END_PLACE_KEEPOUT found" ) );
     }
 
-    return true;
+    return;
 }
 
-bool PLACE_OUTLINE::WriteData( std::ofstream& aBoardFile )
+void PLACE_OUTLINE::writeData( std::ofstream& aBoardFile )
 {
     // this section is optional; do not write if not required
     if( outlines.empty() )
-        return true;
+        return;
 
     writeComments( aBoardFile );
 
@@ -1848,8 +2385,14 @@
             break;
 
         default:
-            ERROR_IDF << "Invalid PLACE_OUTLINE/KEEPOUT side (" << side << "); must be one of TOP/BOTTOM/BOTH\n";
-            return false;
+            do
+            {
+                ostringstream ostr;
+                ostr << "\n* invalid PLACE_OUTLINE/KEEPOUT side (";
+                ostr << side << "); must be one of TOP/BOTTOM/BOTH";
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            } while( 0 );
+
             break;
     }
 
@@ -1861,8 +2404,7 @@
         aBoardFile << setiosflags(ios::fixed) << setprecision(1) << (thickness / IDF_MM_TO_THOU) << "\n";
 
     // write RECORD 3
-    if( !writeOutlines( aBoardFile ) )
-        return false;
+    writeOutlines( aBoardFile );
 
     // write RECORD 4
     if( outlineType == OTLN_PLACE )
@@ -1870,22 +2412,28 @@
     else
         aBoardFile << ".END_PLACE_KEEPOUT\n\n";
 
-    return !aBoardFile.fail();
+    return;
 }
 
-void PLACE_OUTLINE::Clear( void )
+
+bool PLACE_OUTLINE::Clear( void )
 {
-    BOARD_OUTLINE::Clear();
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
     thickness = 0.0;
     side = LYR_INVALID;
-    return;
+
+    return true;
 }
 
 
 /*
  * CLASS: ROUTE_KEEPOUT
  */
-ROUTE_KO_OUTLINE::ROUTE_KO_OUTLINE()
+ROUTE_KO_OUTLINE::ROUTE_KO_OUTLINE( IDF3_BOARD* aParent )
+    : ROUTE_OUTLINE( aParent )
 {
     outlineType = OTLN_ROUTE_KEEPOUT;
     return;
@@ -1895,7 +2443,8 @@
 /*
  * CLASS: PLACE_KEEPOUT
  */
-PLACE_KO_OUTLINE::PLACE_KO_OUTLINE()
+PLACE_KO_OUTLINE::PLACE_KO_OUTLINE( IDF3_BOARD* aParent )
+    : PLACE_OUTLINE( aParent )
 {
     outlineType = OTLN_PLACE_KEEPOUT;
     return;
@@ -1905,8 +2454,10 @@
 /*
  * CLASS: VIA_KEEPOUT
  */
-VIA_KO_OUTLINE::VIA_KO_OUTLINE()
+VIA_KO_OUTLINE::VIA_KO_OUTLINE( IDF3_BOARD* aParent )
+    : OTHER_OUTLINE( aParent )
 {
+    single = true;
     outlineType = OTLN_VIA_KEEPOUT;
 }
 
@@ -1914,8 +2465,9 @@
 /*
  * CLASS: PLACEMENT GROUP (PLACE_REGION)
  */
-GROUP_OUTLINE::GROUP_OUTLINE()
+GROUP_OUTLINE::GROUP_OUTLINE( IDF3_BOARD* aParent )
 {
+    setParent( aParent );
     outlineType = OTLN_GROUP_PLACE;
     thickness = 0.0;
     side = LYR_INVALID;
@@ -1923,8 +2475,12 @@
     return;
 }
 
-void GROUP_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
+
+bool GROUP_OUTLINE::SetSide( IDF3::IDF_LAYER aSide )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     switch( aSide )
     {
         case LYR_TOP:
@@ -1934,32 +2490,46 @@
             break;
 
         default:
-            // XXX throw
-            ERROR_IDF << "invalid side (" << aSide << "); must be one of TOP/BOTTOM/BOTH\n";
-            return;
+            do{
+                ostringstream ostr;
+                ostr << "invalid side (" << aSide << "); must be one of TOP/BOTTOM/BOTH\n";
+                ostr << "* outline type: " << GetOutlineTypeString( outlineType );
+                errormsg = ostr.str();
+
+                return false;
+            } while( 0 );
+
             break;
     }
 
-    return;
+    return true;
 }
 
+
 IDF3::IDF_LAYER GROUP_OUTLINE::GetSide( void )
 {
     return side;
 }
 
-void GROUP_OUTLINE::SetGroupName( std::string aGroupName )
+
+bool GROUP_OUTLINE::SetGroupName( std::string aGroupName )
 {
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
     groupName = aGroupName;
-    return;
+
+    return true;
 }
 
+
 const std::string& GROUP_OUTLINE::GetGroupName( void )
 {
     return groupName;
 }
 
-bool GROUP_OUTLINE::ReadData( std::ifstream& aBoardFile, const std::string& aHeader )
+
+void GROUP_OUTLINE::readData( std::ifstream& aBoardFile, const std::string& aHeader )
 {
     //  Placement Group
     //      .PLACE_REGION [OWNER]
@@ -1970,26 +2540,27 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos = aBoardFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
-    {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invalid invocation: blank header line" ) );
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section name must not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !CompareToken( ".PLACE_REGION", token ) )
-    {
-        ERROR_IDF << "not a PLACE_REGION outline:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: not a .PLACE_REGION" ) );
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
     {
@@ -2007,7 +2578,6 @@
 
     std::string iline;
     bool comment = false;
-    std::streampos pos;
 
     // check RECORD 2
     // [side: Top/Bot/Both ] [component group name]
@@ -2015,35 +2585,63 @@
 
     if( !aBoardFile.good() )
     {
-        ERROR_IDF << "bad .PLACE_REGION section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .PLACE_REGION section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .PLACE_REGION section (no board side)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no board side specified\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !ParseIDFLayer( token, side ) ||
         ( side != LYR_TOP && side != LYR_BOTTOM && side != LYR_BOTH ) )
     {
-        ERROR_IDF << "bad .PLACE_REGION section (invalid side, must be TOP/BOTTOM/BOTH)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid board side, must be one of TOP/BOTTOM/BOTH\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad .PLACE_REGION section (no outline identifier)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no outline identifier\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     groupName = token;
@@ -2056,32 +2654,42 @@
 
     if( ( !aBoardFile.good() && aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad .PLACE_REGION section (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within .PLACE_REGION section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx )
         || !CompareToken( ".END_PLACE_REGION", token ) )
-    {
-        ERROR_IDF << "bad .PLACE_REGION section (no .END_PLACE_REGION)\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* invalid .PLACE_REGION section: no .END_PLACE_REGION found" ) );
 
-    return true;
+    return;
 }
 
-bool GROUP_OUTLINE::WriteData( std::ofstream& aBoardFile )
+
+void GROUP_OUTLINE::writeData( std::ofstream& aBoardFile )
 {
     // this section is optional; do not write if not required
     if( outlines.empty() )
-        return true;
+        return;
 
     writeComments( aBoardFile );
 
@@ -2100,37 +2708,47 @@
             break;
 
         default:
-            ERROR_IDF << "Invalid PLACE_REGION side (must be TOP/BOTTOM/BOTH): " << side << "\n";
-            return false;
+            do{
+                ostringstream ostr;
+                ostr << "\n* invalid PLACE_REGION side (must be TOP/BOTTOM/BOTH): ";
+                ostr << side;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            } while( 0 );
+
             break;
     }
 
     aBoardFile << " \"" << groupName << "\"\n";
 
     // write RECORD 3
-    if( !writeOutlines( aBoardFile ) )
-        return false;
+    writeOutlines( aBoardFile );
 
     // write RECORD 4
     aBoardFile << ".END_PLACE_REGION\n\n";
 
-    return !aBoardFile.fail();
+    return;
 }
 
-void GROUP_OUTLINE::Clear( void )
+bool GROUP_OUTLINE::Clear( void )
 {
-    BOARD_OUTLINE::Clear();
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
     thickness = 0.0;
     side = LYR_INVALID;
     groupName.clear();
-    return;
+
+    return true;
 }
 
 /*
  * CLASS: COMPONENT OUTLINE
  */
-IDF3_COMP_OUTLINE::IDF3_COMP_OUTLINE()
+IDF3_COMP_OUTLINE::IDF3_COMP_OUTLINE( IDF3_BOARD* aParent )
 {
+    setParent( aParent );
     single = true;
     outlineType = OTLN_COMPONENT;
     compType = COMP_INVALID;
@@ -2138,7 +2756,7 @@
     return;
 }
 
-bool IDF3_COMP_OUTLINE::readProperties( std::ifstream& aLibFile )
+void IDF3_COMP_OUTLINE::readProperties( std::ifstream& aLibFile )
 {
     bool quoted = false;
     bool comment = false;
@@ -2155,63 +2773,106 @@
             continue;
 
         idx = 0;
+
         if( comment )
         {
-            ERROR_IDF << "comment within component outline section\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: comment within section\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad component outline section (no PROP)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: bad property section (no PROP)\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( quoted )
         {
-            ERROR_IDF << "bad component outline section (PROP or .END may not be quoted)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: PROP or .END must not be quoted\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( token.size() >= 5 && CompareToken( ".END_", token.substr( 0, 5 ) ) )
         {
             aLibFile.seekg( pos );
-            return true;
+            return;
         }
 
         if( !CompareToken( "PROP", token ) )
         {
-            ERROR_IDF << "invalid electrical outline; expecting PROP or .END_ELECTRICAL\n";
-            std::cerr << "\tLINE: " << iline << "\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: expecting PROP or .END_ELECTRICAL\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad component outline section (no prop name)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no PROP name\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         pname = token;
 
         if( !GetIDFString( iline, token, quoted, idx ) )
         {
-            ERROR_IDF << "bad component outline section (no prop value)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no PROP value\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         pval = token;
 
         if( props.insert( pair< string, string >(pname, pval) ).second == false )
         {
-            ERROR_IDF << "bad component outline: duplicate property name '" << pname << "'\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: duplicate property name \"" << pname << "\"\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
-    return !aLibFile.fail();
+    return;
 }
 
+
 bool IDF3_COMP_OUTLINE::writeProperties( std::ofstream& aLibFile )
 {
     if( props.empty() )
@@ -2229,7 +2890,7 @@
     return !aLibFile.fail();
 }
 
-bool IDF3_COMP_OUTLINE::ReadData( std::ifstream& aLibFile, const std::string& aHeader )
+void IDF3_COMP_OUTLINE::readData( std::ifstream& aLibFile, const std::string& aHeader )
 {
     //  .ELECTRICAL/.MECHANICAL
     //  [GEOM] [PART] [UNIT] [HEIGHT]
@@ -2239,18 +2900,22 @@
     std::string token;
     bool quoted = false;
     int  idx = 0;
+    std::streampos pos = aLibFile.tellg();
 
     if( !GetIDFString( aHeader, token, quoted, idx ) )
-    {
-        ERROR_IDF << "invalid invocation; blank header line\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invalid invocation: blank header line" ) );
 
     if( quoted )
     {
-        ERROR_IDF << "section names may not be quoted:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: section name must not be in quotes\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( CompareToken( ".ELECTRICAL", token ) )
@@ -2263,58 +2928,97 @@
     }
     else
     {
-        ERROR_IDF << "not a component outline:\n";
-        std::cerr << "\tLINE: " << aHeader << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: expecting .ELECTRICAL or .MECHANICAL header\n";
+        ostr << "* line: '" << aHeader << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     // check RECORD 2
     // [GEOM] [PART] [UNIT] [HEIGHT]
     std::string iline;
     bool comment = false;
-    std::streampos pos;
 
     while( aLibFile.good() && !FetchIDFLine( aLibFile, iline, comment, pos ) );
 
     if( !aLibFile.good() )
     {
-        ERROR_IDF << "bad component outline data (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within a component outline section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad component outline (no GEOMETRY NAME)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no GEOMETRY NAME\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     geometry = token;
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad component outline (no PART NAME)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no PART NAME\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     part = token;
 
     if( part.empty() && geometry.empty() )
     {
-        ERROR_IDF << "bad component outline (both GEOMETRY and PART names are empty)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: both GEOMETRY and PART names are empty\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad component outline (no unit type)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no UNIT type\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( CompareToken( "MM", token ) )
@@ -2327,15 +3031,26 @@
     }
     else
     {
-        ERROR_IDF << "bad component outline (invalid unit type)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid UNIT '" << token << "': must be one of MM or THOU\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF << "bad component outline (no height)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: no height specified\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     std::istringstream teststr;
@@ -2344,9 +3059,14 @@
     teststr >> thickness;
     if( teststr.fail() )
     {
-        ERROR_IDF << "bad component outline (invalid height)\n";
-        std::cerr << "\tLINE: " << iline << "\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: invalid height '" << token << "'\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( unit == UNIT_THOU )
@@ -2356,58 +3076,81 @@
     readOutlines( aLibFile );
 
     if( compType == COMP_ELEC )
-    {
-        if( !readProperties( aLibFile ) )
-            return false;
-    }
+        readProperties( aLibFile );
 
     // check RECORD 4
     while( aLibFile.good() && !FetchIDFLine( aLibFile, iline, comment, pos ) );
 
     if( ( !aLibFile.good() && aLibFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF << "bad component outline data (premature end)\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: premature end\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
     if( comment )
     {
-        ERROR_IDF << "comment within component outline section\n";
-        return false;
+        ostringstream ostr;
+
+        ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+        ostr << "* violation: comment within section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( compType == COMP_ELEC )
     {
         if( !CompareToken( ".END_ELECTRICAL", iline ) )
         {
-            ERROR_IDF << "bad component outline (no .END_ELECTRICAL)\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_ELECTRICAL found\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
     else
     {
         if( !CompareToken( ".END_MECHANICAL", iline ) )
         {
-            ERROR_IDF << "corrupt .MECHANICAL outline\n";
-            return false;
+            ostringstream ostr;
+
+            ostr << "\n* invalid outline: " << GetOutlineTypeString( outlineType ) << "\n";
+            ostr << "* violation: no .END_MECHANICAL found\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
     }
 
-    return true;
+    return;
 }
 
-bool IDF3_COMP_OUTLINE::WriteData( std::ofstream& aLibFile )
+
+void IDF3_COMP_OUTLINE::writeData( std::ofstream& aLibFile )
 {
+    if( refNum == 0 )
+        return;    // nothing to do
+
     if( compType != COMP_ELEC && compType != COMP_MECH )
     {
-        ERROR_IDF << "component type not set or invalid\n";
-        return false;
+        ostringstream ostr;
+        ostr << "\n* component type not set or invalid: " << compType;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
-    if( refNum == 0 )
-        return true;    // nothing to do
-
     writeComments( aLibFile );
 
     // note: the outline section is required, even if it is empty
@@ -2425,8 +3168,7 @@
     else
         aLibFile << "THOU " << setiosflags(ios::fixed) << setprecision(1) << (thickness / IDF_MM_TO_THOU) << "\n";
 
-    if( !writeOutlines( aLibFile ) )
-        return false;
+    writeOutlines( aLibFile );
 
     if( compType == COMP_ELEC )
     {
@@ -2438,22 +3180,27 @@
         aLibFile << ".END_MECHANICAL\n\n";
     }
 
-    return !aLibFile.fail();
+    return;
 }
 
-void IDF3_COMP_OUTLINE::Clear( void )
+
+bool IDF3_COMP_OUTLINE::Clear( void )
 {
-    BOARD_OUTLINE::Clear();
+    if( !CheckOwnership( __FILE__, __LINE__, __FUNCTION__, parent, owner, outlineType, errormsg ) )
+        return false;
+
+    clear();
     uid.clear();
     geometry.clear();
     part.clear();
     compType = COMP_INVALID;
     refNum = 0;
     props.clear();
-    return;
+
+    return true;
 }
 
-void IDF3_COMP_OUTLINE::SetComponentClass( IDF3::COMP_TYPE aCompClass )
+bool IDF3_COMP_OUTLINE::SetComponentClass( IDF3::COMP_TYPE aCompClass )
 {
     switch( aCompClass )
     {
@@ -2463,15 +3210,23 @@
             break;
 
         default:
-            // XXX - throw
-            ERROR_IDF << "invalid component class (must be ELECTRICAL or MECHANICAL)\n";
-            return;
+            do{
+                ostringstream ostr;
+                ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+                ostr << "* BUG: invalid component class (must be ELECTRICAL or MECHANICAL): ";
+                ostr << aCompClass << "\n";
+                errormsg = ostr.str();
+
+                return false;
+            } while( 0 );
+
             break;
     }
 
-    return;
+    return true;
 }
 
+
 IDF3::COMP_TYPE IDF3_COMP_OUTLINE::GetComponentClass( void )
 {
     return compType;
@@ -2525,8 +3280,12 @@
 {
     if( refNum == 0 )
     {
-        ERROR_IDF << "BUG: decrementing refNum beyond 0\n";
-        return 0;
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "():\n";
+        ostr << "* BUG:  decrementing refNum beyond 0";
+        errormsg = ostr.str();
+
+        return -1;
     }
 
     --refNum;

=== modified file 'utils/idftools/idf_outlines.h'
--- utils/idftools/idf_outlines.h	2014-05-28 12:24:44 +0000
+++ utils/idftools/idf_outlines.h	2014-05-29 07:50:28 +0000
@@ -91,7 +91,9 @@
  */
 class BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
 protected:
+    std::string                 errormsg;
     std::list< IDF_OUTLINE* >   outlines;
     IDF3::KEY_OWNER             owner;      // indicates the owner of this outline (MCAD, ECAD, UNOWNED)
     IDF3::OUTLINE_TYPE          outlineType;// type of IDF outline
@@ -102,15 +104,47 @@
     double                      thickness;  // Board/Extrude Thickness or Height (IDF spec)
 
     // Read outline data from a BOARD or LIBRARY file's outline section
-    bool readOutlines( std::ifstream& aBoardFile );
+    void readOutlines( std::ifstream& aBoardFile );
     // Write comments to a BOARD or LIBRARY file (must not be within a SECTION as per IDFv3 spec)
     bool writeComments( std::ofstream& aBoardFile );
     // Write the outline owner to a BOARD file
     bool writeOwner( std::ofstream& aBoardFile );
     // Write the data of a single outline object
-    bool writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex );
+    void writeOutline( std::ofstream& aBoardFile, IDF_OUTLINE* aOutline, size_t aIndex );
     // Iterate through the outlines and write out all data
-    bool writeOutlines( std::ofstream& aBoardFile );  // write outline data (no headers)
+    void writeOutlines( std::ofstream& aBoardFile );  // write outline data (no headers)
+    // Clear internal list of outlines
+    void clearOutlines( void );
+    /**
+     * Function SetParent
+     * sets the parent IDF_BOARD object
+     */
+    void setParent( IDF3_BOARD* aParent );
+
+    // Shadow routines used by friends to bypass ownership checks
+    bool addOutline( IDF_OUTLINE* aOutline );
+    virtual bool setThickness( double aThickness );
+    virtual void clear( void );
+
+    /**
+     * Function readData
+     * reads data from a .BOARD_OUTLINE section
+     * In case of an unrecoverable error an exception is thrown. On a successful
+     * return the file pointer will be at the line following .END_BOARD_OUTLINE
+     *
+     * @param aBoardFile is an IDFv3 file opened for reading
+     * @param aHeader is the ".BOARD_OUTLINE" header line as read by FetchIDFLine
+     */
+    virtual void readData( std::ifstream& aBoardFile, const std::string& aHeader );
+
+    /**
+     * Function writeData
+     * writes the comments and .BOARD_OUTLINE section to an IDFv3 file.
+     * Throws exceptions.
+     *
+     * @param aBoardFile is an IDFv3 file opened for writing
+     */
+    virtual void writeData( std::ofstream& aBoardFile );
 
 public:
     BOARD_OUTLINE();
@@ -123,7 +157,7 @@
      *
      * @param aUnit is the native unit (UNIT_MM or UNIT_THOU)
      */
-    virtual void SetUnit( IDF3::IDF_UNIT aUnit );
+    virtual bool SetUnit( IDF3::IDF_UNIT aUnit );
 
     /**
      * Function GetUnit
@@ -148,33 +182,12 @@
     virtual double GetThickness( void );
 
     /**
-     * Function ReadData
-     * reads data from a .BOARD_OUTLINE section
-     *
-     * @param aBoardFile is an IDFv3 file opened for reading
-     * @param aHeader is the ".BOARD_OUTLINE" header line as read by FetchIDFLine
-     *
-     * @return bool: true if the BOARD_OUTLINE section was successfully read, otherwise
-     * false. In case of an unrecoverable error an exception is thrown. On a successful
-     * return the file pointer will be at the line following .END_BOARD_OUTLINE
-     */
-    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
-
-    /**
-     * Function WriteData
-     * writes the comments and .BOARD_OUTLINE section to an IDFv3 file
-     *
-     * @param aBoardFile is an IDFv3 file opened for writing
-     *
-     * @return bool: true if the data had been successfully written, otherwise false.
-     */
-    virtual bool WriteData( std::ofstream& aBoardFile );
-
-    /**
      * Function Clear
-     * frees memory and reinitializes all internal data except for the parent pointer
+     * frees memory and reinitializes all internal data except for the parent pointer.
+     *
+     * @return bool: true if OK, false on ownership violations
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 
     /**
      * Function GetOutlineType
@@ -183,12 +196,6 @@
     IDF3::OUTLINE_TYPE GetOutlineType( void );
 
     /**
-     * Function SetParent
-     * sets the parent IDF_BOARD object
-     */
-    void SetParent( IDF3_BOARD* aParent );
-
-    /**
      * Function GetParent
      * returns the parent IDF_BOARD object
      */
@@ -202,10 +209,7 @@
      * @param aOutline is a valid IDF outline
      *
      * @return bool: true if the outline was added; false if the outline
-     * already existed. If the outline cannot be added due to a violation
-     * of the IDF specification (multiple outlines for anything other than
-     * a BOARD_OUTLINE, or the ownership rules are violated) an exception is
-     * thrown.
+     * already existed or an ownership violation occurs.
      */
     bool AddOutline( IDF_OUTLINE* aOutline );
 
@@ -221,8 +225,7 @@
      * @param aOutline is a pointer to the outline to remove from the list
      *
      * @return bool: true if the outline was found and removed; false if
-     * the outline was not found. If an ownership violation occurs an
-     * exception is thrown.
+     * the outline was not found or an ownership violation occurs.
      */
     bool DelOutline( IDF_OUTLINE* aOutline );
 
@@ -237,8 +240,8 @@
      * @param aIndex is an index to the outline to delete
      *
      * @return bool: true if the outline was found and deleted; false if
-     * the outline was not found. If an ownership violation or indexation
-     * error occurs an exception is thrown.
+     * the outline was not found or an ownership violation or indexation
+     * error occurs.
      */
     bool DelOutline( size_t aIndex );
 
@@ -331,6 +334,11 @@
      * deletes all comments
      */
     void  ClearComments( void );
+
+    const std::string& GetError( void )
+    {
+        return errormsg;
+    }
 };
 
 
@@ -340,19 +348,40 @@
  */
 class OTHER_OUTLINE : public BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
 private:
     std::string uniqueID;   // Outline Identifier (IDF spec)
     IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM ONLY] (IDF spec)
 
+    /**
+     * Function ReadData
+     * reads an OTHER_OUTLINE data from an IDFv3 file.
+     * If an unrecoverable error occurs an exception is thrown.
+     *
+     * @param aBoardFile is an IDFv3 file open for reading
+     * @param aHeader is the .OTHER_OUTLINE header as read via FetchIDFLine
+     */
+    virtual void readData( std::ifstream& aBoardFile, const std::string& aHeader );
+
+    /**
+     * Function WriteData
+     * writes the OTHER_OUTLINE data to an open IDFv3 file
+     *
+     * @param aBoardFile is an IDFv3 file open for writing
+     *
+     * @return bool: true if the data was successfully written, otherwise false.
+     */
+    virtual void writeData( std::ofstream& aBoardFile );
+
 public:
-    OTHER_OUTLINE();
+    OTHER_OUTLINE( IDF3_BOARD* aParent );
 
     /**
      * Function SetOutlineIdentifier
      * sets the Outline Identifier string of this OTHER_OUTLINE object
      * as per IDFv3 spec.
      */
-    virtual void SetOutlineIdentifier( const std::string aUniqueID );
+    virtual bool SetOutlineIdentifier( const std::string aUniqueID );
 
     /**
      * Function GetOutlineIdentifier
@@ -364,8 +393,8 @@
      * Function SetSide
      * sets the side which this outline is applicable to (TOP, BOTTOM).
      *
-     * @return bool: true if the side was set, false if the side is invalid.
-     * An exception is thrown if there is a violation of IDF ownership rules.
+     * @return bool: true if the side was set, false if the side is invalid
+     * or there is a violation of IDF ownership rules.
      */
     virtual bool SetSide( IDF3::IDF_LAYER aSide );
 
@@ -376,32 +405,10 @@
     virtual IDF3::IDF_LAYER GetSide( void );
 
     /**
-     * Function ReadData
-     * reads an OTHER_OUTLINE data from an IDFv3 file.
-     *
-     * @param aBoardFile is an IDFv3 file open for reading
-     * @param aHeader is the .OTHER_OUTLINE header as read via FetchIDFLine
-     *
-     * @return bool: true if data was read, otherwise false. If an unrecoverable
-     * error occurs an exception is thrown.
-     */
-    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
-
-    /**
-     * Function WriteData
-     * writes the OTHER_OUTLINE data to an open IDFv3 file
-     *
-     * @param aBoardFile is an IDFv3 file open for writing
-     *
-     * @return bool: true if the data was successfully written, otherwise false.
-     */
-    virtual bool WriteData( std::ofstream& aBoardFile );
-
-    /**
      * Function Clear
      * deletes internal data except for the parent object
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 };
 
 
@@ -411,20 +418,37 @@
  */
 class ROUTE_OUTLINE : public BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
+private:
+    /**
+     * Function ReadData
+     * reads ROUTE_OUTLINE data from an IDFv3 file
+     * If an unrecoverable error occurs an exception is thrown.
+     *
+     * @param aBoardFile is an open IDFv3 board file
+     * @param aHeader is the .ROUTE_OUTLINE header as returned by FetchIDFLine
+     */
+    virtual void readData( std::ifstream& aBoardFile, const std::string& aHeader );
+
+    /**
+     * Function WriteData
+     * writes the ROUTE_OUTLINE data to an open IDFv3 file
+     */
+    virtual void writeData( std::ofstream& aBoardFile );
+
 protected:
     IDF3::IDF_LAYER layers; // Routing layers (IDF spec)
 
 public:
-    ROUTE_OUTLINE();
+    ROUTE_OUTLINE( IDF3_BOARD* aParent );
 
     /**
      * Function SetLayers
      * sets the layer or group of layers this outline is applicable to.
-     * This function is subject to IDF ownership rules. An exception is
-     * thrown if an invalid layer is provided or an IDF ownership violation
-     * occurs.
+     * This function is subject to IDF ownership rules; true is returned
+     * on success, otherwise false is returned and the error message is set.
      */
-    virtual void SetLayers( IDF3::IDF_LAYER aLayer );
+    virtual bool SetLayers( IDF3::IDF_LAYER aLayer );
 
     /**
      * Function GetLayers
@@ -433,28 +457,10 @@
     virtual IDF3::IDF_LAYER GetLayers( void );
 
     /**
-     * Function ReadData
-     * reads ROUTE_OUTLINE data from an IDFv3 file
-     *
-     * @param aBoardFile is an open IDFv3 board file
-     * @param aHeader is the .ROUTE_OUTLINE header as returned by FetchIDFLine
-     *
-     * @return bool: true if data was read, otherwise false. If unrecoverable
-     * errors occur an exception is thrown.
-     */
-    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
-
-    /**
-     * Function WriteData
-     * writes the ROUTE_OUTLINE data to an open IDFv3 file
-     */
-    virtual bool WriteData( std::ofstream& aBoardFile );
-
-    /**
      * Function Clear
      * deletes internal data except for the parent object
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 };
 
 /**
@@ -463,20 +469,42 @@
  */
 class PLACE_OUTLINE : public BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
+private:
+    /**
+     * Function ReadData
+     * reads PLACE_OUTLINE data from an open IDFv3 file.
+     * If an unrecoverable error occurs an exception is thrown.
+     *
+     * @param aBoardFile is an IDFv3 file opened for reading
+     * @param aHeader is the .PLACE_OUTLINE header as returned by FetchIDFLine
+     */
+    virtual void readData( std::ifstream& aBoardFile, const std::string& aHeader );
+
+    /**
+     * Function WriteData
+     * writes the PLACE_OUTLINE data to an open IDFv3 file
+     *
+     * @param aBoardFile is an IDFv3 file opened for writing
+     *
+     * @return bool: true if the data was successfully written, otherwise false
+     */
+    virtual void writeData( std::ofstream& aBoardFile );
+
 protected:
     IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM/BOTH ONLY] (IDF spec)
     double height;          // Max Height (IDF spec)
 
 public:
-    PLACE_OUTLINE();
+    PLACE_OUTLINE( IDF3_BOARD* aParent );
 
     /**
      * Function SetSide
-     * sets the side (TOP, BOTTOM, BOTH) which this outline applies to,
-     * subject to IDF ownership rules. An exception is thrown if there is
-     * an ownership violation or an invalid layer is passed.
+     * sets the side (TOP, BOTTOM, BOTH) which this outline applies to.
+     * This function is subject to IDF ownership rules; true is returned
+     * on success, otherwise false is returned and the error message is set.
      */
-    virtual void SetSide( IDF3::IDF_LAYER aSide );
+    virtual bool SetSide( IDF3::IDF_LAYER aSide );
 
     /**
      * Function GetSide
@@ -486,11 +514,11 @@
 
     /**
      * Function SetMaxHeight
-     * sets the maximum height of a component within this outline,
-     * subject to IDF ownership rules. An exception is thrown if
-     * there is an ownership violation or aHeight is negative.
+     * sets the maximum height of a component within this outline.
+     * This function is subject to IDF ownership rules; true is returned
+     * on success, otherwise false is returned and the error message is set.
      */
-    virtual void SetMaxHeight( double aHeight );
+    virtual bool SetMaxHeight( double aHeight );
 
     /**
      * Function GetMaxHeight
@@ -499,32 +527,10 @@
     virtual double GetMaxHeight( void );
 
     /**
-     * Function ReadData
-     * reads PLACE_OUTLINE data from an open IDFv3 file.
-     *
-     * @param aBoardFile is an IDFv3 file opened for reading
-     * @param aHeader is the .PLACE_OUTLINE header as returned by FetchIDFLine
-     *
-     * @return bool: true if data was read, otherwise false. If there are
-     * unrecoverable errors an exception is thrown.
-     */
-    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
-
-    /**
-     * Function WriteData
-     * writes the PLACE_OUTLINE data to an open IDFv3 file
-     *
-     * @param aBoardFile is an IDFv3 file opened for writing
-     *
-     * @return bool: true if the data was successfully written, otherwise false
-     */
-    virtual bool WriteData( std::ofstream& aBoardFile );
-
-    /**
      * Function Clear
      * deletes all internal data
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 };
 
 
@@ -535,7 +541,7 @@
 class ROUTE_KO_OUTLINE : public ROUTE_OUTLINE
 {
 public:
-    ROUTE_KO_OUTLINE();
+    ROUTE_KO_OUTLINE( IDF3_BOARD* aParent );
 };
 
 /**
@@ -547,7 +553,7 @@
 class VIA_KO_OUTLINE : public OTHER_OUTLINE
 {
 public:
-    VIA_KO_OUTLINE();
+    VIA_KO_OUTLINE( IDF3_BOARD* aParent );
 };
 
 
@@ -559,7 +565,7 @@
 class PLACE_KO_OUTLINE : public PLACE_OUTLINE
 {
 public:
-    PLACE_KO_OUTLINE();
+    PLACE_KO_OUTLINE( IDF3_BOARD* aParent );
 };
 
 /**
@@ -569,20 +575,41 @@
  */
 class GROUP_OUTLINE : public BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
 private:
     IDF3::IDF_LAYER side;   // Board Side [TOP/BOTTOM/BOTH ONLY] (IDF spec)
     std::string groupName;  // non-unique string
 
+    /**
+     * Function ReadData
+     * reads GROUP_OUTLINE data from an open IDFv3 file
+     * If an unrecoverable error occurs an exception is thrown.
+     *
+     * @param aBoardFile is an open IDFv3 file
+     * @param aHeader is the .PLACE_REGION header as returned by FetchIDFLine
+     */
+    virtual void readData( std::ifstream& aBoardFile, const std::string& aHeader );
+
+    /**
+     * Function WriteData
+     * writes the data to a .PLACE_REGION section of an IDFv3 file
+     *
+     * @param aBoardFile is an IDFv3 file open for writing
+     *
+     * @return bool: true if the data is successfully written, otherwise false
+     */
+    virtual void writeData( std::ofstream& aBoardFile );
+
 public:
-    GROUP_OUTLINE();
+    GROUP_OUTLINE( IDF3_BOARD* aParent );
 
     /**
      * Function SetSide
-     * sets the side which this outline applies to (TOP, BOTTOM, BOTH),
-     * subject to IDF ownership rules. If an ownership violation occurs
-     * or an invalid side is specified, an exception is thrown.
+     * sets the side which this outline applies to (TOP, BOTTOM, BOTH).
+     * This function is subject to IDF ownership rules; true is returned
+     * on success, otherwise false is returned and the error message is set.
      */
-    virtual void SetSide( IDF3::IDF_LAYER aSide );
+    virtual bool SetSide( IDF3::IDF_LAYER aSide );
 
     /**
      * Function GetSide
@@ -593,10 +620,10 @@
     /**
      * Function SetGroupName
      * sets the name of the group, subject to IDF ownership rules.
-     * An empty name or an ownership violation results in a thrown
-     * exception.
+     * This function is subject to IDF ownership rules; true is returned
+     * on success, otherwise false is returned and the error message is set.
      */
-    virtual void SetGroupName( std::string aGroupName );
+    virtual bool SetGroupName( std::string aGroupName );
 
     /**
      * Function GetGroupName
@@ -605,32 +632,10 @@
     virtual const std::string& GetGroupName( void );
 
     /**
-     * Function ReadData
-     * reads GROUP_OUTLINE data from an open IDFv3 file
-     *
-     * @param aBoardFile is an open IDFv3 file
-     * @param aHeader is the .PLACE_REGION header as returned by FetchIDFLine
-     *
-     * @return bool: true if data was read, otherwise false. If an unrecoverable
-     * error occurs an exception is thrown.
-     */
-    virtual bool ReadData( std::ifstream& aBoardFile, const std::string& aHeader );
-
-    /**
-     * Function WriteData
-     * writes the data to a .PLACE_REGION section of an IDFv3 file
-     *
-     * @param aBoardFile is an IDFv3 file open for writing
-     *
-     * @return bool: true if the data is successfully written, otherwise false
-     */
-    virtual bool WriteData( std::ofstream& aBoardFile );
-
-    /**
      * Function Clear
      * deletes internal data, subject to IDF ownership rules
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 };
 
 
@@ -640,6 +645,7 @@
  */
 class IDF3_COMP_OUTLINE : public BOARD_OUTLINE
 {
+friend class IDF3_BOARD;
 private:
     std::string     uid;        // unique ID
     std::string     geometry;   // geometry name (IDF)
@@ -649,23 +655,18 @@
 
     std::map< std::string, std::string >    props;      // properties list
 
-    bool readProperties( std::ifstream& aLibFile );
+    void readProperties( std::ifstream& aLibFile );
     bool writeProperties( std::ofstream& aLibFile );
 
-public:
-    IDF3_COMP_OUTLINE();
-
     /**
      * Function ReadData
      * reads a component outline from an open IDFv3 file
+     * If an unrecoverable error occurs, an exception is thrown.
      *
      * @param aLibFile is an open IDFv3 Library file
      * @param aHeader is the .ELECTRICAL or .MECHANICAL header as returned by FetchIDFLine
-     *
-     * @return bool: true if data was read, otherwise false. If unrecoverable errors
-     * occur, an exception is thrown.
      */
-    virtual bool ReadData( std::ifstream& aLibFile, const std::string& aHeader );
+    virtual void readData( std::ifstream& aLibFile, const std::string& aHeader );
 
     /**
      * Function WriteData
@@ -675,20 +676,23 @@
      *
      * @return bool: true if the data was successfully written, otherwise false
      */
-    virtual bool WriteData( std::ofstream& aLibFile );
+    virtual void writeData( std::ofstream& aLibFile );
+
+public:
+    IDF3_COMP_OUTLINE( IDF3_BOARD* aParent );
 
     /**
      * Function Clear
      * deletes internal outline data
      */
-    virtual void Clear( void );
+    virtual bool Clear( void );
 
     /**
      * Function SetComponentClass
-     * sets the type of component outline (.ELECTRICAL or .MECHANICAL)
-     * If the specified class is invalid an exception is thrown.
+     * sets the type of component outline (.ELECTRICAL or .MECHANICAL).
+     * Returns true on success, otherwise false and the error message is set
      */
-    void SetComponentClass( IDF3::COMP_TYPE aCompClass );
+    bool SetComponentClass( IDF3::COMP_TYPE aCompClass );
 
     /**
      * Function GetComponentClass
@@ -727,10 +731,14 @@
      */
     const std::string& GetUID( void );
 
+    // TODO: Move IncrementRef and DecrementRef to protect them from
+    // direct manipulation of the user (make them accessible only to friends)
     /**
      * Function IncrementRef
      * increments the internal reference counter to keep track of the number of
      * components referring to this outline.
+     *
+     * @return int: the number of current references to this component outline
      */
     int IncrementRef( void );
 
@@ -738,6 +746,10 @@
      * Function DecrementRef
      * decrements the internal reference counter to keep track of the number of
      * components referring to this outline.
+     *
+     * @return int: the number of remaining references or -1 if there were no
+     * references when the function was invoked, in which case the error message
+     * is also set.
      */
     int DecrementRef( void );
 
@@ -751,4 +763,4 @@
     // XXX: property manipulators
 };
 
-#endif // IDF_OUTLINES_H
+#endif // IDF_OUTLINES_H
\ No newline at end of file

=== modified file 'utils/idftools/idf_parser.cpp'
--- utils/idftools/idf_parser.cpp	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_parser.cpp	2014-05-29 07:50:37 +0000
@@ -21,6 +21,16 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 
+// TODO: check ownership rules
+
+/*
+ * TODO:
+ *
+ *  URGENT: In order to not lose drilled holes, we need to support a PANEL
+ *  RefDes. This is a special RefDes as no outlines are allowed, only DRILL holes.
+ *
+ */
+
 #include <iostream>
 #include <iomanip>
 #include <fstream>
@@ -130,16 +140,13 @@
     return;
 }
 
+
 bool IDF3_COMP_OUTLINE_DATA::ReadPlaceData( std::ifstream &aBoardFile,
                                             IDF3::FILE_STATE& aBoardState, IDF3_BOARD *aBoard )
 {
     if( !aBoard )
-    {
-        ERROR_IDF;
-        cerr << "BUG: invoked with no reference to the parent IDF_BOARD\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invoked with no reference to the parent IDF_BOARD" ) );
 
     // clear out data possibly left over from previous use of the object
     outline = NULL;
@@ -161,19 +168,25 @@
 
     if( ( !aBoardFile.good() && !aBoardFile.eof() ) || iline.empty() )
     {
-        ERROR_IDF;
-        cerr << "problems reading PLACEMENT SECTION\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: could not read PLACEMENT section\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( isComment )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within a section (PLACEMENT)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: comment within PLACEMENT section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
@@ -190,11 +203,14 @@
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no PART NAME in PLACEMENT RECORD2\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no PART NAME in PLACEMENT RECORD2\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     std::string npart = token;
@@ -202,12 +218,14 @@
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no REFDES in PLACEMENT RECORD2\n";
-        cerr << "* Line: '" << iline << "'\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no REFDES in PLACEMENT RECORD2\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( CompareToken( "NOREFDES", token ) )
@@ -223,27 +241,36 @@
     }
     else if( CompareToken( "BOARD", token ) )
     {
-        ERROR_IDF;
-        cerr << "unsupported feature\n";
-        cerr << "* RefDes is 'BOARD', indicating this is a PANEL FILE (not supported)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "UNSUPPORTED FEATURE\n";
+        ostr << "* RefDes is 'BOARD', indicating this is a PANEL FILE (not supported)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
     else if( CompareToken( "PANEL", token ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: RefDes in PLACEMENT RECORD2 is 'PANEL'\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: RefDes in PLACEMENT RECORD2 is 'PANEL'\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
     else if( token.empty() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: empty RefDes string in PLACEMENT RECORD2\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: empty RefDes string in PLACEMENT RECORD2\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
     else
     {
@@ -256,19 +283,25 @@
 
     if( !aBoardFile.good() )
     {
-        ERROR_IDF;
-        cerr << "problems reading PLACEMENT SECTION, RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* problems reading PLACEMENT SECTION, RECORD 3\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( isComment )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within a section (PLACEMENT)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: comment within PLACEMENT section\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     idx = 0;
@@ -276,11 +309,14 @@
 
     if( quoted )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: X value must not be in quotes (PLACEMENT RECORD 3)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: X value must not be in quotes (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     istringstream istr;
@@ -289,20 +325,26 @@
     istr >> xoff;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: X value is not numeric (PLACEMENT RECORD 3)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: X value is not numeric (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no Y value in PLACEMENT RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no Y value (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     istr.clear();
@@ -311,20 +353,26 @@
     istr >> yoff;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Y value is not numeric (PLACEMENT RECORD 3)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: Y value is not numeric (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no Z value in PLACEMENT RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no Z value (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     istr.clear();
@@ -333,20 +381,26 @@
     istr >> zoff;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: Z value is not numeric (PLACEMENT RECORD 3)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: Z value is not numeric (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no rotation value in PLACEMENT RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no rotation value (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     istr.clear();
@@ -355,20 +409,26 @@
     istr >> aoff;
     if( istr.fail() )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: rotation value is not numeric (PLACEMENT RECORD 3)\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: rotation value is not numeric (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no SIDE value in PLACEMENT RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no SIDE value (PLACEMENT RECORD 3)\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( CompareToken( "TOP", token ) )
@@ -381,21 +441,27 @@
     }
     else
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: SIDE value in PLACEMENT RECORD 3 is invalid ('";
-        cerr << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: invalid SIDE value in PLACEMENT RECORD 3 ('";
+        ostr << token << "'); must be one of TOP/BOTTOM\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: no PLACEMENT value in PLACEMENT RECORD 3\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: no PLACEMENT value in PLACEMENT RECORD 3\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( CompareToken( "PLACED", token ) )
@@ -416,12 +482,15 @@
     }
     else
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: PLACEMENT value in PLACEMENT RECORD 3 is invalid ('";
-        cerr << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* violation: invalid PLACEMENT value ('";
+        ostr << token << "') in PLACEMENT RECORD 3\n";
+        ostr << "* line: '" << iline << "'\n";
+        ostr << "* file position: " << pos;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     outline = aBoard->GetComponentOutline( uid );
@@ -434,11 +503,8 @@
         outline = aBoard->GetInvalidOutline( ngeom, npart );
 
         if( outline == NULL )
-        {
-            ERROR_IDF << "cannot create outline object\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* missing outline: cannot create default" ) );
     }
 
     if( aBoard->GetUnit() == IDF3::UNIT_THOU )
@@ -456,10 +522,10 @@
 
         if( cp == NULL )
         {
-            ERROR_IDF << "cannot create component object\n";
-            aBoardState = IDF3::FILE_INVALID;
             outline = NULL;
-            return false;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "cannot create component object" ) );
         }
 
         cp->SetRefDes( refdes );
@@ -483,12 +549,17 @@
         {
             if( side != tL )
             {
-                ERROR_IDF << "inconsistent PLACEMENT data\n";
-                cerr << "* SIDE value has changed from " << GetLayerString( tL );
-                cerr << " to " << GetLayerString( side ) << "\n";
-                aBoardState = IDF3::FILE_INVALID;
                 outline = NULL;
-                return false;
+                ostringstream ostr;
+
+                ostr << "invalid IDFv3 file\n";
+                ostr << "* violation: inconsistent PLACEMENT data; ";
+                ostr << "* SIDE value has changed from " << GetLayerString( tL );
+                ostr << " to " << GetLayerString( side ) << "\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* file position: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
 
             xoff -= tX;
@@ -507,13 +578,18 @@
 
         if( placement != parent->GetPlacement() )
         {
-            ERROR_IDF << "inconsistent PLACEMENT data\n";
-            cerr << "* placement value has changed from " << GetPlacementString( parent->GetPlacement() );
-            cerr << " to " << GetPlacementString( placement ) << "\n";
-            cerr << "* line: '" << iline << "'\n";
-            aBoardState = IDF3::FILE_INVALID;
             outline = NULL;
-            return false;
+            ostringstream ostr;
+
+            ostr << "invalid IDFv3 file\n";
+            ostr << "* violation: inconsistent PLACEMENT data; ";
+            ostr << "* PLACEMENT value has changed from ";
+            ostr << GetPlacementString( parent->GetPlacement() );
+            ostr << " to " << GetPlacementString( placement ) << "\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* file position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
     }
@@ -526,14 +602,15 @@
 
     if( !parent->AddOutlineData( cdp ) )
     {
-        ERROR_IDF << "could not add outline data object\n";
-        aBoardState = IDF3::FILE_INVALID;
         delete cdp;
-        return false;
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "could not add outline data object" ) );
     }
 
     return true;
-}
+}   // IDF3_COMP_OUTLINE_DATA::ReadPlaceData
+
 
 bool IDF3_COMP_OUTLINE_DATA::WritePlaceData( std::ofstream& aBoardFile,
                                              double aXpos, double aYpos, double aAngle,
@@ -638,19 +715,6 @@
  * This represents a component and its associated
  * IDF outlines and ancillary data (position, etc)
  */
-IDF3_COMPONENT::IDF3_COMPONENT()
-{
-    xpos   = 0.0;
-    ypos   = 0.0;
-    angle  = 0.0;
-    parent = NULL;
-
-    hasPosition = false;
-    placement   = PS_INVALID;
-    layer       = LYR_INVALID;
-    return;
-}
-
 IDF3_COMPONENT::IDF3_COMPONENT( IDF3_BOARD* aParent )
 {
     xpos   = 0.0;
@@ -724,16 +788,14 @@
     }
 
     if( CompareToken( "PANEL", aRefDes ) )
-    {
-        ERROR_IDF;
-        cerr << "\n*BUG: PANEL is a reserved designator and may not be used by components\n";
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n*BUG: PANEL is a reserved designator and may not be used by components" ) );
 
     refdes = aRefDes;
     return true;
 }
 
+
 const std::string& IDF3_COMPONENT::GetRefDes( void )
 {
     return refdes;
@@ -755,6 +817,7 @@
     return dp;
 }
 
+
 IDF_DRILL_DATA* IDF3_COMPONENT::AddDrill( IDF_DRILL_DATA* aDrilledHole )
 {
     if( !aDrilledHole )
@@ -935,7 +998,12 @@
             break;
 
         default:
-            ERROR_IDF << "invalid side (must be TOP or BOTTOM only): " << aLayer << "\n";
+            do{
+                ostringstream ostr;
+                ostr << "\n* invalid side (must be TOP or BOTTOM only): " << GetLayerString( aLayer );
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            } while( 0 );
+            ERROR_IDF << " " << aLayer << "\n";
             return false;
             break;
     }
@@ -960,15 +1028,76 @@
 
 void IDF3_COMPONENT::SetPlacement( IDF3::IDF_PLACEMENT aPlacementValue )
 {
-    // XXX - throw on ownership violation or invalid placement value
     if( aPlacementValue < PS_UNPLACED || aPlacementValue >= PS_INVALID )
-        return;
-
-    placement = aPlacementValue;
+    {
+        ostringstream ostr;
+        ostr << "\n* invalid PLACEMENT value (" << aPlacementValue << ")";
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+    }
+
+    if( !parent )
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: parent not set; cannot ensure IDF compliance" ) );
+
+    IDF3::CAD_TYPE pcad = parent->GetCadType();
+
+    switch( placement )
+    {
+        case PS_UNPLACED:
+        case PS_PLACED:
+        case PS_INVALID:
+            placement = aPlacementValue;
+            break;
+
+        case PS_MCAD:
+
+            if( pcad == CAD_MECH )
+            {
+                placement = aPlacementValue;
+            }
+            else
+            {
+                ostringstream ostr;
+                ostr << "\n* ownership violation; internal CAD type (MCAD) conflicts with PLACEMENT (";
+                ostr << GetPlacementString( aPlacementValue ) << ")";
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            }
+
+            break;
+
+        case PS_ECAD:
+
+            if( pcad == CAD_ELEC )
+            {
+                placement = aPlacementValue;
+            }
+            else
+            {
+                ostringstream ostr;
+                ostr << "\n* ownership violation; internal CAD type (ECAD) conflicts with PLACEMENT (";
+                ostr << GetPlacementString( aPlacementValue ) << ")";
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            }
+
+            break;
+
+        default:
+            do{
+                ostringstream ostr;
+                ostr << "\n* BUG: unhandled internal placement value (" << placement << ")";
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            } while( 0 );
+
+            break;
+    }
+
     return;
 }
 
-bool IDF3_COMPONENT::WriteDrillData( std::ofstream& aBoardFile )
+bool IDF3_COMPONENT::writeDrillData( std::ofstream& aBoardFile )
 {
     if( drills.empty() )
         return true;
@@ -978,7 +1107,7 @@
 
     while( itS != itE )
     {
-        if( !(*itS)->Write( aBoardFile, GetUnit() ) )
+        if( !(*itS)->write( aBoardFile, GetUnit() ) )
             return false;
 
         ++itS;
@@ -987,7 +1116,8 @@
     return true;
 }
 
-bool IDF3_COMPONENT::WritePlaceData( std::ofstream& aBoardFile )
+
+bool IDF3_COMPONENT::writePlaceData( std::ofstream& aBoardFile )
 {
     if( components.empty() )
         return true;
@@ -1021,8 +1151,8 @@
     // unlike other outlines which are created as necessary,
     // the board outline always exists and its parent must
     // be set here
-    olnBoard.SetParent( this );
-    olnBoard.SetThickness( 1.6 );
+    olnBoard.setParent( this );
+    olnBoard.setThickness( 1.6 );
 
     return;
 }
@@ -1190,11 +1320,21 @@
 {
     if( aBoardThickness <= 0.0 )
     {
-        ERROR_IDF << "board thickness must be > 0\n";
-        return false;
-    }
-
-    return olnBoard.SetThickness( aBoardThickness );
+        ostringstream ostr;
+        ostr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): ";
+        ostr << "board thickness must be > 0";
+        errormsg = ostr.str();
+
+        return false;
+    }
+
+    if(! olnBoard.SetThickness( aBoardThickness ) )
+    {
+        errormsg = olnBoard.GetError();
+        return false;
+    }
+
+    return true;
 }
 
 
@@ -1205,11 +1345,11 @@
 
 
 // read the DRILLED HOLES section
-bool IDF3_BOARD::readBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+void IDF3_BOARD::readBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
 {
     IDF_DRILL_DATA drill;
 
-    while( drill.Read( aBoardFile, unit, aBoardState ) )
+    while( drill.read( aBoardFile, unit, aBoardState ) )
     {
         if( CompareToken( "PANEL", drill.GetDrillRefDes() ) )
         {
@@ -1220,62 +1360,49 @@
 
         IDF_DRILL_DATA *dp = new IDF_DRILL_DATA;
         *dp = drill;
+
         if( AddDrill( dp ) == NULL )
         {
             delete dp;
-            ERROR_IDF;
-            cerr << "\n* BUG: could not add drill data; cannot continue reading the file\n";
-            aBoardState = FILE_INVALID;
-            return false;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "\n* BUG: could not add drill data; cannot continue reading the file" ) );
         }
     }
 
-    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
-        return true;
-
-    return false;
-
+    return;
 }
 
 
 // read the NOTES section
-bool IDF3_BOARD::readBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+void IDF3_BOARD::readBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
 {
     IDF_NOTE note;
 
-    while( note.ReadNote( aBoardFile, aBoardState, unit ) )
+    while( note.readNote( aBoardFile, aBoardState, unit ) )
     {
         IDF_NOTE *np = new IDF_NOTE;
         *np = note;
         notes.push_back( np );
     }
 
-    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
-        return true;
-
-    return false;
+    return;
 }
 
 
 // read the component placement section
-bool IDF3_BOARD::readBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+void IDF3_BOARD::readBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
 {
     IDF3_COMP_OUTLINE_DATA oldata;
 
     while( oldata.ReadPlaceData( aBoardFile, aBoardState, this ) );
 
-    if( errno == 0 && aBoardState != IDF3::FILE_INVALID )
-        return true;
-
-    ERROR_IDF << "problems reading board PLACEMENT section\n";
-
-    return false;
-
+    return;
 }
 
 
 // read the board HEADER
-bool IDF3_BOARD::readBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+void IDF3_BOARD::readBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
 {
     std::string iline;      // the input line
     bool isComment;         // true if a line just read in is a comment line
@@ -1288,30 +1415,19 @@
     while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
 
     if( !aBoardFile.good() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading board header\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading board header" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: first line must be .HEADER\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: first line must be .HEADER\n" ) );
 
     if( !CompareToken( ".HEADER", iline ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: first line must be .HEADER and have no quotes or trailing text\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* first line must be .HEADER and have no quotes or trailing text" ) );
 
     // RECORD 2:
     //      File Type [str]: BOARD_FILE (PANEL_FILE not supported)
@@ -1322,109 +1438,79 @@
     while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
 
     if( !aBoardFile.good() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading board header, RECORD 2\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading board header, RECORD 2" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within .HEADER section\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: comment within .HEADER section" ) );
 
     idx = 0;
     GetIDFString( iline, token, quoted, idx );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: File Type in HEADER section must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* File Type in HEADER section must not be in quotes" ) );
 
     if( !CompareToken( "BOARD_FILE", token ) )
     {
         ERROR_IDF;
 
         if( CompareToken( "PANEL_FILE", token ) )
-        {
-            cerr << "not a board file\n";
-            cerr << "* PANEL_FILE is not supported (expecting BOARD_FILE)\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "not a board file\n"
+                              "* PANEL_FILE is not supported (expecting BOARD_FILE)" ) );
         else
-        {
-            cerr << "invalid IDFv3 file\n";
-            cerr << "* Expecting string: BOARD_FILE\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "invalid IDFv3 file\n"
+                              "* Expecting string: BOARD_FILE" ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2: no FIELD 2\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: HEADER section, RECORD 2: no FIELD 2" ) );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: IDF Version must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: IDF Version must not be in quotes" ) );
 
     if( token.compare( "3.0" ) && token.compare( "3." ) && token.compare( "3" ) )
     {
-        ERROR_IDF;
-        cerr << "unsupported IDF version\n";
-        cerr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "unsupported IDF version\n";
+        ostr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 3: no Source System string\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 3: no Source System string" ) );
+
     brdSource = token;
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 4: no Date string\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 4: no Date string" ) );
+
     brdDate = token;
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 5: no Board File Version number\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 5: no Board File Version number" ) );
+
     std::istringstream istr;
     istr.str( token );
 
@@ -1438,13 +1524,10 @@
     }
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: HEADER section, RECORD 2, FIELD 5: Board File Version must not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 5: Board File Version must not be in quotes" ) );
 
     // RECORD 3:
     //      Board Name [str]: stored
@@ -1452,21 +1535,13 @@
     while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
 
     if( !aBoardFile.good() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading board header, RECORD 2\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* problems reading board header, RECORD 2" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within .HEADER section\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: comment within .HEADER section" ) );
 
     idx = 0;
     GetIDFString( iline, token, quoted, idx );
@@ -1474,22 +1549,16 @@
     boardName = token;
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 3, FIELD 1: no Board Name\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 3, FIELD 1: no Board Name" ) );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: HEADER section, RECORD 3, FIELD 2: UNIT may not be in quotes\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 3, FIELD 2: UNIT may not be in quotes" ) );
 
     if( CompareToken( "MM", token ) )
     {
@@ -1501,11 +1570,12 @@
     }
     else
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* HEADER section, RECORD 3, FIELD 2: expecting MM or THOU (got '" << token << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* HEADER section, RECORD 3, FIELD 2: expecting MM or THOU (got '" << token << "')\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     olnBoard.SetUnit( unit );
@@ -1515,38 +1585,32 @@
     while( !FetchIDFLine( aBoardFile, iline, isComment, pos ) && aBoardFile.good() );
 
     if( ( !aBoardFile.good() && !aBoardFile.eof() ) || iline.empty() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading board header, RECORD 4\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading board header, RECORD 4" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: comment within .HEADER section\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 file\n"
+                          "* Violation of specification: comment within .HEADER section\n" ) );
 
     if( !CompareToken( ".END_HEADER", iline ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 file\n";
-        cerr << "* Violation of specification: expected .END_HEADER (got '" << iline << "')\n";
-        aBoardState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+
+        ostr << "invalid IDFv3 file\n";
+        ostr << "* Violation of specification: expected .END_HEADER\n";
+        ostr << "* line: '" << iline << "'";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     aBoardState = IDF3::FILE_HEADER;
-    return true;
+    return;
 }
 
 
 // read individual board sections; pay attention to IDFv3 section specifications
-bool IDF3_BOARD::readBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
+void IDF3_BOARD::readBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState )
 {
     std::list< std::string > comments;  // comments associated with a section
 
@@ -1562,7 +1626,7 @@
     //      .PLACE_KEEPOUT
     //      .PLACE_REGION
     //      .DRILLED_HOLES
-    //      .NOTES (NOT YET SUPPORTED: NOTES SECTION WILL BE SKIPPED FOR NOW)
+    //      .NOTES
     //      .PLACEMENT
     std::string iline;      // the input line
     bool isComment;         // true if a line just read in is a comment line
@@ -1578,12 +1642,15 @@
         if( !aBoardFile.good() )
         {
             if( aBoardFile.eof() && aBoardState >= IDF3::FILE_HEADER && aBoardState < IDF3::FILE_INVALID )
-                return true;
-
-            ERROR_IDF;
-            cerr << "problems reading board section\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
+            {
+                if( !comments.empty() )
+                    ERROR_IDF << "[warning]: trailing comments in IDF file (comments will be lost)\n";
+
+                return;
+            }
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "problems reading board section" ) );
         }
 
         if( isComment )
@@ -1593,41 +1660,31 @@
         }
 
         // This must be a header
-        if( !GetIDFString( iline, token, quoted, idx ) )
-        {
-            ERROR_IDF;
-            cerr << "problems reading board section\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
+        GetIDFString( iline, token, quoted, idx );
 
         if( quoted )
         {
-            ERROR_IDF;
-            cerr << "invalid IDFv3 file\n";
-            cerr << "* Violation of specification: quoted string where SECTION HEADER expected\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
+            ostringstream ostr;
+
+            ostr << "invalid IDFv3 file\n";
+            ostr << "* Violation of specification: quoted string where SECTION HEADER expected\n";
+            ostr << "* line: '" << iline << "'";
+            ostr << "* position: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( CompareToken( ".BOARD_OUTLINE", token ) )
         {
             if( aBoardState != IDF3::FILE_HEADER )
             {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: no HEADER section\n";
                 aBoardState = IDF3::FILE_INVALID;
-                return false;
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: no HEADER section" ) );
             }
 
-            if( !olnBoard.ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+            olnBoard.readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1642,47 +1699,28 @@
             }
 
             aBoardState = IDF3::FILE_OUTLINE;
-            return true;
+            return;
         }
 
         if( CompareToken( ".PANEL_OUTLINE", token ) )
-        {
-            ERROR_IDF;
-            cerr << "PANEL_OUTLINE not supported\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "PANEL_OUTLINE not supported" ) );
 
         if( CompareToken( ".OTHER_OUTLINE", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .OTHER_OUTLINE\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .OTHER_OUTLINE" ) );
 
-            OTHER_OUTLINE* op = new OTHER_OUTLINE;
+            OTHER_OUTLINE* op = new OTHER_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create OTHER_OUTLINE object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create OTHER_OUTLINE object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the OTHER_OUTLINE section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1698,47 +1736,36 @@
 
             if( olnOther.insert( pair<string, OTHER_OUTLINE*>(op->GetOutlineIdentifier(), op) ).second == false )
             {
-                ERROR_IDF;
-                cerr << "* Violation of specification. Non-unique ID in OTHER_OUTLINE '";
-                cerr << op->GetOutlineIdentifier() << "'\n";
                 delete op;
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
+
+                ostringstream ostr;
+                ostr << "invalid IDFv3 file\n";
+                ostr << "* Violation of specification. Non-unique ID in OTHER_OUTLINE '";
+                ostr << op->GetOutlineIdentifier() << "'\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* pos: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".ROUTE_OUTLINE", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_OUTLINE\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_OUTLINE" ) );
 
-            ROUTE_OUTLINE* op = new ROUTE_OUTLINE;
+            ROUTE_OUTLINE* op = new ROUTE_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create ROUTE_OUTLINE object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create ROUTE_OUTLINE object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the ROUTE_OUTLINE section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1754,39 +1781,24 @@
 
             olnRoute.push_back( op );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".PLACE_OUTLINE", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_OUTLINE\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_OUTLINE" ) );
 
-            PLACE_OUTLINE* op = new PLACE_OUTLINE;
+            PLACE_OUTLINE* op = new PLACE_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create PLACE_OUTLINE object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create PLACE_OUTLINE object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the PLACE_OUTLINE section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1802,39 +1814,24 @@
 
             olnPlace.push_back( op );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".ROUTE_KEEPOUT", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_KEEPOUT\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .ROUTE_KEEPOUT" ) );
 
-            ROUTE_KO_OUTLINE* op = new ROUTE_KO_OUTLINE;
+            ROUTE_KO_OUTLINE* op = new ROUTE_KO_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create ROUTE_KEEPOUT object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create ROUTE_KEEPOUT object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the ROUTE_KEEPOUT section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1850,39 +1847,24 @@
 
             olnRouteKeepout.push_back( op );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".VIA_KEEPOUT", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .VIA_KEEPOUT\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .VIA_KEEPOUT" ) );
 
-            VIA_KO_OUTLINE* op = new VIA_KO_OUTLINE;
+            VIA_KO_OUTLINE* op = new VIA_KO_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create VIA_KEEPOUT object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create VIA_KEEPOUT object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the VIA_KEEPOUT section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1898,39 +1880,24 @@
 
             olnViaKeepout.push_back( op );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".PLACE_KEEPOUT", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_KEEPOUT\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_KEEPOUT" ) );
 
-            PLACE_KO_OUTLINE* op = new PLACE_KO_OUTLINE;
+            PLACE_KO_OUTLINE* op = new PLACE_KO_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create PLACE_KEEPOUT object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create PLACE_KEEPOUT object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the PLACE_KEEPOUT section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1946,39 +1913,24 @@
 
             olnPlaceKeepout.push_back( op );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".PLACE_REGION", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_REGION\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACE_REGION" ) );
 
-            GROUP_OUTLINE* op = new GROUP_OUTLINE;
+            GROUP_OUTLINE* op = new GROUP_OUTLINE( this );
 
             if( op == NULL )
-            {
-                ERROR_IDF;
-                cerr << "could not create PLACE_REGION object\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "could not create PLACE_REGION object" ) );
 
             op->SetUnit( unit );
-
-            if( !op->ReadData( aBoardFile, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading the PLACE_REGION section\n";
-                aBoardState = IDF3::FILE_ERROR;
-                return false;
-            }
+            op->readData( aBoardFile, iline );
 
             if( !comments.empty() )
             {
@@ -1994,28 +1946,17 @@
 
             olnGroup.insert( pair<string, GROUP_OUTLINE*>(op->GetGroupName(), op) );
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".DRILLED_HOLES", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .DRILLED_HOLES\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .DRILLED_HOLES" ) );
 
-            if( !readBrdDrills( aBoardFile, aBoardState ) )
-            {
-                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
-                {
-                    ERROR_IDF << "could not read board DRILLED HOLES section\n";
-                    return false;
-                }
-            }
+            readBrdDrills( aBoardFile, aBoardState );
 
             if( !comments.empty() )
             {
@@ -2029,28 +1970,17 @@
                 }
             }
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".NOTES", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .NOTES\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .NOTES" ) );
 
-            if( !readBrdNotes( aBoardFile, aBoardState ) )
-            {
-                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
-                {
-                    ERROR_IDF << "could not read board NOTES section\n";
-                    return false;
-                }
-            }
+            readBrdNotes( aBoardFile, aBoardState );
 
             if( !comments.empty() )
             {
@@ -2064,28 +1994,17 @@
                 }
             }
 
-            return true;
+            return;
         }
 
         if( CompareToken( ".PLACEMENT", token ) )
         {
             if( aBoardState != IDF3::FILE_OUTLINE )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 file\n";
-                cerr << "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACEMENT\n";
-                aBoardState = IDF3::FILE_INVALID;
-                return false;
-            }
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                  "invalid IDFv3 file\n"
+                                  "* Violation of specification: expecting .BOARD_OUTLINE, have .PLACEMENT" ) );
 
-            if( !readBrdPlacement( aBoardFile, aBoardState ) )
-            {
-                if( !aBoardFile.good() || aBoardState == IDF3::FILE_INVALID )
-                {
-                    ERROR_IDF << "could not read board PLACEMENT section\n";
-                    return false;
-                }
-            }
+            readBrdPlacement( aBoardFile, aBoardState );
 
             if( !comments.empty() )
             {
@@ -2099,129 +2018,122 @@
                 }
             }
 
-            return true;
+            return;
         }
     }   // while( aBoardFile.good()
 
-    if( !aBoardFile.good() )
-    {
-        if( !aBoardFile.eof() || aBoardState < IDF3::FILE_OUTLINE || aBoardState >= IDF3::FILE_INVALID )
-        {
-            ERROR_IDF;
-            cerr << "problems reading board section\n";
-            aBoardState = IDF3::FILE_INVALID;
-            return false;
-        }
-    }
-
-    return true;
+    return;
 }   // readBrdSection()
 
 
 // read the board file data
-bool IDF3_BOARD::readBoardFile( const std::string& aFileName )
+void IDF3_BOARD::readBoardFile( const std::string& aFileName )
 {
     std::ifstream brd;
 
-    brd.open( aFileName.c_str(), std::ios_base::in );
-
-    if( !brd.is_open() )
-    {
-        ERROR_IDF;
-        cerr << "could not open file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    std::string iline;      // the input line
-    bool isComment;         // true if a line just read in is a comment line
-    std::streampos pos;
-    IDF3::FILE_STATE state = IDF3::FILE_START;
-
-    // note: as per IDFv3 specification:
-    //      "The Header section must be the first section in the file, the second
-    //       section must be the Outline section, and the last section must be the
-    //       Placement section. All other sections may be in any order."
-
-    // further notes: Except for the HEADER section, sections may be preceeded by
-    // comment lines which will be copied back out on write(). No comments may
-    // be associated with the board file itself since the only logical location
-    // for unambiguous association is at the end of the file, which is inconvenient
-    // for large files.
-
-    if( !readBrdHeader( brd, state ) )
-    {
-        ERROR_IDF;
-        cerr << "could not find a valid header\n";
-        brd.close();
-        return false;
-    }
-
-    // read the various sections
-    while( readBrdSection( brd, state ) && state != IDF3::FILE_PLACEMENT && !brd.eof() );
-
-    if( state == IDF3::FILE_INVALID )
-    {
-        brd.close();
-        ERROR_IDF;
-        cerr << "problems reading file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    if( !brd.good() )
-    {
-        // check if we have valid data
-        if( brd.eof() && state >= IDF3::FILE_OUTLINE && state < IDF3::FILE_INVALID )
+    brd.exceptions ( std::ifstream::badbit );
+
+    try
+    {
+        brd.open( aFileName.c_str(), std::ios_base::in );
+
+        if( !brd.is_open() )
         {
-            brd.close();
-            return true;
+            ostringstream ostr;
+            ostr << "\n* could not open file: '" << aFileName << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
-        brd.close();
-        ERROR_IDF;
-        cerr << "problems reading file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    if( brd.good() && state == IDF3::FILE_PLACEMENT )
-    {
-        // read in any trailing lines and report on ignored comments (minor fault)
-        // and any non-comment item (non-compliance with IDFv3)
-        while( brd.good() )
+        std::string iline;      // the input line
+        bool isComment;         // true if a line just read in is a comment line
+        std::streampos pos;
+        IDF3::FILE_STATE state = IDF3::FILE_START;
+
+        // note: as per IDFv3 specification:
+        //      "The Header section must be the first section in the file, the second
+        //       section must be the Outline section, and the last section must be the
+        //       Placement section. All other sections may be in any order."
+
+        // further notes: Except for the HEADER section, sections may be preceeded by
+        // comment lines which will be copied back out on write(). No comments may
+        // be associated with the board file itself since the only logical location
+        // for unambiguous association is at the end of the file, which is inconvenient
+        // for large files.
+
+        readBrdHeader( brd, state );
+
+        // read the various sections
+        while( state != IDF3::FILE_PLACEMENT && brd.good() )
+            readBrdSection( brd, state );
+
+        if( !brd.good() )
         {
-            while( !FetchIDFLine( brd, iline, isComment, pos ) && brd.good() );
-
-            // normally this is a fault but we have all the data in accordance with specs
-            if( ( !brd.good() && !brd.eof() ) || iline.empty() )
-                break;
-
-            if( isComment )
-            {
-                ERROR_IDF << "[warning]: trailing comments after PLACEMENT\n";
-            }
-            else
-            {
-                ERROR_IDF << "invalid IDF3 file\n";
-                cerr << "* Violation of specification: non-comment lines after PLACEMENT section\n";
-                Clear();
+            // check if we have valid data
+            if( brd.eof() && state >= IDF3::FILE_OUTLINE && state < IDF3::FILE_INVALID )
+            {
                 brd.close();
-                return false;
-            }
-        }
+                return;
+            }
+
+            brd.close();
+
+            ostringstream ostr;
+            ostr << "\n* empty IDF file: '" << aFileName << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        if( brd.good() && state == IDF3::FILE_PLACEMENT )
+        {
+            // read in any trailing lines and report on ignored comments (minor fault)
+            // and any non-comment item (non-compliance with IDFv3)
+            while( brd.good() )
+            {
+                while( !FetchIDFLine( brd, iline, isComment, pos ) && brd.good() );
+
+                // normally this is a fault but we have all the data in accordance with specs
+                if( ( !brd.good() && !brd.eof() ) || iline.empty() )
+                    break;
+
+                if( isComment )
+                {
+                    ERROR_IDF << "[warning]: trailing comments after PLACEMENT\n";
+                }
+                else
+                {
+                    ostringstream ostr;
+                    ostr << "\n* problems reading file: '" << aFileName << "'";
+
+                    throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                                      "invalid IDF3 file\n"
+                                      "* Violation of specification: non-comment lines after PLACEMENT section" ) );
+                }
+            }
+        }
+    }
+    catch( std::exception& e )
+    {
+        brd.exceptions ( std::ios_base::goodbit );
+
+        if( brd.is_open() )
+            brd.close();
+
+        throw;
     }
 
     brd.close();
-    return true;
+    return;
 } // readBoardFile()
 
 
 // read the library sections (outlines)
-bool IDF3_BOARD::readLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard )
+void IDF3_BOARD::readLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard )
 {
     if( aBoard == NULL )
     {
-        ERROR_IDF << "BUG: invoked with NULL reference aBoard\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* BUG: invoked with NULL reference aBoard" ) );
     }
 
     std::list< std::string > comments;  // comments associated with a section
@@ -2233,23 +2145,23 @@
     int idx = 0;
     bool quoted = false;
     std::string token;
-    IDF3_COMP_OUTLINE *pout = new IDF3_COMP_OUTLINE;
+    IDF3_COMP_OUTLINE *pout = new IDF3_COMP_OUTLINE( this );
+
+    if( !pout )
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "\n* memory allocation failure" ) );
 
     while( aLibFile.good() )
     {
         while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
 
         if( !aLibFile.good() && !aLibFile.eof() )
-        {
-            ERROR_IDF;
-            cerr << "problems reading library section\n";
-            aLibState = IDF3::FILE_INVALID;
-            return false;
-        }
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                              "problems reading library section" ) );
 
         // no data was read; this only happens at eof()
         if( iline.empty() )
-            return true;
+            return;
 
         if( isComment )
         {
@@ -2258,32 +2170,22 @@
         }
 
         // This must be a header
-        if( !GetIDFString( iline, token, quoted, idx ) )
-        {
-            ERROR_IDF;
-            cerr << "problems reading library section\n";
-            aLibState = IDF3::FILE_INVALID;
-            return false;
-        }
+        GetIDFString( iline, token, quoted, idx );
 
         if( quoted )
         {
-            ERROR_IDF;
-            cerr << "invalid IDFv3 library\n";
-            cerr << "* Violation of specification: quoted string where .ELECTRICAL or .MECHANICAL expected\n";
-            aLibState = IDF3::FILE_INVALID;
-            return false;
+            ostringstream ostr;
+            ostr << "invalid IDFv3 library\n";
+            ostr << "* Violation of specification: quoted string where .ELECTRICAL or .MECHANICAL expected\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* pos: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
 
         if( CompareToken( ".ELECTRICAL", token ) || CompareToken( ".MECHANICAL", token ) )
         {
-            if( !pout->ReadData( aLibFile, token ) )
-            {
-                ERROR_IDF;
-                cerr << "invalid IDFv3 library [faulty section]\n";
-                aLibState = IDF3::FILE_INVALID;
-                return false;
-            }
+            pout->readData( aLibFile, token );
 
             if( !comments.empty() )
             {
@@ -2305,33 +2207,42 @@
             }
             else
             {
-                ERROR_IDF;
-                cerr << "duplicate Component Outline: '" << pout->GetUID() << "'\n";
                 delete pout;
+
+                ostringstream ostr;
+                ostr << "invalid IDFv3 library\n";
+                ostr << "duplicate Component Outline: '" << pout->GetUID() << "'\n";
+                ostr << "* Violation of specification: multiple outlines have the same GEOM and PART name\n";
+                ostr << "* line: '" << iline << "'\n";
+                ostr << "* pos: " << pos;
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
             }
 
-            return true;
+            return;
         }
         else
         {
-            ERROR_IDF;
-            cerr << "invalid IDFv3 library\n";
-            cerr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << token << "'\n";
-            aLibState = IDF3::FILE_INVALID;
-            return false;
+            ostringstream ostr;
+            ostr << "invalid IDFv3 library\n";
+            ostr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << token << "'\n";
+            ostr << "* line: '" << iline << "'\n";
+            ostr << "* pos: " << pos;
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
         }
-
     }
 
-    ERROR_IDF;
-    cerr << "problems reading library section\n";
-    aLibState = IDF3::FILE_INVALID;
-    return false;
+    if( !aLibFile.eof() )
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading IDF library file" ) );
+
+    return;
 }
 
 
 // read the library HEADER
-bool IDF3_BOARD::readLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState )
+void IDF3_BOARD::readLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState )
 {
     std::string iline;      // the input line
     bool isComment;         // true if a line just read in is a comment line
@@ -2344,30 +2255,20 @@
     while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
 
     if( !aLibFile.good() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading library header\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* premature end of file (no HEADER)" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: first line must be .HEADER\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification: first line must be .HEADER" ) );
 
     if( !CompareToken( ".HEADER", iline ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: first line must be .HEADER and have no quotes or trailing text\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* first line must be .HEADER and have no quotes or trailing text" ) );
 
     // RECORD 2:
     //      File Type [str]: LIBRARY_FILE
@@ -2378,99 +2279,74 @@
     while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
 
     if( !aLibFile.good() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading library header, RECORD 2\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* premature end of HEADER" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: comment within .HEADER section\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification: comment within .HEADER section" ) );
 
     idx = 0;
     GetIDFString( iline, token, quoted, idx );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: File Type in HEADER section must not be in quotes\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* file Type in HEADER section must not be in quotes" ) );
 
     if( !CompareToken( "LIBRARY_FILE", token ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Expecting string: LIBRARY_FILE (got '" << token << "')\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "invalid IDFv3 library\n";
+        ostr << "* Expecting string: LIBRARY_FILE (got '" << token << "')\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2: no FIELD 2\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification: HEADER section, RECORD 2: no FIELD 2" ) );
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: IDF Version must not be in quotes\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification: IDF Version must not be in quotes" ) );
 
     if( token.compare( "3.0" ) && token.compare( "3." ) && token.compare( "3" ) )
     {
-        ERROR_IDF;
-        cerr << "unsupported IDF library version\n";
-        cerr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "unsupported IDF library version\n";
+        ostr << "* Expecting version to be one of '3.0', '3.', or '3' (value: '" << token << "')\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 3: no Source System string\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 3: no Source System string" ) );
+
     libSource = token;
 
-
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 4: no Date string\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 4: no Date string" ) );
+
     libDate = token;
 
     if( !GetIDFString( iline, token, quoted, idx ) )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification for HEADER section, RECORD 2, FIELD 5: no Board File Version number\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 5: no Board File Version number" ) );
+
     std::istringstream istr;
     istr.str( token );
 
@@ -2484,86 +2360,67 @@
     }
 
     if( quoted )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: HEADER section, RECORD 2, FIELD 5: Library File Version must not be in quotes\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification:\n"
+                          "* HEADER section, RECORD 2, FIELD 5: Library File Version must not be in quotes" ) );
 
     // RECORD 3:
     //      .END_HEADER
     while( !FetchIDFLine( aLibFile, iline, isComment, pos ) && aLibFile.good() );
 
     if( ( !aLibFile.good() && !aLibFile.eof() ) || iline.empty() )
-    {
-        ERROR_IDF;
-        cerr << "problems reading library header, RECORD 3\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "problems reading library header, RECORD 3" ) );
 
     if( isComment )
-    {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 library\n";
-        cerr << "* Violation of specification: comment within .HEADER section\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
-    }
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__,
+                          "invalid IDFv3 library file\n"
+                          "* Violation of specification: comment within .HEADER section" ) );
 
     if( !CompareToken( ".END_HEADER", iline ) )
     {
-        ERROR_IDF;
-        cerr << "invalid IDFv3 header\n";
-        cerr << "* Violation of specification: expected .END_HEADER (got '" << iline << "')\n";
-        aLibState = IDF3::FILE_INVALID;
-        return false;
+        ostringstream ostr;
+        ostr << "invalid IDFv3 header\n";
+        ostr << "* Violation of specification: expected .END_HEADER (got '" << iline << "')\n";
+
+        throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
     }
 
     aLibState = IDF3::FILE_HEADER;
-    return true;
+    return;
 }
 
 
 // read the library file data
-bool IDF3_BOARD::readLibFile( const std::string& aFileName )
+void IDF3_BOARD::readLibFile( const std::string& aFileName )
 {
     std::ifstream lib;
 
-    lib.open( aFileName.c_str(), std::ios_base::in );
-
-    if( !lib.is_open() )
-    {
-        ERROR_IDF;
-        cerr << "could not open file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    IDF3::FILE_STATE state = IDF3::FILE_START;
-
-    if( !readLibHeader( lib, state ) )
-    {
-        ERROR_IDF;
-        cerr << "[IDF library] could not find a valid header\n";
-        lib.close();
-        return false;
-    }
-
-    // read the library sections
-    while( readLibSection( lib, state, this ) && lib.good() );
-
-    if( state <= IDF3::FILE_START || state >= IDF3::FILE_INVALID )
-    {
-        lib.close();
-        ERROR_IDF;
-        cerr << "problems reading file: '" << aFileName << "'\n";
-        return false;
+    lib.exceptions ( std::ifstream::badbit );
+
+    try
+    {
+        lib.open( aFileName.c_str(), std::ios_base::in );
+
+        IDF3::FILE_STATE state = IDF3::FILE_START;
+
+        readLibHeader( lib, state );
+
+        while( lib.good() ) readLibSection( lib, state, this );
+    }
+    catch( std::exception& e )
+    {
+        lib.exceptions ( std::ios_base::goodbit );
+
+        if( lib.is_open() )
+            lib.close();
+
+        throw;
     }
 
     lib.close();
-    return true;
+    return;
 }
 
 
@@ -2583,331 +2440,367 @@
 
     std::string bfname = TO_UTF8( aFullFileName );
 
-    if( !brdname.IsOk() )
-    {
-        ERROR_IDF;
-        cerr << "invalid file name: '" << bfname << "'\n";
-        return false;
-    }
-
-    if( !brdname.IsOk() )
-    {
-        ERROR_IDF;
-        cerr << "invalid file name: '" << bfname << "'\n";
-        return false;
-    }
-
-    if( !brdname.FileExists() )
-    {
-        ERROR_IDF;
-        cerr << "no such file: '" << bfname  << "'\n";
-        return false;
-    }
-
-    if( !brdname.IsFileReadable() )
-    {
-        ERROR_IDF;
-        cerr << "cannot read file: '" << bfname << "'\n";
-        return false;
-    }
-
-    bfname = TO_UTF8( brdname.GetFullPath() );
-    std::string lfname = TO_UTF8( libname.GetFullPath() );
-
-    if( !libname.FileExists() )
-    {
-        ERROR_IDF;
-        cerr << "no associated library file (*.emp)\n";
-    }
-    else if( !libname.IsFileReadable() )
-    {
-        ERROR_IDF;
-        cerr << "cannot read library file: '" << lfname << "'\n";
-    }
-    else
-    {
-        // read the library file before proceeding
-        if( !readLibFile( lfname ) )
-        {
+    try
+    {
+        if( !brdname.IsOk() )
+        {
+            ostringstream ostr;
+            ostr << "\n* invalid file name: '" << bfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        if( !brdname.FileExists() )
+        {
+            ostringstream ostr;
+            ostr << "\n* no such file: '" << bfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        if( !brdname.IsFileReadable() )
+        {
+            ostringstream ostr;
+            ostr << "\n* cannot read file: '" << bfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        bfname = TO_UTF8( brdname.GetFullPath() );
+        std::string lfname = TO_UTF8( libname.GetFullPath() );
+
+        if( !libname.FileExists() )
+        {
+            // NOTE: Since this is a common case we simply proceed
+            // with the assumption that there is no library file;
+            // however we print a message to inform the user.
             ERROR_IDF;
-            cerr << "problems reading library file: '" << lfname << "'\n";
-            return false;
-        }
+            cerr << "no associated library file (*.emp)\n";
+        }
+        else if( !libname.IsFileReadable() )
+        {
+            ostringstream ostr;
+            ostr << "\n* cannot read library file: '" << lfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+        else
+        {
+            // read the library file before proceeding
+            readLibFile( lfname );
+        }
+
+        // read the board file
+        readBoardFile( bfname );
     }
-
-    // read the board file
-    if( !readBoardFile( bfname ) )
+    catch( std::exception& e )
     {
         Clear();
-        ERROR_IDF;
-        cerr << "problems reading board file: '" << lfname << "'\n";
+        errormsg = e.what();
+
         return false;
     }
 
     return true;
 }
 
+
 // write the library file data
 bool IDF3_BOARD::writeLibFile( const std::string& aFileName )
 {
     std::ofstream lib;
-
-    lib.open( aFileName.c_str(), std::ios_base::out );
-
-    if( !lib.is_open() )
-    {
-        ERROR_IDF;
-        cerr << "could not open library file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    wxDateTime tdate( time( NULL ) );
-
-    if( idfSource.empty() )
-        idfSource = "KiCad-IDF Framework";
-
-    ostringstream fileDate;
-    fileDate << setfill( '0' ) << setw(4) << tdate.GetYear();
-    fileDate << "/" << setw(2) << tdate.GetMonth() << "/" << tdate.GetDay();
-    fileDate << "." << tdate.GetHour() << ":" << tdate.GetMinute() << ":" << tdate.GetSecond();
-    libDate = fileDate.str();
-
-    lib << ".HEADER\n";
-    lib << "LIBRARY_FILE 3.0 \"Created by " << idfSource;
-    lib << "\" " << libDate << " " << (++libFileVersion) << "\n";
-    lib << ".END_HEADER\n\n";
-
-    std::map< std::string, IDF3_COMP_OUTLINE*>::iterator its = compOutlines.begin();
-    std::map< std::string, IDF3_COMP_OUTLINE*>::iterator ite = compOutlines.end();
-
-    while( its != ite )
-    {
-        its->second->WriteData( lib );
-        ++its;
-    }
-
-    bool ok = !lib.fail();
+    lib.exceptions( std::ofstream::failbit );
+
+    try
+    {
+        lib.open( aFileName.c_str(), std::ios_base::out );
+
+        wxDateTime tdate( time( NULL ) );
+
+        if( idfSource.empty() )
+            idfSource = "KiCad-IDF Framework";
+
+        ostringstream fileDate;
+        fileDate << setfill( '0' ) << setw(4) << tdate.GetYear();
+        fileDate << "/" << setw(2) << tdate.GetMonth() << "/" << tdate.GetDay();
+        fileDate << "." << tdate.GetHour() << ":" << tdate.GetMinute() << ":" << tdate.GetSecond();
+        libDate = fileDate.str();
+
+        lib << ".HEADER\n";
+        lib << "LIBRARY_FILE 3.0 \"Created by " << idfSource;
+        lib << "\" " << libDate << " " << (++libFileVersion) << "\n";
+        lib << ".END_HEADER\n\n";
+
+        std::map< std::string, IDF3_COMP_OUTLINE*>::iterator its = compOutlines.begin();
+        std::map< std::string, IDF3_COMP_OUTLINE*>::iterator ite = compOutlines.end();
+
+        while( its != ite )
+        {
+            its->second->writeData( lib );
+            ++its;
+        }
+
+    }
+    catch( std::exception& e )
+    {
+        lib.exceptions( std::ios_base::goodbit );
+
+        if( lib.is_open() )
+            lib.close();
+
+        throw;
+    }
 
     lib.close();
 
-    return ok;
+    return true;
 }
 
 // write the board file data
-bool IDF3_BOARD::writeBoardFile( const std::string& aFileName )
+void IDF3_BOARD::writeBoardFile( const std::string& aFileName )
 {
     std::ofstream brd;
-
-    brd.open( aFileName.c_str(), std::ios_base::out );
-
-    if( !brd.is_open() )
-    {
-        ERROR_IDF;
-        cerr << "could not open board file: '" << aFileName << "'\n";
-        return false;
-    }
-
-    wxDateTime tdate( time( NULL ) );
-
-    if( idfSource.empty() )
-        idfSource = "KiCad-IDF Framework";
-
-    ostringstream fileDate;
-    fileDate << setfill( '0' ) << setw(4) << tdate.GetYear();
-    fileDate << "/" << setw(2) << tdate.GetMonth() << "/" << tdate.GetDay();
-    fileDate << "." << tdate.GetHour() << ":" << tdate.GetMinute() << ":" << tdate.GetSecond();
-    brdDate = fileDate.str();
-
-    brd << ".HEADER\n";
-    brd << "BOARD_FILE 3.0 \"Created by " << idfSource;
-    brd << "\" " << brdDate << " " << (++brdFileVersion) << "\n";
-
-    if( boardName.empty() )
-        brd << "\"BOARD WITH NO NAME\" ";
-    else
-        brd << "\"" << boardName << "\" ";
-
-    brd << setw(1) << setfill( ' ' );
-
-    if( unit == IDF3::UNIT_MM )
-        brd << "MM\n";
-    else
-        brd << "THOU\n";
-
-    brd << ".END_HEADER\n\n";
-
-    // write the BOARD_OUTLINE
-    if( !olnBoard.WriteData( brd ) )
-    {
-        ERROR_IDF << "problems writing BOARD OUTLINE\n";
-        brd.close();
-        return false;
-    }
-
-    // OTHER outlines
-    do
-    {
-        std::map<std::string, OTHER_OUTLINE*>::iterator its = olnOther.begin();
-        std::map<std::string, OTHER_OUTLINE*>::iterator ite = olnOther.end();
-
-        while( (its != ite) && its->second->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // ROUTE outlines
-    do
-    {
-        std::list<ROUTE_OUTLINE*>::iterator its = olnRoute.begin();
-        std::list<ROUTE_OUTLINE*>::iterator ite = olnRoute.end();
-
-        while( (its != ite) && (*its)->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // PLACEMENT outlines
-    do
-    {
-        std::list<PLACE_OUTLINE*>::iterator its = olnPlace.begin();
-        std::list<PLACE_OUTLINE*>::iterator ite = olnPlace.end();
-
-        while( (its != ite) && (*its)->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // ROUTE KEEPOUT outlines
-    do
-    {
-        std::list<ROUTE_KO_OUTLINE*>::iterator its = olnRouteKeepout.begin();
-        std::list<ROUTE_KO_OUTLINE*>::iterator ite = olnRouteKeepout.end();
-
-        while( (its != ite) && (*its)->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // VIA KEEPOUT outlines
-    do
-    {
-        std::list<VIA_KO_OUTLINE*>::iterator its = olnViaKeepout.begin();
-        std::list<VIA_KO_OUTLINE*>::iterator ite = olnViaKeepout.end();
-
-        while( (its != ite) && (*its)->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // PLACE KEEPOUT outlines
-    do
-    {
-        std::list<PLACE_KO_OUTLINE*>::iterator its = olnPlaceKeepout.begin();
-        std::list<PLACE_KO_OUTLINE*>::iterator ite = olnPlaceKeepout.end();
-
-        while( (its != ite) && (*its)->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // PLACEMENT GROUP outlines
-    do
-    {
-        std::map<std::string, GROUP_OUTLINE*>::iterator its = olnGroup.begin();
-        std::map<std::string, GROUP_OUTLINE*>::iterator ite = olnGroup.end();
-
-        while( (its != ite) && its->second->WriteData( brd ) ) ++its;
-
-    } while( 0 );
-
-    // Drilled holes
-    do
-    {
-        std::list<std::string>::iterator itds = drillComments.begin();
-        std::list<std::string>::iterator itde = drillComments.end();
-
-        while( itds != itde )
-        {
-            brd << "# " << *itds << "\n";
-            ++itds;
-        }
-
-        brd << ".DRILLED_HOLES\n";
-
-        std::list<IDF_DRILL_DATA*>::iterator itbs = board_drills.begin();
-        std::list<IDF_DRILL_DATA*>::iterator itbe = board_drills.end();
-
-        while( itbs != itbe )
-        {
-            (*itbs)->Write( brd, unit );
-            ++itbs;
-        }
-
-        std::map< std::string, IDF3_COMPONENT*>::iterator itcs = components.begin();
-        std::map< std::string, IDF3_COMPONENT*>::iterator itce = components.end();
-
-        while( itcs != itce )
-        {
-            itcs->second->WriteDrillData( brd );
-            ++itcs;
-        }
-
-        brd << ".END_DRILLED_HOLES\n\n";
-    } while( 0 );
-
-    // Notes
-    if( !notes.empty() )
-    {
-        std::list<std::string>::iterator itncs = noteComments.begin();
-        std::list<std::string>::iterator itnce = noteComments.end();
-
-        while( itncs != itnce )
-        {
-            brd << "# " << *itncs << "\n";
-            ++itncs;
-        }
-
-        brd << ".NOTES\n";
-
-        std::list<IDF_NOTE*>::iterator itns = notes.begin();
-        std::list<IDF_NOTE*>::iterator itne = notes.end();
-
-        while( itns != itne )
-        {
-            (*itns)->WriteNote( brd, unit );
-            ++itns;
-        }
-
-        brd << ".END_NOTES\n\n";
-
-    }
-
-    // Placement
-    if( !components.empty() )
-    {
-        std::list<std::string>::iterator itpcs = placeComments.begin();
-        std::list<std::string>::iterator itpce = placeComments.end();
-
-        while( itpcs != itpce )
-        {
-            brd << "# " << *itpcs << "\n";
-            ++itpcs;
-        }
-
-        std::map< std::string, IDF3_COMPONENT*>::iterator itcs = components.begin();
-        std::map< std::string, IDF3_COMPONENT*>::iterator itce = components.end();
-
-        brd << ".PLACEMENT\n";
-
-        while( itcs != itce )
-        {
-            itcs->second->WritePlaceData( brd );
-            ++itcs;
-        }
-
-        brd << ".END_PLACEMENT\n";
-    }
-
-    bool ok = !brd.fail();
+    brd.exceptions( std::ofstream::failbit );
+
+    try
+    {
+        brd.open( aFileName.c_str(), std::ios_base::out );
+
+        wxDateTime tdate( time( NULL ) );
+
+        if( idfSource.empty() )
+            idfSource = "KiCad-IDF Framework";
+
+        ostringstream fileDate;
+        fileDate << setfill( '0' ) << setw(4) << tdate.GetYear();
+        fileDate << "/" << setw(2) << tdate.GetMonth() << "/" << tdate.GetDay();
+        fileDate << "." << tdate.GetHour() << ":" << tdate.GetMinute() << ":" << tdate.GetSecond();
+        brdDate = fileDate.str();
+
+        brd << ".HEADER\n";
+        brd << "BOARD_FILE 3.0 \"Created by " << idfSource;
+        brd << "\" " << brdDate << " " << (++brdFileVersion) << "\n";
+
+        if( boardName.empty() )
+            brd << "\"BOARD WITH NO NAME\" ";
+        else
+            brd << "\"" << boardName << "\" ";
+
+        brd << setw(1) << setfill( ' ' );
+
+        if( unit == IDF3::UNIT_MM )
+            brd << "MM\n";
+        else
+            brd << "THOU\n";
+
+        brd << ".END_HEADER\n\n";
+
+        // write the BOARD_OUTLINE
+        olnBoard.writeData( brd );
+
+        // OTHER outlines
+        do
+        {
+            std::map<std::string, OTHER_OUTLINE*>::iterator its = olnOther.begin();
+            std::map<std::string, OTHER_OUTLINE*>::iterator ite = olnOther.end();
+
+            while(its != ite )
+            {
+                its->second->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // ROUTE outlines
+        do
+        {
+            std::list<ROUTE_OUTLINE*>::iterator its = olnRoute.begin();
+            std::list<ROUTE_OUTLINE*>::iterator ite = olnRoute.end();
+
+            while( its != ite )
+            {
+                (*its)->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // PLACEMENT outlines
+        do
+        {
+            std::list<PLACE_OUTLINE*>::iterator its = olnPlace.begin();
+            std::list<PLACE_OUTLINE*>::iterator ite = olnPlace.end();
+
+            while( its != ite )
+            {
+                (*its)->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // ROUTE KEEPOUT outlines
+        do
+        {
+            std::list<ROUTE_KO_OUTLINE*>::iterator its = olnRouteKeepout.begin();
+            std::list<ROUTE_KO_OUTLINE*>::iterator ite = olnRouteKeepout.end();
+
+            while( its != ite )
+            {
+                (*its)->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // VIA KEEPOUT outlines
+        do
+        {
+            std::list<VIA_KO_OUTLINE*>::iterator its = olnViaKeepout.begin();
+            std::list<VIA_KO_OUTLINE*>::iterator ite = olnViaKeepout.end();
+
+            while( its != ite )
+            {
+                (*its)->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // PLACE KEEPOUT outlines
+        do
+        {
+            std::list<PLACE_KO_OUTLINE*>::iterator its = olnPlaceKeepout.begin();
+            std::list<PLACE_KO_OUTLINE*>::iterator ite = olnPlaceKeepout.end();
+
+            while( its != ite )
+            {
+                (*its)->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // PLACEMENT GROUP outlines
+        do
+        {
+            std::map<std::string, GROUP_OUTLINE*>::iterator its = olnGroup.begin();
+            std::map<std::string, GROUP_OUTLINE*>::iterator ite = olnGroup.end();
+
+            while( its != ite )
+            {
+                its->second->writeData( brd );
+                ++its;
+            }
+
+        } while( 0 );
+
+        // Drilled holes
+        do
+        {
+            std::list<std::string>::iterator itds = drillComments.begin();
+            std::list<std::string>::iterator itde = drillComments.end();
+
+            while( itds != itde )
+            {
+                brd << "# " << *itds << "\n";
+                ++itds;
+            }
+
+            brd << ".DRILLED_HOLES\n";
+
+            std::list<IDF_DRILL_DATA*>::iterator itbs = board_drills.begin();
+            std::list<IDF_DRILL_DATA*>::iterator itbe = board_drills.end();
+
+            while( itbs != itbe )
+            {
+                (*itbs)->write( brd, unit );
+                ++itbs;
+            }
+
+            std::map< std::string, IDF3_COMPONENT*>::iterator itcs = components.begin();
+            std::map< std::string, IDF3_COMPONENT*>::iterator itce = components.end();
+
+            while( itcs != itce )
+            {
+                itcs->second->writeDrillData( brd );
+                ++itcs;
+            }
+
+            brd << ".END_DRILLED_HOLES\n\n";
+        } while( 0 );
+
+        // Notes
+        if( !notes.empty() )
+        {
+            std::list<std::string>::iterator itncs = noteComments.begin();
+            std::list<std::string>::iterator itnce = noteComments.end();
+
+            while( itncs != itnce )
+            {
+                brd << "# " << *itncs << "\n";
+                ++itncs;
+            }
+
+            brd << ".NOTES\n";
+
+            std::list<IDF_NOTE*>::iterator itns = notes.begin();
+            std::list<IDF_NOTE*>::iterator itne = notes.end();
+
+            while( itns != itne )
+            {
+                (*itns)->writeNote( brd, unit );
+                ++itns;
+            }
+
+            brd << ".END_NOTES\n\n";
+
+        }
+
+        // Placement
+        if( !components.empty() )
+        {
+            std::list<std::string>::iterator itpcs = placeComments.begin();
+            std::list<std::string>::iterator itpce = placeComments.end();
+
+            while( itpcs != itpce )
+            {
+                brd << "# " << *itpcs << "\n";
+                ++itpcs;
+            }
+
+            std::map< std::string, IDF3_COMPONENT*>::iterator itcs = components.begin();
+            std::map< std::string, IDF3_COMPONENT*>::iterator itce = components.end();
+
+            brd << ".PLACEMENT\n";
+
+            while( itcs != itce )
+            {
+                itcs->second->writePlaceData( brd );
+                ++itcs;
+            }
+
+            brd << ".END_PLACEMENT\n";
+        }
+
+    }
+    catch( std::exception& e )
+    {
+        brd.exceptions( std::ios_base::goodbit );
+
+        if( brd.is_open() )
+            brd.close();
+
+        throw;
+    }
+
     brd.close();
 
-    return ok;
+    return;
 }
 
+
 bool IDF3_BOARD::WriteFile( const wxString& aFullFileName, bool aUnitMM, bool aForceUnitFlag )
 {
     if( aUnitMM == IDF3::UNIT_MM )
@@ -2929,46 +2822,45 @@
 
     std::string bfname = TO_UTF8( aFullFileName );
 
-    if( !brdname.IsOk() )
-    {
-        ERROR_IDF;
-        cerr << "invalid file name: '" << bfname << "'\n";
-        errno = EINVAL;
-        return false;
-    }
-
-    if( brdname.FileExists() && !brdname.IsFileWritable() )
-    {
-        ERROR_IDF;
-        cerr << "cannot overwrite existing board file\n";
-        cerr << "* Filename: '" << bfname << "'\n";
-        errno = EACCES;
-        return false;
-    }
-
-    bfname = TO_UTF8( brdname.GetFullPath() );
-    std::string lfname = TO_UTF8( libname.GetFullPath() );
-
-    if( libname.FileExists() && !libname.IsFileWritable() )
-    {
-        ERROR_IDF;
-        cerr << "cannot overwrite existing library file\n";
-        cerr << "* Filename: '" << lfname << "'\n";
-        errno = EACCES;
-        return false;
-    }
-
-    if( !writeLibFile( lfname ) )
-    {
-        ERROR_IDF;
-        cerr << "problems writing library file: '" << lfname << "'\n";
-        return false;
-    }
-
-    if( !writeBoardFile( bfname ) )
-    {
-        ERROR_IDF;
-        cerr << "problems writing board file: '" << bfname << "'\n";
+    try
+    {
+        if( !brdname.IsOk() )
+        {
+            ostringstream ostr;
+            ostr << "\n* invalid file name: '" << bfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        if( brdname.FileExists() && !brdname.IsFileWritable() )
+        {
+            ostringstream ostr;
+            ostr << "cannot overwrite existing board file\n";
+            ostr << "* filename: '" << bfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        bfname = TO_UTF8( brdname.GetFullPath() );
+        std::string lfname = TO_UTF8( libname.GetFullPath() );
+
+        if( libname.FileExists() && !libname.IsFileWritable() )
+        {
+            ostringstream ostr;
+            ostr << "cannot overwrite existing library file\n";
+            ostr << "* filename: '" << lfname << "'";
+
+            throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+        }
+
+        writeLibFile( lfname );
+        writeBoardFile( bfname );
+
+    }
+    catch( std::exception& e )
+    {
+        errormsg = e.what();
+
         return false;
     }
 
@@ -3092,19 +2984,38 @@
 
 bool IDF3_BOARD::AddBoardOutline( IDF_OUTLINE* aOutline )
 {
-    return olnBoard.AddOutline( aOutline );
+    if( !olnBoard.AddOutline( aOutline ) )
+    {
+        errormsg = olnBoard.GetError();
+
+        return false;
+    }
+
+    return true;
 }
 
 
 bool IDF3_BOARD::DelBoardOutline( IDF_OUTLINE* aOutline )
 {
-    return olnBoard.DelOutline( aOutline );
+    if( !olnBoard.DelOutline( aOutline ) )
+    {
+        errormsg = olnBoard.GetError();
+        return false;
+    }
+
+    return true;
 }
 
 
 bool IDF3_BOARD::DelBoardOutline( size_t aIndex )
 {
-    return olnBoard.DelOutline( aIndex );
+    if( !olnBoard.DelOutline( aIndex ) )
+    {
+        errormsg = olnBoard.GetError();
+        return false;
+    }
+
+    return true;
 }
 
 
@@ -3186,7 +3097,8 @@
 
 // a slot is a deficient representation of a kicad slotted hole;
 // it is usually associated with a component but IDFv3 does not
-// provide for such an association.
+// provide for such an association. Note: this mechanism must bypass
+// the BOARD_OUTLINE ownership rules
 bool IDF3_BOARD::AddSlot( double aWidth, double aLength, double aOrientation, double aX, double aY )
 {
     if( aWidth < IDF_MIN_DIA_MM )
@@ -3255,7 +3167,7 @@
     seg = new IDF_SEGMENT( c[0], pt[3], -180.0, true );
     outline->push( seg );
 
-    return AddBoardOutline( outline );
+    return olnBoard.addOutline( outline );
 }
 
 
@@ -3462,7 +3374,7 @@
 
     std::string fname = TO_UTF8( aFullFileName );
 
-    cp = new IDF3_COMP_OUTLINE;
+    cp = new IDF3_COMP_OUTLINE( this );
 
     if( cp == NULL )
     {
@@ -3500,67 +3412,66 @@
     }
 
     std::ifstream model;
-
-    model.open( fname.c_str(), std::ios_base::in );
-
-    if( !model.is_open() )
-    {
-        ERROR_IDF;
-        cerr << "could not open file: '" << fname << "'\n";
+    model.exceptions ( std::ifstream::badbit );
+
+    try
+    {
+        model.open( fname.c_str(), std::ios_base::in );
+
+
+        std::string iline;      // the input line
+        bool isComment;         // true if a line just read in is a comment line
+        std::streampos pos;
+
+
+        while( true )
+        {
+            while( !FetchIDFLine( model, iline, isComment, pos ) && model.good() );
+
+            if( !model.good() )
+            {
+                ostringstream ostr;
+                ostr << "\n* problems reading file: '" << fname << "'";
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            }
+
+            // accept comment lines, .ELECTRICAL, or .MECHANICAL only
+            if( isComment )
+            {
+                cp->AddComment( iline );
+                continue;
+            }
+
+            if( CompareToken( ".ELECTRICAL", iline ) || CompareToken( ".MECHANICAL", iline ) )
+            {
+                cp->readData( model, iline );
+                break;
+            }
+            else
+            {
+                ostringstream ostr;
+                ostr << "faulty IDF component definition\n";
+                ostr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << iline << "'\n";
+                cerr << "* File: '" << fname << "'\n";
+
+                throw( IDF_ERROR( __FILE__, __FUNCTION__, __LINE__, ostr.str() ) );
+            }
+        }   // while( true )
+    }
+    catch( std::exception& e )
+    {
         delete cp;
+
+        model.exceptions ( std::ios_base::goodbit );
+
+        if( model.is_open() )
+            model.close();
+
+        errormsg = e.what();
+
         return NULL;
     }
 
-    std::string iline;      // the input line
-    bool isComment;         // true if a line just read in is a comment line
-    std::streampos pos;
-
-    while( true )
-    {
-        while( !FetchIDFLine( model, iline, isComment, pos ) && model.good() );
-
-        if( !model.good() )
-        {
-            ERROR_IDF;
-            cerr << "problems reading file: '" << fname << "'\n";
-            delete cp;
-            model.close();
-            return NULL;
-        }
-
-        // accept comment lines, .ELECTRICAL, or .MECHANICAL only
-        if( isComment )
-        {
-            cp->AddComment( iline );
-            continue;
-        }
-
-        if( CompareToken( ".ELECTRICAL", iline ) || CompareToken( ".MECHANICAL", iline ) )
-        {
-            if( !cp->ReadData( model, iline ) )
-            {
-                ERROR_IDF;
-                cerr << "problems reading file: '" << fname << "'\n";
-                delete cp;
-                model.close();
-                return NULL;
-            }
-            else
-            {
-                break;
-            }
-        }
-        else
-        {
-            ERROR_IDF << "faulty IDF component definition\n";
-            cerr << "* Expecting .ELECTRICAL or .MECHANICAL, got '" << iline << "'\n";
-            cerr << "* File: '" << fname << "'\n";
-            delete cp;
-            model.close();
-            return NULL;
-        }
-    }   // while( true )
-
     model.close();
 
     return cp;
@@ -3602,7 +3513,7 @@
     if( cp != NULL )
         return cp;
 
-    cp = new IDF3_COMP_OUTLINE;
+    cp = new IDF3_COMP_OUTLINE( this );
 
     if( cp == NULL )
     {
@@ -3807,7 +3718,7 @@
     } while(0);
 
     boardName.clear();
-    olnBoard.SetThickness( thickness );
+    olnBoard.setThickness( thickness );
 
     state     = FILE_START;
     unit      = UNIT_MM;

=== modified file 'utils/idftools/idf_parser.h'
--- utils/idftools/idf_parser.h	2014-05-28 06:26:46 +0000
+++ utils/idftools/idf_parser.h	2014-05-29 07:50:37 +0000
@@ -21,6 +21,22 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 
+/*
+ * NOTE: CLEANUP:
+ *  To facilitate use within a DLL:
+ *
+ *  1. all functions which throw exceptions must not be publicly available;
+ *  they must become FRIEND functions instead.
+ *
+ *  2. All objects with PRIVATE functions which throw exceptions when
+ *  invoked by a PUBLIC function must indicate success or failure
+ *  and make the exception information available via a GetError()
+ *  routine.
+ *
+ *  3. set I/O file streams to throw errors so we don't waste time
+ *  checking stream integrity everywhere.
+ */
+
 // NOTE:
 // 1. Due to the complexity of objects and the risk of accumulated
 // position errors, CAD packages should only delete or add complete
@@ -36,12 +52,6 @@
 // other unit, it is their responsibility to perform the conversion
 // to mm. Conversion back to thou may incur small rounding errors.
 
-// BUGS:
-// 1. IDF compliance: On DELETE operations, ensure that the CAD
-//    has permission to make these deletions. This is no small task;
-//    however this compliance task can be deferred since it is not
-//    essential to the immediate needs of KiCad which are IDF
-//    export and IDF->VRML conversion
 
 #ifndef IDF_PARSER_H
 #define IDF_PARSER_H
@@ -181,6 +191,7 @@
 
 class IDF3_COMPONENT
 {
+friend class IDF3_BOARD;
 private:
     std::list< IDF3_COMP_OUTLINE_DATA* > components;
     std::list< IDF_DRILL_DATA* > drills;
@@ -194,15 +205,29 @@
     std::string         refdes;         ///< Reference Description (MUST BE UNIQUE)
     IDF3_BOARD*         parent;
 
+    /**
+     * Function WriteDrillData
+     * writes the internal drill data to an IDFv3 .DRILLED_HOLES section
+     *
+     * @param aBoardFile is an IDFv3 file opened for writing
+     *
+     * @return bool: true if the operation succeeded, otherwise false
+     */
+    bool writeDrillData( std::ofstream& aBoardFile );
+
+    /**
+     * Function WritePlaceData
+     * writes the component placement data to an IDFv3 .PLACEMENT section
+     *
+     * @param aBoardFile is an IDFv3 file opened for writing
+     *
+     * @return bool: true if the operation succeeded, otherwise false
+     */
+    bool writePlaceData( std::ofstream& aBoardFile );
+
 public:
     /**
      * Constructor
-     * sets internal parameters to default values
-     */
-    IDF3_COMPONENT();
-
-    /**
-     * Constructor
      * sets the parent object and initializes other internal parameters to default values
      *
      * @param aParent is the owning IDF3_BOARD object
@@ -401,31 +426,12 @@
      * violation occurs.
      */
     void SetPlacement( IDF3::IDF_PLACEMENT aPlacementValue );
-
-    /**
-     * Function WriteDrillData
-     * writes the internal drill data to an IDFv3 .DRILLED_HOLES section
-     *
-     * @param aBoardFile is an IDFv3 file opened for writing
-     *
-     * @return bool: true if the operation succeeded, otherwise false
-     */
-    bool WriteDrillData( std::ofstream& aBoardFile );
-
-    /**
-     * Function WritePlaceData
-     * writes the component placement data to an IDFv3 .PLACEMENT section
-     *
-     * @param aBoardFile is an IDFv3 file opened for writing
-     *
-     * @return bool: true if the operation succeeded, otherwise false
-     */
-    bool WritePlaceData( std::ofstream& aBoardFile );
 };
 
 class IDF3_BOARD
 {
 private:
+    std::string errormsg;                                       // string for passing error messages to user
     std::list< IDF_NOTE* >     notes;                           // IDF notes
     std::list< std::string >   noteComments;                    // comment list for NOTES section
     std::list< std::string >   drillComments;                   // comment list for DRILL section
@@ -483,27 +489,29 @@
     bool delCompDrill( double aDia, double aXpos, double aYpos, std::string aRefDes );
 
     // read the DRILLED HOLES section
-    bool readBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    void readBrdDrills( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
     // read the NOTES section
-    bool readBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    void readBrdNotes( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
     // read the component placement section
-    bool readBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    void readBrdPlacement( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
     // read the board HEADER
-    bool readBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    void readBrdHeader( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
     // read individual board sections; pay attention to IDFv3 section specifications
-    bool readBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
+    // exception thrown on unrecoverable errors. state flag set to FILE_PLACEMENT
+    // upon reading the PLACEMENT file; according to IDFv3 this is the final section
+    void readBrdSection( std::ifstream& aBoardFile, IDF3::FILE_STATE& aBoardState );
     // read the board file data
-    bool readBoardFile( const std::string& aFileName );
+    void readBoardFile( const std::string& aFileName );
 
     // write the board file data
-    bool writeBoardFile( const std::string& aFileName );
+    void writeBoardFile( const std::string& aFileName );
 
     // read the library sections (outlines)
-    bool readLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard );
+    void readLibSection( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState, IDF3_BOARD* aBoard );
     // read the library HEADER
-    bool readLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState );
+    void readLibHeader( std::ifstream& aLibFile, IDF3::FILE_STATE& aLibState );
     // read the library file data
-    bool readLibFile( const std::string& aFileName );
+    void readLibFile( const std::string& aFileName );
 
     // write the library file data
     bool writeLibFile( const std::string& aFileName );
@@ -558,6 +566,9 @@
     const std::list< IDF_OUTLINE* >*const GetBoardOutlines( void );
 
     /// XXX - TO BE IMPLEMENTED
+    //
+    // SetBoardOutlineOwner()
+    //
     // AddDrillComment
     // AddPlacementComment
     // GetDrillComments()
@@ -652,6 +663,12 @@
 
     // clears all data
     void Clear( void );
+
+    // return error string
+    const std::string& GetError( void )
+    {
+        return errormsg;
+    }
 };
 
 #endif // IDF_PARSER_H

